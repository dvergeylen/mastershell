---
layout: default
title: "common"
date: 2021-06-25 18:12:13 +02:00
---
## Table of contents
* <a href="#7z">7z</a>
* <a href="#7za">7za</a>
* <a href="#7zr">7zr</a>
* <a href="#ab">ab</a>
* <a href="#abduco">abduco</a>
* <a href="#ack">ack</a>
* <a href="#act">act</a>
* <a href="#adb">adb</a>
* <a href="#ag">ag</a>
* <a href="#airpaste">airpaste</a>
* <a href="#alacritty">alacritty</a>
* <a href="#alex">alex</a>
* <a href="#alias">alias</a>
* <a href="#ansible">ansible</a>
* <a href="#ansible-galaxy">ansible-galaxy</a>
* <a href="#ansible-playbook">ansible-playbook</a>
* <a href="#ansiweather">ansiweather</a>
* <a href="#apg">apg</a>
* <a href="#apm">apm</a>
* <a href="#apropos">apropos</a>
* <a href="#ar">ar</a>
* <a href="#arc">arc</a>
* <a href="#arch">arch</a>
* <a href="#aria2">aria2</a>
* <a href="#aria2c">aria2c</a>
* <a href="#arp">arp</a>
* <a href="#arping">arping</a>
* <a href="#asar">asar</a>
* <a href="#asciinema">asciinema</a>
* <a href="#asdf">asdf</a>
* <a href="#assimp">assimp</a>
* <a href="#astronomer">astronomer</a>
* <a href="#astyle">astyle</a>
* <a href="#at">at</a>
* <a href="#atom">atom</a>
* <a href="#atoum">atoum</a>
* <a href="#autossh">autossh</a>
* <a href="#avrdude">avrdude</a>
* <a href="#awk">awk</a>
* <a href="#aws">aws</a>
* <a href="#aws-s3">aws s3</a>
* <a href="#aws-google-auth">aws-google-auth</a>
* <a href="#axel">axel</a>
* <a href="#az">az</a>
* <a href="#b2sum">b2sum</a>
* <a href="#babel">babel</a>
* <a href="#badblocks">badblocks</a>
* <a href="#balena">balena</a>
* <a href="#banner">banner</a>
* <a href="#base32">base32</a>
* <a href="#base64">base64</a>
* <a href="#basename">basename</a>
* <a href="#bash">bash</a>
* <a href="#bashmarks">bashmarks</a>
* <a href="#bat">bat</a>
* <a href="#batch">batch</a>
* <a href="#bc">bc</a>
* <a href="#beanstalkd">beanstalkd</a>
* <a href="#bedtools">bedtools</a>
* <a href="#behat">behat</a>
* <a href="#berks">berks</a>
* <a href="#bg">bg</a>
* <a href="#bitcoin-cli">bitcoin-cli</a>
* <a href="#black">black</a>
* <a href="#blackfire">blackfire</a>
* <a href="#blender">blender</a>
* <a href="#bmaptool">bmaptool</a>
* <a href="#boot">boot</a>
* <a href="#borg">borg</a>
* <a href="#bosh">bosh</a>
* <a href="#bower">bower</a>
* <a href="#box">box</a>
* <a href="#browser-sync">browser-sync</a>
* <a href="#bundle">bundle</a>
* <a href="#bup">bup</a>
* <a href="#buzzphrase">buzzphrase</a>
* <a href="#bw">bw</a>
* <a href="#bzip2">bzip2</a>
* <a href="#c99">c99</a>
* <a href="#cabal">cabal</a>
* <a href="#cake">cake</a>
* <a href="#calibre-server">calibre-server</a>
* <a href="#calibredb">calibredb</a>
* <a href="#cargo">cargo</a>
* <a href="#case">case</a>
* <a href="#cat">cat</a>
* <a href="#cd">cd</a>
* <a href="#chars">chars</a>
* <a href="#chcon">chcon</a>
* <a href="#chgrp">chgrp</a>
* <a href="#chisel">chisel</a>
* <a href="#chmod">chmod</a>
* <a href="#chown">chown</a>
* <a href="#chromium">chromium</a>
* <a href="#chroot">chroot</a>
* <a href="#chsh">chsh</a>
* <a href="#cksum">cksum</a>
* <a href="#clamscan">clamscan</a>
* <a href="#clang">clang</a>
* <a href="#clear">clear</a>
* <a href="#clementine">clementine</a>
* <a href="#cloc">cloc</a>
* <a href="#clockwork-cli">clockwork-cli</a>
* <a href="#cmake">cmake</a>
* <a href="#cmark">cmark</a>
* <a href="#cmp">cmp</a>
* <a href="#code">code</a>
* <a href="#coffee">coffee</a>
* <a href="#column">column</a>
* <a href="#comm">comm</a>
* <a href="#command">command</a>
* <a href="#complete">complete</a>
* <a href="#composer">composer</a>
* <a href="#conda">conda</a>
* <a href="#consul">consul</a>
* <a href="#consul-kv">consul-kv</a>
* <a href="#convert">convert</a>
* <a href="#convmv">convmv</a>
* <a href="#copyq">copyq</a>
* <a href="#cordova">cordova</a>
* <a href="#cotton">cotton</a>
* <a href="#couchdb">couchdb</a>
* <a href="#cowsay">cowsay</a>
* <a href="#cp">cp</a>
* <a href="#cpio">cpio</a>
* <a href="#cppcheck">cppcheck</a>
* <a href="#cppclean">cppclean</a>
* <a href="#cradle">cradle</a>
* <a href="#cradle-deploy">cradle deploy</a>
* <a href="#cradle-elastic">cradle elastic</a>
* <a href="#cradle-install">cradle install</a>
* <a href="#cradle-package">cradle package</a>
* <a href="#cradle-sql">cradle sql</a>
* <a href="#crontab">crontab</a>
* <a href="#cryfs">cryfs</a>
* <a href="#crystal">crystal</a>
* <a href="#csc">csc</a>
* <a href="#csslint">csslint</a>
* <a href="#csvclean">csvclean</a>
* <a href="#csvcut">csvcut</a>
* <a href="#csvformat">csvformat</a>
* <a href="#csvgrep">csvgrep</a>
* <a href="#csvlook">csvlook</a>
* <a href="#csvpy">csvpy</a>
* <a href="#csvsort">csvsort</a>
* <a href="#csvstat">csvstat</a>
* <a href="#ctest">ctest</a>
* <a href="#curl">curl</a>
* <a href="#cut">cut</a>
* <a href="#darkhttpd">darkhttpd</a>
* <a href="#date">date</a>
* <a href="#deluge">deluge</a>
* <a href="#deluge-console">deluge-console</a>
* <a href="#deluged">deluged</a>
* <a href="#dep">dep</a>
* <a href="#detox">detox</a>
* <a href="#dexdump">dexdump</a>
* <a href="#dexter">dexter</a>
* <a href="#df">df</a>
* <a href="#dhclient">dhclient</a>
* <a href="#dhcpwn">dhcpwn</a>
* <a href="#diff">diff</a>
* <a href="#diffstat">diffstat</a>
* <a href="#dig">dig</a>
* <a href="#dircolors">dircolors</a>
* <a href="#dirname">dirname</a>
* <a href="#dirs">dirs</a>
* <a href="#dive">dive</a>
* <a href="#docker">docker</a>
* <a href="#docker-container">docker container</a>
* <a href="#docker-images">docker images</a>
* <a href="#docker-logs">docker logs</a>
* <a href="#docker-compose">docker-compose</a>
* <a href="#docker-machine">docker-machine</a>
* <a href="#dokku">dokku</a>
* <a href="#dot">dot</a>
* <a href="#dotnet">dotnet</a>
* <a href="#tldr">tldr</a>

{% raw %}
<h2 id="7z">
  <a href="/ko/common/7z.html">7z</a> <a href="#7z"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 높은 압축률을 보여주는 파일 압축 프로그램.
> 더 많은 정보: <https://www.7-zip.org/>.

#### 파일 또는 디렉토리 압축하기:
```shell
7z a {{archived.7z}} {{경로/파일명_또는_디렉토리명}}
```
#### 존재하는 압축파일 암호화(헤더를 포함한):
```shell
7z a {{encrypted.7z}} -p{{비밀번호}} -mhe=on {{archived.7z}}
```
#### 기본 디렉토리 구조로 존재하는 7z 파일 추출:
```shell
7z x {{archived.7z}}
```
#### 사용자정의 출력 경로로 압축 출력 :
```shell
7z x {{archived.7z}} -o{{경로/출력}}
```
#### 표준출력으로 압축 추출:
```shell
7z x {{archived.7z}} -so
```
#### 특정 압축 타입으로 추출:
```shell
7z a -t{{zip|gzip|bzip2|tar}} {{archived.7z}} {{경로/파일명_또는_디렉토리명}}
```
#### 사용가능한 압축 타입 리스트:
```shell
7z i
```
#### 압축 파일의 내용 리스트:
```shell
7z l {{archived.7z}}
```
{% endraw %}{% raw %}
<h2 id="7za">
  <a href="/ko/common/7za.html">7za</a> <a href="#7za"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 높은 파일 압축률을 보여주는 파일 압축 프로그램.
> 더 적은 압축 타입을 지원하는 `7z`의 독립형 버전.
> 더 많은 정보: <https://www.7-zip.org/>.

#### 파일이나 디렉토리 압축하기:
```shell
7za a {{archived.7z}} {{path/to/file_or_directory}}
```
#### 기존 디렉토리 경로에 존재하는 7z 파일 추출:
```shell
7za x {{archived}}
```
#### 특정 압축 타입을 이용하여 추출하기:
```shell
7za a -t{{zip|gzip|bzip2|tar}} {{archived}} {{path/to/file_or_directory}}
```
#### 사용가능한 압축 타입 리스트:
```shell
7za i
```
#### 압축 파일의 내용 리스트:
```shell
7za l {{archived}}
```
{% endraw %}{% raw %}
<h2 id="7zr">
  <a href="/ko/common/7zr.html">7zr</a> <a href="#7zr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 높은 파일압축률을 보여주는 압축 프로그램.
> .7z파일들만을 지원하는 `7z`의 독립형 버전.
> 더 많은 정보: <https://www.7-zip.org/>.

#### 파일이나 디렉토리 압축하기:
```shell
7zr a {{archived.7z}} {{경로/파일명_또는_디렉토리명}}
```
#### 기존 디렉토리 경로에 존재하는 7z파일 추출하기:
```shell
7zr x {{archived.7z}}
```
#### 압축 파일의 내용 리스트:
```shell
7zr l {{archived.7z}}
```
{% endraw %}{% raw %}
<h2 id="ab">
  <a href="/ko/common/ab.html">ab</a> <a href="#ab"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 아파치 벤치마킹 도구.
> 로드 테스트를 수행하는 가장 간단한 도구.
> 더 많은 정보: <https://httpd.apache.org/docs/current/programs/ab.html>.

#### 주어진 URL에 대해 100개의 HTTP GET 요청 실행:
```shell
ab -n {{100}} {{url}}
```
#### 지정된 URL에 대해 최대 10개의 요청을 동시에 처리하여 100개의 HTTP GET을 실행:
```shell
ab -n {{100}} -c {{10}} {{url}}
```
#### 생존을 유지하며 사용:
```shell
ab -k {{url}}
```
#### 벤치마킹에 사용될 최대 시간(초) 설정:
```shell
ab -t {{60}} {{url}}
```
{% endraw %}{% raw %}
<h2 id="abduco">
  <a href="/ko/common/abduco.html">abduco</a> <a href="#abduco"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 터미널 세션 관리자.
> 더 많은 정보: <http://www.brain-dump.org/projects/abduco/>.

#### 세션 목록:
```shell
abduco
```
#### 세션에 연결하기, 만약 존재하지 않는 경우에는 생성:
```shell
abduco -A {{name}} {{bash}}
```
#### `dvtm`으로 세션 연결하기, 만약 존재하지 않는 경우에는 생성:
```shell
abduco -A {{name}}
```
#### 세션으로부터 제거:
```shell
Ctrl + \
```
#### 읽기 전용 모드로 세션 연결하기:
```shell
abduco -Ar {{name}}
```
{% endraw %}{% raw %}
<h2 id="ack">
  <a href="/ko/common/ack.html">ack</a> <a href="#ack"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 프로그래머에게 최적화된 grep과 같은 검색툴.
> 더 많은 정보: <https://beyondgrep.com/documentation/>.

#### "foo"를 포함하고 있는 파일 검색:
```shell
ack {{foo}}
```
#### 특정 타입의 파일 검색:
```shell
ack --ruby {{foo}}
```
#### "foo"라는 용어와 일치하는 총 합을 계산:
```shell
ack -ch {{foo}}
```
#### "foo"를 포함하고있는 파일의 이름과 각각 파일에서 일치하는 수를 표시:
```shell
ack -cl {{foo}}
```
#### 모든 가능한 타입 리스트:
```shell
ack --help-types
```
{% endraw %}{% raw %}
<h2 id="act">
  <a href="/ko/common/act.html">act</a> <a href="#act"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Docker를 사용하여 로컬로 GitHub작업 실행.
> 더 많은 정보: <https://github.com/nektos/act>.

#### 가능한 작업들 목록:
```shell
act -l
```
#### 기본 이벤트 실행:
```shell
act
```
#### 특정 이벤트 실행:
```shell
act {{event_type}}
```
#### 특정 작업 실행:
```shell
act -a {{action_id}}
```
#### 실제론 작업을 실행하지 않기 (예 : a dry run):
```shell
act -n
```
#### 자세한 로그 표시:
```shell
act -v
```
{% endraw %}{% raw %}
<h2 id="adb">
  <a href="/ko/common/adb.html">adb</a> <a href="#adb"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 안드로이드 디버그 브릿지: 안드로이드 에뮬레이터 객체 또는 연결된 안드로이드 장치와 통신.
> 더 많은 정보: <https://developer.android.com/studio/command-line/adb>.

#### adb 서버 프로세스가 실행되고 있고, 시작하는지 확인:
```shell
adb start-server
```
#### adb 서버 프로세스 종료:
```shell
adb kill-server
```
#### 대상 에뮬레이터/장치 객체에서 원격 쉘 시작:
```shell
adb shell
```
#### 안드로이드 애플리케이션을 에뮬레이터/장치로 푸쉬:
```shell
adb install -r {{경로/파일명.apk}}
```
#### 대상 장치에서부터 파일/디렉토리를 복사:
```shell
adb pull {{경로/장치_파일명_또는_디렉토리명}} {{경로/로컬_목적지_디렉토리명}}
```
#### 대상 장치로 파일/디렉토리 복사:
```shell
adb push {{경로/로컬_파일명_또는_디렉토리명}} {{경로/장치_목적지_directory}}
```
#### 연결된 장치들의 목록 가져오기:
```shell
adb devices
```
{% endraw %}{% raw %}
<h2 id="ag">
  <a href="/ko/common/ag.html">ag</a> <a href="#ag"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> The Silver Searcher.
> ack과 비슷하지만, 더 빠르다.
> 더 많은 정보: <https://github.com/ggreer/the_silver_searcher>.

#### "foo"를 포함하고 있는 파일들을 찾고, 내용에서 일치하는 행을 출력:
```shell
ag {{foo}}
```
#### 특정 디렉토리에서 "foo"를 포함하고 있는 파일 찾기:
```shell
ag {{foo}} {{경로/디렉토리명}}
```
#### "foo"를 포함하고 있는 파일을 찾되, 파일 이름만 나열:
```shell
ag -l {{foo}}
```
#### "FOO"를 포함하고 있는 파일들을 사례별로 찾고, 전체 라인이 아닌 일치 라인만 인쇄:
```shell
ag -i -o {{FOO}}
```
#### "bar" 제목과 일치하는 파일에서 "foo" 찾기:
```shell
ag {{foo}} -G {{bar}}
```
#### 내용이 정규식과 일치하는 파일 찾기:
```shell
ag '{{^ba(r|z)$}}'
```
#### 이름이 "foo"와 일치하는 파일 찾기:
```shell
ag -g {{foo}}
```
{% endraw %}{% raw %}
<h2 id="airpaste">
  <a href="/ko/common/airpaste.html">airpaste</a> <a href="#airpaste"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 동일 네트워크 내에서 메시지와 파일들 공유.
> 더 많은 정보: <https://github.com/mafintosh/airpaste>.

#### 메시지 대기와 수신 시 표시:
```shell
airpaste
```
#### 텍스트 보내기:
```shell
echo {{텍스트}} | airpaste
```
#### 파일 보내기:
```shell
airpaste < {{경로/파일명}}
```
#### 파일 내려받기:
```shell
airpaste > {{경로/파일명}}
```
#### 채널 만들기/접속하기:
```shell
airpaste {{채널_이름}}
```
{% endraw %}{% raw %}
<h2 id="alacritty">
  <a href="/ko/common/alacritty.html">alacritty</a> <a href="#alacritty"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 교차 플랫폼으로, GPU-가속 터미널 에뮬레이터.
> 더 많은 정보: <https://github.com/alacritty/alacritty>.

#### 새 Alacritty 창 열기:
```shell
alacritty
```
#### 특정 디렉토리에서 실행:
```shell
alacritty --working-directory {{경로/디렉토리명}}
```
#### 새로운 Alacritty 창에서 명령어 실행:
```shell
alacritty -e {{명령어}}
```
#### 대체 구성파일 지정 (기본값 : `$XDG_CONFIG_HOME/alacritty/alacritty.yml`):
```shell
alacritty --config-file {{경로/config.yml}}
```
#### 재배치가 가능한 라이브 구성 설정으로 실행 (기본적으로 `alacritty.yml` 에서도 활성화 가능):
```shell
alacritty --live-config-reload --config-file {{경로/config.yml}}
```
{% endraw %}{% raw %}
<h2 id="alex">
  <a href="/ko/common/alex.html">alex</a> <a href="#alex"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 민감하지 않고, 사려깊지 않은 글을 잡는 도구.
> 이것은 당신이 선호 성별, 양극화, 인종 관련, 종교에 대한 고려가 불분명하거나 다른 문구가 아닌 문구를 찾는데 도움이 됩니다.
> 더 많은 정보: <https://github.com/get-alex/alex>.

#### stdin으로부터 텍스트 분석:
```shell
echo {{His network looks good}} | alex --stdin
```
#### 현재 디렉토리의 모든 파일 분석:
```shell
alex
```
#### 특정 파일 분석:
```shell
alex {{textfile.md}}
```
#### `example.md`를 제외한 모든 Markdown 파일 분석:
```shell
alex *.md !{{example.md}}
```
{% endraw %}{% raw %}
<h2 id="alias">
  <a href="/ko/common/alias.html">alias</a> <a href="#alias"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 명령 문자열로 대체되는 단어인 별칭 -- 작성.
> 별칭은 셀의 구성 파일에 정의되어 있지 않으면 현재 쉘 세션으로 만료됩니다, 예 : `~/.bashrc`.
> 더 많은 정보: <https://tldp.org/LDP/abs/html/aliases.html>.

#### 모든 별칭 리스트:
```shell
alias
```
#### 일반 별칭 생성:
```shell
alias {{단어}}="{{명령어}}"
```
#### 주어진 별칭에 연관된 명령어:
```shell
alias {{단어}}
```
#### 별칭 명령어 제거:
```shell
unalias {{단어}}
```
#### `rm` 을 대화형 명령어로 전환:
```shell
alias {{rm}}="{{rm -i}}"
```
#### `ls -a`의 지름길인 `la`생성:
```shell
alias {{la}}="{{ls -a}}"
```
{% endraw %}{% raw %}
<h2 id="ansible-galaxy">
  <a href="/ko/common/ansible-galaxy.html">ansible-galaxy</a> <a href="#ansible-galaxy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 수용 가능한 역할 생성 및 관리.
> 더 많은 정보: <https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html>.

#### 역할 설치:
```shell
ansible-galaxy install {{사용자이름.역할_}}
```
#### 역할 제거:
```shell
ansible-galaxy remove {{사용자이름.역할_이름}}
```
#### 설치된 역할 리스트:
```shell
ansible-galaxy list
```
#### 주어진 역할에 대해 검색:
```shell
ansible-galaxy search {{역할_이름}}
```
#### 새로운 역할 생성:
```shell
ansible-galaxy init {{역할_이름}}
```
{% endraw %}{% raw %}
<h2 id="ansible-playbook">
  <a href="/ko/common/ansible-playbook.html">ansible-playbook</a> <a href="#ansible-playbook"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> SSH를 통해 원격 머신에서 playbook에 정의된 작업 실행.
> 더 많은 정보: <https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html>.

#### playbook에서 작업 실행:
```shell
ansible-playbook {{playbook}}
```
#### 사용자 정의 호스트 인벤토리를 포함한 playbook에서 작업 실행:
```shell
ansible-playbook {{playbook}} -i {{인벤토리_파일}}
```
#### 명령어 라인을 통해 정의된 추가 변수를 사용하여 playbook에서 작업 실행:
```shell
ansible-playbook {{playbook}} -e "{{변수1}}={{값1}} {{변수2}}={{값2}}"
```
#### json 파일에 정의된 추가 변수를 사용하여 playbook에서 작업 실행:
```shell
ansible-playbook {{playbook}} -e "@{{변수.json}}"
```
{% endraw %}{% raw %}
<h2 id="ansible">
  <a href="/ko/common/ansible.html">ansible</a> <a href="#ansible"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> SSH를 통해 컴퓨터 그룹을 원격으로 관리.
> `/etc/ansible/hosts` 파일을 사용하여 새 그룹/호스트를 추가하십시오.
> 더 많은 정보: <https://www.ansible.com/>.

#### 그룹에 속한 호스트 목록:
```shell
ansible {{그룹명}} --list-hosts
```
#### 핑 모듈을 호출하여 호스트 그룹 핑:
```shell
ansible {{그룹명}} -m ping
```
#### 설정 모듈을 호출하여 호스트 그룹에 대한 사실 표시:
```shell
ansible {{그룹명}} -m setup
```
#### 명령 모듈을 인수로 호출하여 호스트 그룹에서 명령어 실행:
```shell
ansible {{그룹명}} -m command -a '{{나의_명령어}}'
```
#### 관리자 권한으로 명령어 실행:
```shell
ansible {{그룹명}} --become --ask-become-pass -m command -a '{{나의_명령어}}'
```
#### 사용자 정의 인벤토리 파일을 사용하여 명령어 실행:
```shell
ansible {{그룹}} -i {{인벤토리_파일}} -m command -a '{{나의_명령어}}'
```
{% endraw %}{% raw %}
<h2 id="ansiweather">
  <a href="/ko/common/ansiweather.html">ansiweather</a> <a href="#ansiweather"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 당신의 터미널에서 현재 날씨 상태를 표시하는 쉘 스크립트.
> 더 많은 정보: <https://github.com/fcambus/ansiweather>.

#### 폴란드 르제조에 대한 메트릭 단위를 사용하여 예측 표시:
```shell
ansiweather -u {{metric}} -f {{5}} -l {{Rzeszow,PL}}
```
#### 당신의 현재 위치에 대한 기호 및 일광 데이터를 표시하는 예측 표시:
```shell
ansiweather -s {{true}} -d {{true}}
```
#### 당신의 현재 위치의 바람과 습도 데이터를 보여주는 예측 표시:
```shell
ansiweather -w {{true}} -h {{true}}
```
{% endraw %}{% raw %}
<h2 id="apg">
  <a href="/ko/common/apg.html">apg</a> <a href="#apg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 임의로 복잡한 랜덤 암호를 만듭니다.
> 더 많은 정보: <https://manned.org/apg>.

#### 임의 비밀번호 생성 (기본 비밀번호 길이는 8):
```shell
apg
```
#### 1개 이상의 기호(S), 1개의 숫자(N), 1개의 대문자(C), 1개의 소문자(L) 로 비밀번호 생성:
```shell
apg -M SNCL
```
#### 16개 글자의 비밀번호 생성:
```shell
apg -m {{16}}
```
#### 최대 길이가 16인 비밀번호 생성:
```shell
apg -x {{16}}
```
#### 사전에 나타나지 않는 암호를 생성(사전 파일을 제공해야함):
```shell
apg -r {{디렉토리_파일}}
```
{% endraw %}{% raw %}
<h2 id="apm">
  <a href="/ko/common/apm.html">apm</a> <a href="#apm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 아톰 편집기 패키지 관리자.
> `atom`을 보시오.
> 더 많은 정보: <https://github.com/atom/apm>.

#### <http://atom.io/packages>으로부터 패키지 설치하고 <http://atom.io/themes>에서 테마 설치:
```shell
apm install {{패키지 이름}}
```
#### 패키지/테마 제거:
```shell
apm remove {{패키지 이름}}
```
#### 패키지/테마 업그레이드:
```shell
apm upgrade {{패키지 이름}}
```
{% endraw %}{% raw %}
<h2 id="apropos">
  <a href="/ko/common/apropos.html">apropos</a> <a href="#apropos"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 메뉴얼 페이지에서 검색, 예를 들어 새로운 명령어 검색.
> 더 많은 정보: <https://manned.org/apropos>.

#### 키워드 검색:
```shell
apropos {{정규 표현식}}
```
#### 출력을 터미널 너비에 제한을 두지 않고 검색:
```shell
apropos -l {{정규 표현식}}
```
#### 주어진 모든 표현식만 포함하는 페이지 검색(AND 검색):
```shell
apropos {{정규 표현식_1}} -a {{정규 표현식_2}} -a {{정규 표현식_3}}
```
{% endraw %}{% raw %}
<h2 id="ar">
  <a href="/ko/common/ar.html">ar</a> <a href="#ar"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 아카이브로부터 생성, 수정, 추출 (`.a`, `.so`, `.o`).
> 더 많은 정보: <https://manned.org/ar>.

#### 보관소로부터 모든 멤버를 추출하기:
```shell
ar -x {{libfoo.a}}
```
#### 보관소 멤버 리스트 보여주기:
```shell
ar -t {{libfoo.a}}
```
#### 보관소로 파일을 대체하거나 추가하기:
```shell
ar -r {{libfoo.a}} {{foo.o}} {{bar.o}} {{baz.o}}
```
#### object 파일 인덱스 삽입( `ranlib` 와 같은 기능입니다):
```shell
ar -s {{libfoo.a}}
```
#### 파일 및 첨부된 객체 파일 색인을 사용하여 보관소에 작성:
```shell
ar -rs {{libfoo.a}} {{foo.o}} {{bar.o}} {{baz.o}}
```
{% endraw %}{% raw %}
<h2 id="arc">
  <a href="/ko/common/arc.html">arc</a> <a href="#arc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Arcanist: A CLI for Phabricator.
> 더 많은 정보: <https://secure.phabricator.com/book/phabricator/article/arcanist/>.

#### 검토에 대한 차이점의 변경을 보냅니다:
```shell
arc diff
```
#### 보류중인 수정 정보 표시:
```shell
arc list
```
#### 검토 후 Git Commit 메시지 업데이트하기:
```shell
arc amend
```
#### Git에 Push 하기:
```shell
arc land
```
{% endraw %}{% raw %}
<h2 id="arch">
  <a href="/ko/common/arch.html">arch</a> <a href="#arch"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 시스템 구조의 이름을 보여줍니다.
> `uname` 도 같이 보세요.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/arch>.

#### 시스템 구조 보여주기:
```shell
arch
```
{% endraw %}{% raw %}
<h2 id="aria2">
  <a href="/ko/common/aria2.html">aria2</a> <a href="#aria2"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 경량 멀티 프로토콜 및 멀티 소스 명령줄 다운로드 유틸리티입니다.
> HTTP, HTTPS, FTP, SFTP, BitTorrent와 Metalink를 지원합니다.
> 더 많은 정보: <https://aria2.github.io/>.

#### 웹 리소스 다운로드:
```shell
aria2c {{http://example.org/myLinux.iso}}
```
#### 멀티 소스 리소스 다운로드:
```shell
aria2c {{http://mirror1.org/myLinux.iso}} {{http://mirror2.org/myLinux.iso}}
```
#### 호스트당 2개의 연결을 사용하여 다운로드 :
```shell
aria2c -x{{2}} {{http://example.org/myLinux.iso}}
```
#### Metalink URL로 다운로드:
```shell
aria2c {{http://example.org/myLinux.metalink}}
```
#### BitTorrent URI로 다운로드:
```shell
aria2c {{http://example.org/myLinux.torrent}}
```
#### BitTorrent Magnet URI로 다운로드:
```shell
aria2c {{'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C'}}
```
#### 파일로 URls 다운로드:
```shell
aria2c -i {{uris.txt}}
```
{% endraw %}{% raw %}
<h2 id="aria2c">
  <a href="/ko/common/aria2c.html">aria2c</a> <a href="#aria2c"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 빠른 다운로드 유틸리티.
> HTTP(S), FTP, SFTP, BitTorrent, and Metalink를 지원합니다.
> 더 많은 정보: <https://aria2.github.io>.

#### URl을 파일에 다운로드:
```shell
aria2c {{url}}
```
#### 다중 소스를 다운로드:
```shell
aria2c {{url_1}} {{url_2}}
```
#### 파일에 나열된 URI 다운로드 :
```shell
aria2c -i {{filename}}
```
#### 여러 연결로 다운로드 :
```shell
aria2c -s {{connections_num}} {{url}}
```
#### 사용자 이름과 암호가 있는 FTP 다운로드 :
```shell
aria2c --ftp-user={{username}} --ftp-passwd={{password}} {{url}}
```
#### 다운로드 속도를 바이트/s로 제한 :
```shell
aria2c --max-download-limit={{speed}} {{url}}
```
{% endraw %}{% raw %}
<h2 id="arp">
  <a href="/ko/common/arp.html">arp</a> <a href="#arp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 시스템의 ARP 캐시 표시 및 조작.
> 더 많은 정보: <https://manned.org/arp>.

#### 현재 arp 테이블을 보여줍니다:
```shell
arp -a
```
#### 전체 캐시 삭제:
```shell
sudo arp -a -d
```
#### 특정 엔트리 삭제:
```shell
arp -d {{address}}
```
#### 엔트리 생성:
```shell
arp -s {{address}} {{mac_address}}
```
{% endraw %}{% raw %}
<h2 id="arping">
  <a href="/ko/common/arping.html">arping</a> <a href="#arping"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ARP 프로토콜을 사용하여 네트워크에서 호스트를 발견하고 탐색합니다.
> MAC 주소 검색에 유용합니다.
> 더 많은 정보: <https://github.com/ThomasHabets/arping>.

#### ARP 요청 패킷으로 호스트 ping 하기:
```shell
arping {{host_ip}}
```
#### 특정 인터페이스의 호스트로 ping 하기:
```shell
arping -I {{interface}} {{host_ip}}
```
#### 첫 응답을 한 호스트로 ping 하기:
```shell
arping -f {{host_ip}}
```
#### 호스트에 특정 횟수 ping 하기:
```shell
arping -c {{count}} {{host_ip}}
```
#### 브로드캐스트 ARP 요청 패킷을 통해 이웃 ARP 캐시 업데이트 :
```shell
arping -U {{ip_to_broadcast}}
```
#### 3초의 시간 제한을 사용하여 ARP 요청을 전송하여 네트워크에서 중복된 IP 주소를 탐지합니다:
```shell
arping -D -w {{3}} {{ip_to_check}}
```
{% endraw %}{% raw %}
<h2 id="asar">
  <a href="/ko/common/asar.html">asar</a> <a href="#asar"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 전자 플랫폼을 위한 파일 저장소입니다.
> 더 많은 정보: <https://github.com/electron/asar>.

#### 파일 또는 디렉토리 보관:
```shell
asar pack {{path/to/file_or_directory}} {{archived.asar}}
```
#### 보관소 추출:
```shell
asar extract {{archived.asar}}
```
#### 보관소에서 특정 파일 추출:
```shell
asar extract-file {{archived.asar}} {{file}}
```
#### 보관소 파일의 내용을 나열 :
```shell
asar list {{archived.asar}}
```
{% endraw %}{% raw %}
<h2 id="asciinema">
  <a href="/ko/common/asciinema.html">asciinema</a> <a href="#asciinema"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 터미널 세션을 녹음하고 재생하며 선택적으로 asciinema.org에서 공유합니다.
> 더 많은 정보: <https://asciinema.org/>.

#### `asciinema` 로컬 설치와 with an asciinema.org 계정을 연결하기:
```shell
asciinema auth
```
#### 새로운 녹음을 작성 (한 번 완료되면 사용자는 업로드하거나 로컬로 저장하라는 메시지가 표시됩니다):
```shell
asciinema rec
```
#### 새 녹음을 만들고 로컬 파일에 저장:
```shell
asciinema rec {{경로/파일명}}.cast
```
#### 로컬 파일에서 녹음한 터미널을 재생:
```shell
asciinema play {{경로/파일명}}.cast
```
#### asciinema.org에서 호스트된 터미널 녹음을 재생:
```shell
asciinema play https://asciinema.org/a/{{cast_id}}
```
#### 새로운 녹음을 만들어 유휴 시간을 최대 2.5초로 제한:
```shell
asciinema rec -i {{2.5}}
```
#### 로컬 저장 기록의 전체 출력을 인쇄:
```shell
asciinema cat {{경로/파일명}}.cast
```
#### 로컬로 저장된 터미널 세션을 asciinema.org에 업로드하기:
```shell
asciinema upload {{경로/파일명}}.cast
```
{% endraw %}{% raw %}
<h2 id="asdf">
  <a href="/ko/common/asdf.html">asdf</a> <a href="#asdf"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 여러 패키지 버전을 관리하기 위한 CLI(Command-line Interface) 입니다.
> 더 많은 정보: <https://asdf-vm.com>.

#### 사용 가능한 모든 플러그인을 나열:
```shell
asdf plugin-list-all
```
#### 플러그인 설치:
```shell
asdf plugin-add {{이름}}
```
#### 모든 사용 가능한 패키지 버전 나열:
```shell
asdf list-all {{이름}}
```
#### 특정 패키지 버전 설치:
```shell
asdf install {{이름}} {{버전}}
```
#### 글로벌 버전 패키지 설치:
```shell
asdf global {{버전}} {{버전}}
```
#### 로컬 버전 패키지 설치:
```shell
asdf local {{이름}} {{버전}}
```
{% endraw %}{% raw %}
<h2 id="assimp">
  <a href="/ko/common/assimp.html">assimp</a> <a href="#assimp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Open Asset Import Library 위한 Command-line 클라이언트.
> 40 +3D 파일 형식을 지원하고 몇 개의 유명한 3D포맷으로 내보낼 수 있습니다.
> 더 많은 정보: <http://www.assimp.org/>.

#### 지원되는 모든 가져오기 형식을 나열:
```shell
assimp listext
```
#### 지원되는 모든 내보내기 형식 나열:
```shell
assimp listexport
```
#### 기본 매개 변수를 사용하여 파일을 지원되는 출력 형식 중 하나로 변환:
```shell
assimp export {{입력_파일명.stl}} {{출력_파일명.obj}}
```
#### 사용자 정의 매개 변수 (Assimp의 소스 코드 목록에서 dox_cmd.h 파일 사용 가능한 매개 변수)를 사용하여 파일을 변환:
```shell
assimp export {{입력_파일명.stl}} {{출력_파일명.obj}} {{매개변수}}
```
#### 3D 파일의 내용을 요약하여 표시:
```shell
assimp info {{경로/파일명}}
```
#### 지원되는 모든 하위 명령 ("Verb")을 나열:
```shell
assimp help
```
#### 특정 하위 명령에 대한 도움말 얻기 (예 : 특정 하위 명령에 특정 매개 변수) :
```shell
assimp {{하위명령어}} --help
```
{% endraw %}{% raw %}
<h2 id="astronomer">
  <a href="/ko/common/astronomer.html">astronomer</a> <a href="#astronomer"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> GitHub 프로젝트의 봇 계정에서 불법적인 star를 탐지하는 도구.
> 더 많은 정보: <https://github.com/Ullaakut/astronomer>.

#### 저장소 스캔:
```shell
astronomer {{tldr-pages/tldr-node-client}}
```
#### 레포지토리의 최대 star 스캔:
```shell
astronomer {{tldr-pages/tldr-node-client}} --stars {{50}}
```
#### 비교 보고서를 포함한 리포지토리 스캔:
```shell
astronomer {{tldr-pages/tldr-node-client}} --verbose
```
{% endraw %}{% raw %}
<h2 id="astyle">
  <a href="/ko/common/astyle.html">astyle</a> <a href="#astyle"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> C, C ++, C # 및 Java 프로그래밍 언어에 대한 소스 코드 인덴터, 포맷터 및 미화기.
> 실행 시 원본 파일의 사본은 원래 파일 이름에 ".orig"가 추가된 상태로 작성된다.
> 더 많은 정보: <http://astyle.sourceforge.net/>.

#### 들여쓰기 당 4개의 공백의 기본 스타일을 적용하고 형식 변경 없도록 적용:
```shell
astyle {{소스파일명}}
```
#### java 스타일 코드로 적용:
```shell
astyle --style=java {{경로/파일명}}
```
#### allman 스타일 코드로 적용:
```shell
astyle --style=allman {{경로/파일명}}
```
#### 공간을 사용하여 사용자 지정 들여쓰기를 적용합니다. 2에서 20개 사이의 공간을 선택합니다:
```shell
astyle --indent=spaces={{띄어쓸_수}} {{경로/파일명}}
```
#### 탭을 사용하여 사용자 지정 들여쓰기를 적용합니다. 2에서 20 탭 사이에서 선택합니다:
```shell
astyle --indent=tab={{탭_수}} {{경로/파일명}}
```
{% endraw %}{% raw %}
<h2 id="at">
  <a href="/ko/common/at.html">at</a> <a href="#at"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 명령 실행 후 한 번 실행합니다.
> 서비스 AD(또는 ATRUN)는 실제 실행을 위해 실행되어야 합니다.
> 더 많은 정보: <https://man.archlinux.org/man/at.1>.

#### 표준 입력에서 명령을 5분 내에 실행(작업이 끝나면 `Ctrl + D` 를 누르세요):
```shell
at now + 5 minutes
```
#### 오전 10시에 표준 입력에서 명령을 실행하십시오:
```shell
echo "{{./make_db_backup.sh}}" | at 1000
```
#### 다음 주 화요일에 주어진 파일에서 명령을 실행하십시오:
```shell
at -f {{경로/파일명}} 9:30 PM Tue
```
{% endraw %}{% raw %}
<h2 id="atom">
  <a href="/ko/common/atom.html">atom</a> <a href="#atom"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 플러그 기능이 있는 교차 플랫폼 텍스트 편집기.
> 플러그는 `apm`에 의해 관리됩니다.
> 더 많은 정보: <https://atom.io/>.

#### 파일이나 디렉토리 열기:
```shell
atom {{경로/파일명_또는_디렉토리명}}
```
#### 새로운 창에서 파일이나 디렉토리 열기:
```shell
atom -n {{경로/파일명_또는_디렉토리명}}
```
#### 현재 창에서 파일이나 디렉토리 열기:
```shell
atom --add {{경로/파일명_또는_디렉토리명}}
```
#### 안전모드에서 atom 열기Open atom in safe mode (추가 패키지를 로드하지 마시오):
```shell
atom --safe
```
#### 백그라운드에서 fork하지 않도록 막기, atom을 터미널에 부착합니다:
```shell
atom --foreground
```
{% endraw %}{% raw %}
<h2 id="atoum">
  <a href="/ko/common/atoum.html">atoum</a> <a href="#atoum"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> PHP를 위한 단순하고 현대적이며 직관적인 단위 테스트 프레임워크.
> 더 많은 정보: <http://atoum.org>.

#### 설정 파일 초기화:
```shell
atoum --init
```
#### 모든 테스트 실행:
```shell
atoum
```
#### 특정 설정 파일을 사용한 테스트 실행:
```shell
atoum -c {{경로/파일명}}
```
#### 특정 테스트파일 실행:
```shell
atoum -f {{경로/파일명}}
```
#### 특정 테스트 디렉토리 실행:
```shell
atoum -d {{경로/디렉토리명}}
```
#### 특정 namespace 아래 있는 모든 테스트 실행:
```shell
atoum -ns {{namespace}}
```
#### 특정 태그를 갖고 테스트 실행:
```shell
atoum -t {{태그}}
```
#### 테스트를 실행하기 전에 사용자 지정 부트스트랩 파일을 로드:
```shell
atoum --bootstrap-file {{경로/파일명}}
```
{% endraw %}{% raw %}
<h2 id="autossh">
  <a href="/ko/common/autossh.html">autossh</a> <a href="#autossh"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> SSH 연결을 실행, 모니터링 및 재시작. port 재전송 tunnel을 유지하기 위해 자동 재연결. 모든 ssh 플래그 허용.
> 더 많은 정보: <https://harding.motd.ca/autossh>.

#### SSH session을 열고, 모니터링 포트가 데이터를 리턴하지 못하면 다시 시작:
```shell
autossh -M {{monitor_port}} {{ssh_command}}
```
#### 로컬 포트를 원격 포트로 전달하는 SSH session을 열고 필요한 경우 다시 시작:
```shell
autossh -M {{monitor_port}} -L {{local_port}}:localhost:{{remote_port}} {{user}}@{{host}}
```
#### ssh(백그라운드에서 실행)를 실행하기 전에 포크하고 원격 쉘을 열지 않는다:
```shell
autossh -f -M {{monitor_port}} -N {{ssh_command}}
```
#### 모니터링 포트없이 백그라운드에서 autossh를 실행하는 대신 실패를 감지하기 위해 10초마다 SSH 연결 유지에 의존:
```shell
autossh -f -M 0 -N -o "ServerAliveInterval 10" -o "ServerAliveCountMax 3" {{ssh_command}}
```
#### 모니터링 포트, 원격 쉘 없이 백그라운드에서 autossh를 실행하고, 포트 전달에 실패하면 종료:
```shell
autossh -f -M 0 -N -o "ServerAliveInterval 10" -o "ServerAliveCountMax 3" -o ExitOnForwardFailure=yes -L {{local_port}}:localhost:{{remote_port}} {{user}}@{{host}}
```
#### 디버그 출력이 파일에 기록되고 ssh 상세 출력이 두번째 파일에 기록 된 상태에서 백그라운드에서 autossh를 실행:
```shell
AUTOSSH_DEBUG=1 AUTOSSH_LOGFILE={{log_file}} autossh -f -M {{monitor_port}} -v -E {{ssh_log_file}} {{ssh_command}}
```
{% endraw %}{% raw %}
<h2 id="avrdude">
  <a href="/ko/common/avrdude.html">avrdude</a> <a href="#avrdude"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Atmel AVR 마이크로 컨트롤러 프로그래밍을 위한 드라이버 프로그램.
> 더 많은 정보: <https://www.nongnu.org/avrdude/>.

#### AVR 마이크로 컨트롤러 읽기:
```shell
avrdude -p {{AVR_device}} -c {{programmer}} -U flash:r:{{file.hex}}:i
```
#### AVR 마이크로 컨트롤러 쓰기:
```shell
avrdude -p {{AVR_device}} -c {{programmer}} -U flash:w:{{file.hex}}
```
#### 사용 가능한 AVR 장치 목록:
```shell
avrdude -p \?
```
#### 사용 가능한 AVR 프로그래머 목록:
```shell
avrdude -c \?
```
{% endraw %}{% raw %}
<h2 id="awk">
  <a href="/ko/common/awk.html">awk</a> <a href="#awk"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 작업을 위한 다목적 프로그래밍 언어.
> 더 많은 정보: <https://github.com/onetrueawk/awk>.

#### 공백으로 구분 된 파일의 다섯 번째 열 (일명 필드)를 출력하기:
```shell
awk '{print $5}' {{filename}}
```
#### 공백으로 구분 된 파일에서 `foo`을 포함한 두 번째 열 출력하기:
```shell
awk '/{{foo}}/ {print $2}' {{filename}}
```
#### 공백이 아닌 쉼표를 필드 구분 기호로 사용한 파일에서 각 줄의 마지막 열을 출력하기:
```shell
awk -F ',' '{print $NF}' {{filename}}
```
#### 파일의 첫 번째 열에 있는 값을 더하고 합계를 출력:
```shell
awk '{s+=$1} END {print s}' {{filename}}
```
#### 첫 번째 열에 있는 값을 더하고 값들을 출력하고 합계를 출력:
```shell
awk '{s+=$1; print $1} END {print "--------"; print s}' {{filename}}
```
#### 첫 번째 줄부터 시작하여 세 번째 줄까지 모두 출력:
```shell
awk 'NR%3==1' {{filename}}
```
#### 세 번째 열부터 시작하여 모든 값을 출력:
```shell
awk '{ s = ""; for (i=3; i <= NF; i++) s = s $i " "; print s }'
```
#### 조건에 따라 다른 값을 출력:
```shell
awk '{if ($1 == "foo") print "Exact match foo"; else if ($1 ~ "bar") print "Partial match bar"; else print "Baz"}'
```
{% endraw %}{% raw %}
<h2 id="aws-google-auth">
  <a href="/ko/common/aws-google-auth.html">aws-google-auth</a> <a href="#aws-google-auth"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Google Apps를 페더레이션(Single Sign-On)공급자로 사용하여 AWS 임시(STS) 자격 증명을 획득하는 명령 줄 도구입니다.
> 더 많은 정보: <https://github.com/cevoaustralia/aws-google-auth>.

#### IDP및 식별자를 사용하여 Google SSO에 로그인하고 자격 증명 기간을 1시간으로 설정:
```shell
aws-google-auth -u {{example@example.com}} -I {{$GOOGLE_IDP_ID}} -S {{$GOOGLE_SP_ID}} -d {{3600}}
```
#### 사용자 역할을 묻는 로그인(여러 개으 사용 가능한 SAML 역할의 경우):
```shell
aws-google-auth -u {{example@example.com}} -I {{$GOOGLE_IDP_ID}} -S {{$GOOGLE_SP_ID}} -d {{3600}} -a
```
#### AWS 계정의 별칭 확인:
```shell
aws-google-auth -u {{example@example.com}} -I {{$GOOGLE_IDP_ID}} -S {{$GOOGLE_SP_ID}} -d {{3600}} -a --resolve-aliases
```
#### 도움말 정보 보기:
```shell
aws-google-auth -h
```
{% endraw %}{% raw %}
<h2 id="aws-s3">
  <a href="/ko/common/aws-s3.html">aws s3</a> <a href="#aws-s3"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> AWS S3용 CLI - 웹 서비스 인터페이스를 통해 스토리지를 제공합니다.
> 더 많은 정보: <https://aws.amazon.com/cli>.

#### 버킷 안의 파일 보기:
```shell
aws s3 ls {{bucket_name}}
```
#### 로컬에서 버킷으로 파일 및 디렉토리 동기화:
```shell
aws s3 sync {{path/to/files}} s3://{{bucket_name}}
```
#### 버킷에서 로컬로 파일 및 디렉토리 동기화:
```shell
aws s3 sync s3://{{bucket_name}} {{path/to/target}}
```
#### 제외 된 파일 및 디렉토리 동기화:
```shell
aws s3 sync {{path/to/files}} s3://{{bucket_name}} --exclude {{path/to/file}} --exclude {{path/to/directory}}/*
```
#### 버킷에서 파일 제거:
```shell
aws s3 rm s3://{{bucket}}/{{path/to/file}}
```
#### 변경 사항만 미리보기:
```shell
aws s3 {{any_command}} --dryrun
```
{% endraw %}{% raw %}
<h2 id="aws">
  <a href="/ko/common/aws.html">aws</a> <a href="#aws"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Amazon Web Services의 공식 CLI tool입니다.
> 더 많은 정보: <https://aws.amazon.com/cli>.

#### 모든 IAM 사용자 목록:
```shell
aws iam list-users
```
#### 특정 지역의 모든 ec2 인스턴스 나열:
```shell
aws ec2 describe-instances --region {{us-east-1}}
```
#### 특정 SQS 대기열에서 메시지 수신:
```shell
aws sqs receive-message --queue-url {{https://queue.amazonaws.com/546123/Test}}
```
#### 특정 SNS 주제에 메시지 게시:
```shell
aws sns publish --topic-arn {{arn:aws:sns:us-east-1:54633:testTopic}} --message "Message"
```
#### AWS 명령어에 대한 도움말을 보려면:
```shell
aws {{command}} help
```
{% endraw %}{% raw %}
<h2 id="axel">
  <a href="/ko/common/axel.html">axel</a> <a href="#axel"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 가속기를 다운로드 하십시오. HTTP, HTTPS, FTP를 지원합니다.
> 더 많은 정보: <https://github.com/axel-download-accelerator/axel>.

#### 파일로 URL 다운로드:
```shell
axel {{url}}
```
#### 다운로드 및 파일 이름 지정:
```shell
axel {{url}} -o {{filename}}
```
#### 여러 연결로 다운로드:
```shell
axel -n {{connections_num}} {{url}}
```
#### mirrors 검색:
```shell
axel -S {{mirrors_num}} {{url}}
```
#### 다운로드 속도 제한 (초당 바이트):
```shell
axel -s {{speed}} {{url}}
```
{% endraw %}{% raw %}
<h2 id="az">
  <a href="/ko/common/az.html">az</a> <a href="#az"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Microsoft Azure의 공식 CLI tool입니다.
> 더 많은 정보: <https://docs.microsoft.com/cli/azure>.

#### Azure에 로그인:
```shell
az login
```
#### Azure 구독 정보 관리:
```shell
az account
```
#### 모든 Azure 관리 디스크 나열:
```shell
az disk list
```
#### 모든 Azure 가상머신 나열:
```shell
az vm list
```
#### Azure Kubernetes Services 관리:
```shell
az aks
```
#### Azure 네트워크 리소스 관리:
```shell
az network
```
{% endraw %}{% raw %}
<h2 id="b2sum">
  <a href="/ko/common/b2sum.html">b2sum</a> <a href="#b2sum"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> BLACK2 암호화 체크섬을 계산하십시오.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/b2sum>.

#### 파일의 BLACKE2 체크섬 계산:
```shell
b2sum {{filename1}}
```
#### 여러 파일의 BLACKE2 체크섬 계산:
```shell
b2sum {{filename1}} {{filename2}}
```
#### BLAKE2 합계 파일 및 파일 이름을 읽고 모든 파일에 일치하는 체크섬이 있는지 확인:
```shell
b2sum -c {{filename.b2}}
```
#### stdin에서 BLACK2 체크섬 계산:
```shell
{{somecommand}} | b2sum
```
{% endraw %}{% raw %}
<h2 id="babel">
  <a href="/ko/common/babel.html">babel</a> <a href="#babel"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 코드를 JavaScript ES6/ES7문법에서 ES5문법으로 변환하는 변환기입니다.
> 더 많은 정보: <https://babeljs.io/>.

#### 지정된 입력 파일을 변환하고 `stdout'으로 출력:
```shell
babel {{path/to/file}}
```
#### 지정된 입력 파일을 변환하고 특정 파일로 출력:
```shell
babel {{path/to/input_file}} --out-file {{path/to/output_file}}
```
#### 입력 파일이 변경 될 때마다 변환:
```shell
babel {{path/to/input_file}} --watch
```
#### 파일의 전체 디렉토리를 변환:
```shell
babel {{path/to/input_directory}}
```
#### 디렉토리에서 지정된 쉼표로 구분 된 파일 무시:
```shell
babel {{path/to/input_directory}} --ignore {{ignored_files}}
```
#### 축소 된 JavaScript로 변환 및 출력:
```shell
babel {{path/to/input_file}} --minified
```
#### 출력 형식에 대한 사전 설정 세트를 선택:
```shell
babel {{path/to/input_file}} --presets {{presets}}
```
#### 사용 가능한 모든 옵션 출력:
```shell
babel --help
```
{% endraw %}{% raw %}
<h2 id="badblocks">
  <a href="/ko/common/badblocks.html">badblocks</a> <a href="#badblocks"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 불량 블록이 있는지 장치를 검사하십시오.
> 불량 블록을 사용하면 파티션 테이블을 포함하여 디스크의 모든 데이터를 지우는 등의 파괴적인 작업이 발생할 수 있습니다.
> 더 많은 정보: <https://manned.org/badblocks>.

#### 비파괴 읽기 전용 테스트를 사용하여 디스크에서 불량 블록을 검사:
```shell
sudo badblocks {{/dev/sda}}
```
#### 비파괴 읽기-쓰기 테스트로 마운트되지 않은 디스크에서 불량 블록이 있는지 검사:
```shell
sudo badblocks -n {{/dev/sda}}
```
#### 파괴 쓰기 테스트로 마운드되지 않은 디스크에서 불량 블록이 있는지 검사:
```shell
sudo badblocks -w {{/dev/sda}}
```
{% endraw %}{% raw %}
<h2 id="balena">
  <a href="/ko/common/balena.html">balena</a> <a href="#balena"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 명령 줄에서 balenaCloud, openBalena 및 balena API와 상호 작용하십시오.
> 더 많은 정보: <https://www.balena.io/docs/reference/cli/>.

#### balenaCloud 계정에 로그인:
```shell
balena login
```
#### BalencaCloud 또는 OpenBalena 애플리케이션 생성:
```shell
balena app create {{app_name}}
```
#### 계정 내 모든 balenaCloud 또는 openBalena 애플리케이션 나열:
```shell
balena apps
```
#### balenaCloud 또는 openBalena 계정과 관련된 모든 장치 나열:
```shell
balena devices
```
#### BalenaOS 이미지를 로컬 드라이브에 플래시:
```shell
balena local flash {{path/to/balenaos.img}} --drive {{drive_location}}
```
{% endraw %}{% raw %}
<h2 id="banner">
  <a href="/ko/common/banner.html">banner</a> <a href="#banner"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 주어진 인자를 큰 ASCII art로 출력.
> 더 많은 정보: <https://man.archlinux.org/man/banner.1>.

#### 텍스트 메시지를 큰 배너로 출력(따옴표는 선택 사항):
```shell
banner "{{Hello World}}"
```
#### 텍스트 메시지를 너비가 50자인 배너로 출력:
```shell
banner -w {{50}} "{{Hello World}}"
```
#### stdin에서 텍스트 읽기:
```shell
banner
```
{% endraw %}{% raw %}
<h2 id="base32">
  <a href="/ko/common/base32.html">base32</a> <a href="#base32"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 또는 표준 입력을 Base32와 표준 출력으로 인코딩하거나 디코딩함.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/base32>.

#### 파일 인코딩:
```shell
base32 {{filename}}
```
#### 파일 디코딩:
```shell
base32 --decode {{filename}}
```
#### stdin에서 인코딩:
```shell
{{somecommand}} | base32
```
#### stdin에서 디코딩:
```shell
{{somecommand}} | base32 --decode
```
{% endraw %}{% raw %}
<h2 id="base64">
  <a href="/ko/common/base64.html">base64</a> <a href="#base64"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 또는 표준 입력을 Base64와 표준 출력으로 인코딩하거나 디코딩함.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/base64>.

#### 파일 인코딩:
```shell
base64 {{filename}}
```
#### 파일 디코딩:
```shell
base64 --decode {{filename}}
```
#### stdin에서 인코딩:
```shell
{{somecommand}} | base64
```
#### stdin에서 디코딩:
```shell
{{somecommand}} | base64 --decode
```
{% endraw %}{% raw %}
<h2 id="basename">
  <a href="/ko/common/basename.html">basename</a> <a href="#basename"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 경로명의 디렉토리가 아닌 부분을 반환.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/basename>.

#### 경로에서 파일 이름만 표시:
```shell
basename {{path/to/file}}
```
#### 경로에서 접미사가 제거된 파일 이름만 표시:
```shell
basename {{path/to/file}} {{suffix}}
```
{% endraw %}{% raw %}
<h2 id="bash">
  <a href="/ko/common/bash.html">bash</a> <a href="#bash"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Bourne-Again SHell. `sh`-호환 명령 행 인터프리터.
> 더 많은 정보: <https://gnu.org/software/bash>.

#### 대화식 쉘 시작:
```shell
bash
```
#### 명령 실행:
```shell
bash -c "{{command}}"
```
#### 파일에서 명령 실행:
```shell
bash {{file.sh}}
```
#### 파일에서 명령 실행하고, 터미널에서 실행 된 모든 명령 기록:
```shell
bash -x {{file.sh}}
```
#### 파일에서 명령 실행하고, 첫 번째 에러에서 중지:
```shell
bash -e {{file.sh}}
```
#### stdin에서 명령 실행:
```shell
bash -s
```
#### bash의 버전 정보 출력 (`echo $BASH_VERSION`을 사용하여 버전 문자열만 표시):
```shell
bash --version
```
{% endraw %}{% raw %}
<h2 id="bashmarks">
  <a href="/ko/common/bashmarks.html">bashmarks</a> <a href="#bashmarks"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 하나의 문자 명령을 사용하여 일반적으로 사용되는 디렉토리를 저장하고 점프하십시오.
> 더 많은 정보: <https://github.com/huyng/bashmarks>.

#### 사용 가능한 북마크 나열:
```shell
l
```
#### 현재 디렉토리를 "bookmark_name"으로 저장:
```shell
s {{bookmark_name}}
```
#### 북마크된 디렉토리로 이동:
```shell
g {{bookmark_name}}
```
#### 북마크 된 디렉토리 내용 출력:
```shell
p {{bookmark_name}}
```
#### 북마크 삭제:
```shell
d {{bookmark_name}}
```
{% endraw %}{% raw %}
<h2 id="bat">
  <a href="/ko/common/bat.html">bat</a> <a href="#bat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일들을 출력하고 연결. 구문 강조와 Git 통합을 가진`cat`클론.

#### 파일 내용을 표준 출력으로 출력:
```shell
bat {{file}}
```
#### 여러 파일을 대상 파일에 연결:
```shell
bat {{file1}} {{file2}} > {{target_file}}
```
#### 대상 파일에 여러 파일을 추가:
```shell
bat {{file1}} {{file2}} >> {{target_file}}
```
#### 모든 출력 라인 번호 매기기:
```shell
bat -n {{file}}
```
#### json파일 구문 강조:
```shell
bat --language json {{file.json}}
```
#### 지원되는 모든 언어 표시:
```shell
bat --list-languages
```
{% endraw %}{% raw %}
<h2 id="batch">
  <a href="/ko/common/batch.html">batch</a> <a href="#batch"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 시스템 로드 레벨이 허가된 후, 명령을 실행하십시오. 실제로 실행하기 위해서는 atd (혹은 atrun) 를 실행해야합니다.
> 더 많은 정보: <https://man.archlinux.org/man/at.1>.

#### 표준 입력에서 명령 실행하기 (완료 시 `Ctrl + D` 를 누릅니다):
```shell
batch
```
#### 표준 입력에서의 명령 실행하기:
```shell
echo "{{./make_db_backup.sh}}" | batch
```
#### 특정 파일에서 명령 실행하기:
```shell
batch -f {{path/to/file}}
```
{% endraw %}{% raw %}
<h2 id="bc">
  <a href="/ko/common/bc.html">bc</a> <a href="#bc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 계산기의 기능을 수행합니다.
> 더 많은 정보: <https://manned.org/bc>.

#### 표준 Math 라이브러리를 사용한 대화형 모드에서 계산기 실행하기:
```shell
bc -l
```
#### 계산 결과 표현법:
```shell
bc <<< "(1 + 2) * 2 ^ 2"
```
#### 계산 및 표현되는 소수 자릿수를 10으로 지정하기:
```shell
bc <<< "scale=10; 5 / 3"
```
#### mathlib를 사용하여 sin 및 cosine의 계산식 표현하기:
```shell
bc -l <<< "s(1) + c(1)"
```
{% endraw %}{% raw %}
<h2 id="beanstalkd">
  <a href="/ko/common/beanstalkd.html">beanstalkd</a> <a href="#beanstalkd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 단순하고 일반적인 work-queue 서버.
> 더 많은 정보:<https://beanstalkd.github.io/>.

#### beanstalkd를 시작하고, 11300 포트로 듣기:
```shell
beanstalkd
```
#### 사용자가 지정한 포트 및 주소에서 beanstalkd 듣기 시작:
```shell
beanstalkd -l {{ip_address}} -p {{port_number}}
```
#### work queue를 디스크에 저장하고 유지:
```shell
beanstalkd -b {{path/to/persistence_directory}}
```
#### 500밀리초마다 지속성있는 디렉토리에 동기화:
```shell
beanstalkd -b {{path/to/persistence_directory}} -f {{500}}
```
{% endraw %}{% raw %}
<h2 id="bedtools">
  <a href="/ko/common/bedtools.html">bedtools</a> <a href="#bedtools"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 유전자 분석 작업을 위한 도구의 swiss-army knife. BAM, BED, GFF/GTF, VCF 형식으로 데이터를 교차, 그룹화, 변환 및 카운트하는 데 사용.
> 더 많은 정보: <https://bedtools.readthedocs.io/en/latest/>.

#### sequence의 strand를 기준으로 두개의 파일을 교차하고 결과를 `path/to/output_file`의 경로에 저장:
```shell
bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -s > {{path/to/output_file}}
```
#### 외부 조인이 왼쪽인 두개의 파일을 교차, 예시. `file_1`에서 각 기능을 보고하고 `file_2`와 겹치지 않으면 NULL:
```shell
bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -lof > {{path/to/output_file}}
```
#### 더 효율적인 알고리즘을 사용하여 두개의 사전 정렬된 파일을 교차:
```shell
bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -sorted > {{path/to/output_file}}
```
#### 첫 3열과 5열을 기준으로 `path/to/file`을 그룹화하여 6열을 요약:
```shell
bedtools groupby -i {{path/to/file}} -c 1-3,5 -g 6 -o sum
```
#### bam-formated 파일을 bed-formated 파일로 변환:
```shell
bedtools bamtobed -i {{path/to/file}}.bam > {{path/to/file}}.bed
```
#### `file_2.bed`와 가장 가까운 `file_1.bed`에서의 모든 기능을 찾고,그들의 거리와 추가 열을 기록 (입력 파일 정렬 필요):
```shell
bedtools closest -a {{path/to/file_1}}.bed -b {{path/to/file_2}}.bed -d
```
{% endraw %}{% raw %}
<h2 id="behat">
  <a href="/ko/common/behat.html">behat</a> <a href="#behat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Behaviour-Driven 개발을 위한 PHP 프레임워크.
> 더 많은 정보: <https://behat.org/>.

#### 새로운 Behat 프로젝트 초기화:
```shell
behat --init
```
#### 모든 테스트 실행:
```shell
behat
```
#### 지정된 suite에서 모든 테스트 실행:
```shell
behat --suite={{suite_명}}
```
#### 특정 출력 formatter로 테스트 실행:
```shell
behat --format {{좋은|진행}}
```
#### 테스트 실행 및 파일로 결과 출력:
```shell
behat --out {{파일/의/경로}}
```
#### 테스트 suite에 정의 목록 표시:
```shell
behat --definitions
```
{% endraw %}{% raw %}
<h2 id="berks">
  <a href="/ko/common/berks.html">berks</a> <a href="#berks"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Chef 자세한 설명서 의존 관리자.
> 더 많은 정보: <https://docs.chef.io/berkshelf.html>.

#### 로컬 저장소에 자세한 설명서 종속성 설치:
```shell
berks install
```
#### 특정 자세한 설명서와 그 종속성을 업데이트:
```shell
berks update {{자세한 설명서}}
```
#### 자세한 설명서를 Chef server에 업로드:
```shell
berks upload {{자세한 설명서}}
```
#### 자세한 설명서의 종속성 확인:
```shell
berks contingent {{자세한 설명서}}
```
{% endraw %}{% raw %}
<h2 id="bg">
  <a href="/ko/common/bg.html">bg</a> <a href="#bg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 일시 중단된 작업을 다시 시작하고 (예. `Ctrl + Z`), 그 작업이 background에서 동작하게 유지.
> 더 많은 정보: <https://manned.org/bg>.

#### 가장 최근에 일시 중단된 작업을 재개하고 background에서 실행:
```shell
bg
```
#### 특정 작업을 재개하고(`jobs -l` 를 사용하여 ID 가져오기) background에서 실행:
```shell
bg %{{job_id}}
```
{% endraw %}{% raw %}
<h2 id="bitcoin-cli">
  <a href="/ko/common/bitcoin-cli.html">bitcoin-cli</a> <a href="#bitcoin-cli"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> RPC 호출을 통해 비트코인 데몬과 상호 작용하는 커맨드라인 클라이언트.`bitcoin.conf`에 정의된 구성 사용.
> 더 많은 정보:<https://en.bitcoin.it/wiki/Running_Bitcoin#Command-line_arguments>.

#### 지정된 주소로 트랜잭션 전송:
```shell
bitcoin-cli sendtoaddress "{{주소}}" {{양}}
```
#### 하나 이상의 블록 생성:
```shell
bitcoin-cli generate {{블록_갯수}}
```
#### wallet에 대한 고급 정보 출력:
```shell
bitcoin-cli getwalletinfo
```
#### 보내지지 않은 모든 트랜잭션의 출력 나열:
```shell
bitcoin-cli listunspent
```
#### wallet 정보를 텍스트 파일로 출력:
```shell
bitcoin-cli dumpwallet "{{파일/의/경로}}"
```
{% endraw %}{% raw %}
<h2 id="black">
  <a href="/ko/common/black.html">black</a> <a href="#black"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Python 자동 코드 formatter.
> 더 많은 정보: <https://github.com/psf/black>.

#### 파일 또는 전체 디렉토리의 자동 포맷:
```shell
black {{파일_또는_디렉토리/의/경로}}
```
#### 전달된 코드를 문자열로 포맷:
```shell
black -c {{파일_또는_디렉토리/의/경로}}
```
#### 표준 출력시 각 파일에 대해 diff 출력:
```shell
black --diff {{파일_또는_디렉토리/의/경로}}
```
#### 파일을 다시 쓰지 않고 상태 반환:
```shell
black --check {{파일_또는_디렉토리/의/경로}}
```
#### 파일 또는 디렉토리가 stderr에 배타적 오류 메시지를 발생시키는 자동 포맷:
```shell
black --quiet {{파일_또는_디렉토리/의/경로}}
```
{% endraw %}{% raw %}
<h2 id="blackfire">
  <a href="/ko/common/blackfire.html">blackfire</a> <a href="#blackfire"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> PHP용 커맨드라인 프로파일링 도구.
> 더 많은 정보: <https://blackfire.io/>.

#### Blackfire 클라이언트 초기화 및 구성:
```shell
blackfire config
```
#### Blackfire agent 시작:
```shell
blackfire agent
```
#### 특정 소켓에서 Blackfire agent 시작:
```shell
blackfire agent --socket="{{tcp://127.0.0.1:8307}}"
```
#### 특정 프로그램에서 프로파일러 실행:
```shell
blackfire run {{파일.php/의/php 경로}}
```
#### 프로파일러 실행 및 샘플 10개 수집:
```shell
blackfire --samples={{10}} run {{파일.php/의/php 경로}}
```
#### 프로파일러 및 출력 결과를 JSON으로 실행:
```shell
blackfire --json run {{파일.php/의/php 경로}}
```
#### 프로파일러 파일을 Blackfire 웹 서비스에 업로드:
```shell
blackfire upload {{파일/의/경로}}
```
#### Blackfire 웹 서비스에서 프로필 상태 확인:
```shell
blackfire status
```
{% endraw %}{% raw %}
<h2 id="blender">
  <a href="/ko/common/blender.html">blender</a> <a href="#blender"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Blender 3D 컴퓨터 그래픽스 어플리케이션의 커맨드라인 인터페이스. 인자는 주어진 순서대로 실행.
> 더 많은 정보: <https://docs.blender.org/manual/en/latest/render/workflows/command_line.html>.

#### UI를 로드하지 않고 background에서 애니메이션의 모든 프레임을 렌더링.(출력은 `/tmp`에 저장):
```shell
blender -b {{파일명}}.blend -a
```
#### .blend 파일에 대한 경로 (`//`)에서 특정 이미지 명명 패턴을 사용하여 애니메이션 렌더링:
```shell
blender -b {{파일명}}.blend -o //{{render/frame_###.png}} -a
```
#### 기존 디렉토리에 저장된 단일 이미지로 애니메이션의 10번째 프레임 렌더링(절대 경로):
```shell
blender -b {{파일명}}.blend -o {{/출력_디렉토리/의/경로}} -f {{10}}
```
#### 기존 디렉토리에 저장된 JPEG 이미지로 애니메이션의 두번째 마지막 프레임 렌더링(상대 경로):
```shell
blender -b {{파일명}}.blend -o //{{출력_디렉토리}} -F {{JPEG}} -f {{-2}}
```
#### 프레임 10에서 시작하여 프레임 500에서 끝나는 특정 장면의 애니메이션 렌더링:
```shell
blender -b {{파일명}}.blend -S {{씬_이름}} -s {{10}} -e {{500}} -a
```
#### Python 표현식을 전달하여 특정 해상도로 애니메이션 렌더링:
```shell
blender -b {{파일명}}.blend --python-expr '{{import bpy; bpy.data.scenes[0].render.resolution_percentage = 25}}' -a
```
#### Python 콘솔을 사용하여 터미널에서 대화형 Blender 세션 시작(시작 후`import bpy` 수행):
```shell
blender -b --python-console
```
{% endraw %}{% raw %}
<h2 id="bmaptool">
  <a href="/ko/common/bmaptool.html">bmaptool</a> <a href="#bmaptool"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 블록 맵을 지능적으로 생성 및 복사( `cp` 혹은 `dd`보다 빠른 속도).
> 더 많은 정보: <https://source.tizen.org/documentation/reference/bmaptool>.

#### 이미지 파일에서 블록 맵 생성:
```shell
bmaptool create -o {{블록맵.bmap}} {{이미지 파일}}
```
#### 이미지 파일을 sdb로 복사:
```shell
bmaptool copy --bmap {{블록맵.bmap}} {{이미지 파일}} {{/dev/sdb}}
```
#### 압축된 이미지 파일을 sdb로 복사:
```shell
bmaptool copy --bmap {{블록맵.bmap}} {{압축된 이미지 파일}} {{/dev/sdb}}
```
#### 블록맵을 사용하지 않고 이미지 파일을 sdb로 복사:
```shell
bmaptool copy --nobmap {{이미지 파일}} {{/dev/sdb}}
```
{% endraw %}{% raw %}
<h2 id="boot">
  <a href="/ko/common/boot.html">boot</a> <a href="#boot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Clojure 프로그래밍 언어를 위한 빌드.
> 더 많은 정보: <https://github.com/boot-clj/boot>.

#### 프로젝트 혹은 독립으로 REPL 세션 시작:
```shell
boot repl
```
#### 단일 "uberjar" 구축:
```shell
boot jar
```
#### 명령어 안내:
```shell
boot cljs --help
```
#### 템플릿을 기반으로 새로운 프로젝트에 대한 기반 생성:
```shell
boot --dependencies boot/new new --template {{템플릿명}} --name {{프로젝트명}}
```
#### 개발용 빌드 (부트/새 템플릿을 사용하는 경우):
```shell
boot dev
```
#### 생산용 빌드 (부트/새 템플릿을 사용하는 경우):
```shell
boot prod
```
{% endraw %}{% raw %}
<h2 id="borg">
  <a href="/ko/common/borg.html">borg</a> <a href="#borg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 중복제거 백업 도구. 파일시스템으로 마운트할 수 있는 로컬 또는 원격 저장소를 제작.
> 더 많은 정보: <https://borgbackup.readthedocs.io/en/stable/usage/general.html>.

#### (로컬) 저장소 초기화:
```shell
borg init {{/저장소_디렉토리/의/경로}}
```
#### 디렉토리를 저장소에 백업하여, "Monday"라는 아카이브 생성:
```shell
borg create --progress {{/저장소_디렉토리/의/경로}}::{{Monday}} {{/소스_디렉토리/의/경로}}
```
#### 저장소의 모든 아카이브 나열:
```shell
borg list {{/저장소_디렉토리/의/경로}}
```
#### *.ext 파일을 제외하고 원격 저장소의 "Monday" 아카이브에서 특정 디렉토리 추출:
```shell
borg extract {{user}}@{{host}}:{{/저장소_디렉토리/의/경로}}::{{Monday}} {{/타겟_디렉토리/의/경로}} --exclude '{{*.ext}}'
```
#### 7일이 지난 아카이브를 모두 삭제하고, 변경 사항을 나열하여 저장소 정리:
```shell
borg prune --keep-within {{7d}} --list {{/저장소_디렉토리/의/경로}}
```
#### 저장소를 FUSE 파일 시스템으로 마운트:
```shell
borg mount {{/저장소_디렉토리/의/경로}}::{{Monday}} {{/마운트포인트/의/경로}}
```
#### 아카이브 작성에 대한 도움말 표시:
```shell
borg create --help
```
{% endraw %}{% raw %}
<h2 id="bosh">
  <a href="/ko/common/bosh.html">bosh</a> <a href="#bosh"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> bosh 디렉터를 배치 및 관리하기 위한 커맨드라인 도구.
> 더 많은 정보: <https://bosh.io/docs/cli-v2/>.

#### 디렉터의 로컬 별칭 생성:
```shell
bosh alias-env {{환경명}} -e {{ip_주소|url}} --ca-cert {{ca_증명서}}
```
#### 환경 나열:
```shell
bosh environments
```
#### 디렉터에 로그인:
```shell
bosh login -e {{환경}}
```
#### 배포 목록 나열:
```shell
bosh -e {{환경}} deployments
```
#### 가상 머신 환경 나열:
```shell
bosh -e {{환경}} vms -d {{전개}}
```
#### 가상 머신의 ssh:
```shell
bosh -e {{환경}} ssh {{가상머신}} -d {{전개}}
```
#### stemcell 업로드:
```shell
bosh -e {{환경}} upload-stemcell {{stemcell_파일|url}}
```
#### 현재 클라우드 구성 표시:
```shell
bosh -e {{환경}} cloud-config
```
{% endraw %}{% raw %}
<h2 id="bower">
  <a href="/ko/common/bower.html">bower</a> <a href="#bower"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> front-end 웹 개발에 최적화된 패키지 관리자. 패키지는 GitHub 사용자/reop 요약, Git의 엔드포인트, URL 혹은 등록된 패키지일 수 있습니다.
> 더 많은 정보: <https://bower.io/>.

#### bower.json에 나열된 프로젝트의 종속성 설치:
```shell
bower install
```
#### bower_components 디렉토리에 하나 이상의 패키지 설치:
```shell
bower install {{패키지}} {{패키지}}
```
#### bower_components 디렉토리에서 로컬로 패키지 제거:
```shell
bower uninstall {{패키지}} {{패키지}}
```
#### 로컬 패키지 및 가능한 업데이트 나열:
```shell
bower list
```
#### bower 명령에 대한 도움말 표시:
```shell
bower help {{명령}}
```
#### 패키지에 대한 bower.json 파일 생성 :
```shell
bower init
```
#### 특정 종속 버전을 설치하고, bower.json에 추가:
```shell
bower install {{로컬명}}={{패키지}}#{{버젼}} --save
```
{% endraw %}{% raw %}
<h2 id="box">
  <a href="/ko/common/box.html">box</a> <a href="#box"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Phar의 빌드 및 관리를 위한 PHP 어플리케이션.
> 더 많은 정보: <https://box-project.github.io/box2>.

#### 새 Phar 파일 작성:
```shell
box build
```
#### 특정 구성 파일을 사용하여 새 Phar 파일 작성:
```shell
box build -c {{config/의/경로}}
```
#### PHAR PHP 확장에 대한 정보 표시:
```shell
box info
```
#### 특정 Phar 파일에 대한 정보 표시:
```shell
box info {{phar_파일/의/경로}}
```
#### 현재 작업 디렉토리에서 처음으로 발견된 구성 파일 확인:
```shell
box validate
```
#### 특정 Phar 파일의 서명 확인:
```shell
box verify {{phar_파일/의/경로}}
```
#### 사용 가능한 모든 명령 및 옵션 표시:
```shell
box help
```
{% endraw %}{% raw %}
<h2 id="browser-sync">
  <a href="/ko/common/browser-sync.html">browser-sync</a> <a href="#browser-sync"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 변경에 따라 브라우저를 업데이트 하는 로컬 웹 서버 시작.
> 더 많은 정보: <https://browsersync.io/docs/command-line>.

#### 특정 디렉토리로부터 서버 시작:
```shell
browser-sync start --server {{디렉토리/의/경로}} --files {{디렉토리/의/경로}}
```
#### 로컬 디렉토리에서 서버 시작, 일부 디렉토리에서 모든 css파일 확인:
```shell
browser-sync start --server --files '{{디렉토리/의/경로/*.css}}'
```
#### 구성 파일 생성:
```shell
browser-sync init
```
#### 구성 파일에서 브라우저 동기화 시작:
```shell
browser-sync start --config {{config_파일}}
```
{% endraw %}{% raw %}
<h2 id="bundle">
  <a href="/ko/common/bundle.html">bundle</a> <a href="#bundle"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Ruby 프로그래밍 언어의 종속성 관리자.
> 더 많은 정보: <https://bundler.io/man/bundle.1.html>.

#### 작업 디렉토리에 있는 `Gemfile`에 정의된 모든 gem을 설치:
```shell
bundle install
```
#### `Gemfile` 에 정의된 규칙에 따라 모든 gem을 업데이트 하고 `Gemfile.lock`을 재생성:
```shell
bundle update
```
#### `Gemfile`에 정의된 특정 gem을 업데이트:
```shell
bundle update --source {{gem명}}
```
#### 새로운 gem의 스켈레톤 생성:
```shell
bundle gem {{gem명}}
```
{% endraw %}{% raw %}
<h2 id="bup">
  <a href="/ko/common/bup.html">bup</a> <a href="#bup"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Git 팩 파일 형식을 기반으로 하는 백업 시스템, 빠른 증분 저장 및. 전역 중복 제거 기능 제공.
> 더 많은 정보: <https://github.com/bup/bup>.

#### 지정된 로컬 디렉토리에서 백업 저장소 초기화:
```shell
bup -d {{저장소/의/경로}} init
```
#### 백업을 수행하기 전에 지정된 디렉토리 준비:
```shell
bup -d {{저장소/의/경로}} index {{디렉토리/의/경로}}
```
#### 저장소에 디렉토리 백업:
```shell
bup -d {{저장소/의/경로}} save -n {{백업명}} {{디렉토리/의/경로}}
```
#### 현재 저장소에 저장된 백업 스냅샷 표시:
```shell
bup -d {{저장소/의/경로}} ls
```
#### 특정 백업 스냅샷을 목적 디렉토리에 복원:
```shell
bup -d {{저장소/의/경로}} restore -C {{타겟_디렉토리/의/경로}} {{백업명}}
```
{% endraw %}{% raw %}
<h2 id="buzzphrase">
  <a href="/ko/common/buzzphrase.html">buzzphrase</a> <a href="#buzzphrase"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 임의의 buzzphrase를 출력하는 Node.js 명령 줄 도구.
> 더 많은 정보: <https://github.com/atomantic/buzzphrase>.

#### 형용사, 과거시제 동사 및 복수 명사를 포함하는 세 개의 임의 구문으로 이루어진 문자열 생성:
```shell
buzzphrase
```
#### 동사의 명령형[i] + 동사의 과거시제[v] + 형용사[a] + 복수형 명사[N] 형태로 포맷된 구문 출력:
```shell
buzzphrase {{'{i} {v} {a} {N}'}}
```
#### 현재분사 동사[V] + 형용사[a] + 단수형 명사[n] + 마침[f] 형태로 포맷된 4개의 구문 출력:
```shell
buzzphrase {{4 '{V} {a} {n} {f}'}}
```
{% endraw %}{% raw %}
<h2 id="bw">
  <a href="/ko/common/bw.html">bw</a> <a href="#bw"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Bitwarden 보관함에 접속과 관리를 위한 CLI.
> 더 많은 정보: <https://help.bitwarden.com/article/cli/>.

#### Bitwarden 사용자 계정 로그인:
```shell
bw login
```
#### 사용자 계정 로그아웃:
```shell
bw logout
```
#### Bitwarden 보관함으로부터 아이템 검색과 출력:
```shell
bw list items --search {{github}}
```
#### Bitwarden 보관함으로부터 특정 아이템 출력:
```shell
bw get item {{github}}
```
#### Bitwarden 보관함에 폴더 생성:
```shell
{{echo -n '{"name":"My Folder1"}' | base64}} | bw create folder
```
{% endraw %}{% raw %}
<h2 id="bzip2">
  <a href="/ko/common/bzip2.html">bzip2</a> <a href="#bzip2"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 블록 정렬 파일 압축기.
> 더 많은 정보: <http://bzip.org>.

#### 파일 압축하기:
```shell
bzip2 {{경로/압축할_파일명}}
```
#### 파일 압축해제하기:
```shell
bzip2 -d {{경로/압축된_.bz2파일}}
```
#### 파일을 표준 출력으로 압축해제:
```shell
bzip2 -dc {{경로/압축된_.bz2파일}}
```
{% endraw %}{% raw %}
<h2 id="c99">
  <a href="/ko/common/c99.html">c99</a> <a href="#c99"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ISO C 표준에 따라 C 프로그램을 컴파일한다.
> 더 많은 정보: <https://manned.org/c99>.

#### 원본 파일 컴파일 및 실행 파일 생성:
```shell
c99 {{.c}}
```
#### 원본 파일 압축 및 사용자 정의 이름으로 실행 파일 생성:
```shell
c99 -o {{생성할_실행파일_이름}} {{파일명.c}}
```
#### 원본 파일 압축 및 개체 파일 생성:
```shell
c99 -c {{파일명.c}}
```
#### 원본 파일 압축, 개체 파일 연결 및 실행 파일 생성:
```shell
c99 {{파일명.c}} {{파일명.o}}
```
{% endraw %}{% raw %}
<h2 id="cabal">
  <a href="/ko/common/cabal.html">cabal</a> <a href="#cabal"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Haskell 패키지 인프라 (Cabal)에 대한 명령어 라인 인터페이스.
> Hackage 패키지 저장소에서 Haskell 프로젝트 및 Cabal패키지 관리.
> 더 많은 정보: <https://cabal.readthedocs.io/en/latest/intro.html>.

#### Hackage에서 패키지 검색 및 리스트:
```shell
cabal list {{검색할_문자열}}
```
#### 패키지에 대한 정보 출력:
```shell
cabal info {{패키지_이름}}
```
#### 패키지 다운로드 및 설치:
```shell
cabal install {{패키지_이름}}
```
#### 현재 디렉토리에서 새로운 Haskell 프로젝트 생성:
```shell
cabal init
```
#### 현재 디렉토리에서 프로젝트 빌드:
```shell
cabal build
```
#### 현재 디렉토리에서 프로젝트의 테스트 실행:
```shell
cabal test
```
{% endraw %}{% raw %}
<h2 id="cake">
  <a href="/ko/common/cake.html">cake</a> <a href="#cake"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> CakePHP 프레임 워크용 명령어 라인 프로세서.
> 더 많은 정보: <https://cakephp.org>.

#### 현재 앱 및 사용 가능한 명령어에 대한 기본 정보 표시:
```shell
cake
```
#### 사용 가능한 경로 리스트 표시:
```shell
cake routes
```
#### 구성 캐시 지우기:
```shell
cake cache clear_all
```
#### 메타데이터 캐시 구축:
```shell
cake schema_cache build --connection {{연결할것}}
```
#### 메타데이터 캐시 지우기:
```shell
cake schema_cache clear
```
#### 단일 캐시 테이블 지우기:
```shell
cake schema_cache clear {{테이블_이름}}
```
#### 개발 웹 서버 시작 (포트 기본값 8765):
```shell
cake server
```
#### REPL 대화형 쉘 인스턴스 시작:
```shell
cake console
```
{% endraw %}{% raw %}
<h2 id="calibre-server">
  <a href="/ko/common/calibre-server.html">calibre-server</a> <a href="#calibre-server"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 네트워크를 통해 전자책을 배포하는 데 사용할 수 있는 서버 어플리케이션.
> 이전에 GUI 또는 보정기능을 사용하여 전자책을 라이브러리로 가져와야 함.
> Calibre 전자책 라이브러리의 일부.
> 더 많은 정보: <https://manual.calibre-ebook.com/generated/en/calibre-server.html>.

#### 전자책을 배포할 서버 시작. http://localhost:8080에 연결:
```shell
calibre-server
```
#### 다른 포트에서 서버 시작. http://localhost:port에 연결:
```shell
calibre-server --port {{포트번호}}
```
#### 서버를 암호로 보호:
```shell
calibre-server --username {{사용자이름}} --password {{비밀번호}}
```
{% endraw %}{% raw %}
<h2 id="calibredb">
  <a href="/ko/common/calibredb.html">calibredb</a> <a href="#calibredb"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 전자책 데이터베이스를 조작하는 도구.
> Calibre 전자책 라이브러리의 일부.
> 더 많은 정보: <https://manual.calibre-ebook.com/generated/en/calibredb.html>.

#### 도서관의 전자책들을 추가 정보와 함께 리스트로 출력:
```shell
calibredb list
```
#### 추가 정보를 표시하며 전자책 검색:
```shell
calibredb list --search {{검색_용어}}
```
#### 전자책의 ID만 검색:
```shell
calibredb search {{검색_용어}}
```
#### 라이브러리에 전자책 하나 이상 추가하기:
```shell
calibredb add {{파일명1 파일명2 …}}
```
#### 라이브러리에서 전자책을 하나 이상 제거하기. 전자책 ID 필요(위를 참조하시오):
```shell
calibredb remove {{id1 id2 …}}
```
{% endraw %}{% raw %}
<h2 id="cargo">
  <a href="/ko/common/cargo.html">cargo</a> <a href="#cargo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Rust 패키지 관리프로그램.
> Rust 프로젝트 및 해당 모듈 종속성(크레이트) 관리.
> 더 많은 정보: <https://crates.io/>.

#### 크레이트 검색:
```shell
cargo search {{검색할_문자열}}
```
#### 크레이트 설치:
```shell
cargo install {{크레이트_이름}}
```
#### 설치된 크레이트 목록:
```shell
cargo install --list
```
#### 현재 디렉토리에 새 이진 또는 라이브러리 Rust 프로젝트 생성:
```shell
cargo init --{{bin|lib}}
```
#### 지정된 디렉토리에 새 이진 또는 라이브러리 Rust 프로젝트 생성:
```shell
cargo new {{경로/디렉토리}} --{{bin|lib}}
```
#### 현재 디렉토리에 Rust 프로젝트 구축:
```shell
cargo build
```
#### 특정 쓰레드 수를 사용하여 구축(기본값은 CPU 코어 수):
```shell
cargo build -j {{작업}}
```
{% endraw %}{% raw %}
<h2 id="case">
  <a href="/ko/common/case.html">case</a> <a href="#case"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 표현식의 값에 근거하여 분기.
> 더 많은 정보: <https://manned.org/case>.

#### 변수를 문자열 리터럴과 일치시켜 실행할 명령어 결정:
```shell
case {{$tocount}} in {{words}}) {{wc -w README}}; ;; {{lines}}) {{wc -l README}}; ;; esac
```
#### 패턴을 |와 결합하고, *를 대비책 패턴으로 사용:
```shell
case {{$tocount}} in {{[wW]|words}}) {{wc -w README}}; ;; {{[lL]|lines}}) {{wc -l README}}; ;; *) {{echo "what?"}}; ;; esac
```
{% endraw %}{% raw %}
<h2 id="cat">
  <a href="/ko/common/cat.html">cat</a> <a href="#cat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 출력 및 연결.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/cat>.

#### 표준출력으로 파일 내용 출력:
```shell
cat {{파일명}}
```
#### 여러 파일을 대상 파일에 연결:
```shell
cat {{파일명1}} {{파일명2}} > {{대상_파일명}}
```
#### 대상 파일에 여러 파일 내용 추가:
```shell
cat {{파일명1}} {{파일명2}} >> {{대상_파일명}}
```
#### 모든 출력 라인에 번호 매기기:
```shell
cat -n {{파일명}}
```
#### 출력할 수 없는 문자 및 공백 문자 표시 (ASCII가 아닌 경우 `M-`접두사 포함):
```shell
cat -v -t -e {{파일명}}
```
{% endraw %}{% raw %}
<h2 id="cd">
  <a href="/ko/common/cd.html">cd</a> <a href="#cd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 현재 작업중인 디렉토리 변경.
> 더 많은 정보: <https://man.archlinux.org/man/cd.n>.

#### 주어진 디렉토리로 이동:
```shell
cd {{경로/디렉토리명}}
```
#### 현재 사용자의 홈 디렉토리로 이동:
```shell
cd
```
#### 현재 디렉토리의 상위 디렉토리로 이동:
```shell
cd ..
```
#### 이전에 선택되었던 디렉토리로 이동:
```shell
cd -
```
{% endraw %}{% raw %}
<h2 id="chars">
  <a href="/ko/common/chars.html">chars</a> <a href="#chars"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 다양한 ASCII 및 유니코드 문자 및 코드 포인트에 대한 이름 및 코드 표시.
> 더 많은 정보: <https://github.com/antifuchs/chars>.

#### 밸류 값으로 문자 검색:
```shell
chars '{{ß}}'
```
#### 유니코드 코드로 문자 검색:
```shell
chars {{U+1F63C}}
```
#### 모호한 코드 포인트가 주어지면 가능한 문자 검색:
```shell
chars {{10}}
```
#### 제어 문자 찾기:
```shell
chars "{{^C}}"
```
{% endraw %}{% raw %}
<h2 id="chcon">
  <a href="/ko/common/chcon.html">chcon</a> <a href="#chcon"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 또는 파일/디렉토리의 SELinux 보안 내용 변경.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/chcon>.

#### 파일의 보안 내용 보기:
```shell
ls -lZ {{경로/파일명}}
```
#### 참조된 파일을 사용하여, 대상 파일의 보안 내용 변경:
```shell
chcon --reference={{참조_파일명}} {{대상_파일명}}
```
#### 파일의 전체 SELinux 보안 내용 변경:
```shell
chcon {{사용자}}:{{역할}}:{{타입}}:{{범위/레벨}} {{파일명}}
```
#### SELinux 보안 내용의 사용자 부분만 변경:
```shell
chcon -u {{사용자}} {{파일명}}
```
#### SELinux 보안 내용의 역할 부분만 변경:
```shell
chcon -r {{역할}} {{파일명}}
```
#### SELinux 보안 컨텍스트의 타입 부분만 변경:
```shell
chcon -t {{타입}} {{파일명}}
```
#### SELinux 보안 컨텍스트의 범위/레벨 부분만 변경:
```shell
chcon -l {{범위/레벨}} {{파일명}}
```
{% endraw %}{% raw %}
<h2 id="chgrp">
  <a href="/ko/common/chgrp.html">chgrp</a> <a href="#chgrp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 및 디렉토리의 그룹 소유권 변경.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/chgrp>.

#### 파일/디렉토리의 소유 그룹 변경:
```shell
chgrp {{그룹}} {{경로/파일명_또는_디렉토리명}}
```
#### 디렉토리 및 해당 컨텐츠의 소유 그룹 변경:
```shell
chgrp -R {{그룹}} {{경로/디렉토리명}}
```
#### 심볼릭 링크의 소유 그룹 변경:
```shell
chgrp -h {{그룹}} {{경로/심볼릭_링크}}
```
#### 참조 파일과 일치하도록 파일/디렉토리의 소유 그룹 변경:
```shell
chgrp --reference={{경로/참조_파일명}} {{경로/파일명_또는_디렉토리명}}
```
{% endraw %}{% raw %}
<h2 id="chisel">
  <a href="/ko/common/chisel.html">chisel</a> <a href="#chisel"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Chisel은 TCP 터널을 생성하는 도구.
> 클라이언트와 서버 모두 포함.
> 더 많은 정보: <https://github.com/jpillora/chisel>.

#### chisel 서버 실행:
```shell
chisel 
```
#### 특정 포트를 수신하는 chisel 서버 실행:
```shell
chisel server -p {{서버_포트}}
```
#### 사용자 이름 및 암호 인증을 사용하여 연결을 보호하는 chisel 서버 실행:
```shell
chisel server --auth {{사용자이름}}:{{비밀번호}}
```
#### chisel 서버에 연결하고 특정 포트를 원격 서버 와 포트에 터널링:
```shell
chisel client {{서버_IP}}:{{서버_포트}} {{로컬_포트}}:{{원격_서버}}:{{원격_포트}}
```
#### chisel 서버에 연결하고 특정 호스트와 포트를 원격 서버 및 포트에 터널링:
```shell
chisel client {{서버_IP}}:{{서버_포트}} {{로컬_호스트}}:{{로컬_포트}}:{{원격_서버}}:{{원격_포트}}
```
#### 사용자 이름 및 암호 인증을 사용하여 chisel 서버에 연결:
```shell
chisel client --auth {{사용자이름}}:{{비밀번호}} {{서버_IP}}:{{서버_포트}} {{local_port}}:{{원격_서버}}:{{원격_포트}}
```
{% endraw %}{% raw %}
<h2 id="chmod">
  <a href="/ko/common/chmod.html">chmod</a> <a href="#chmod"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일이나 디렉토리의 연결 권한 변경.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/chmod>.

#### 파일을 소유한 사용자[u]에게 실행[x] 권한 부여:
```shell
chmod u+x {{파일명}}
```
#### 파일/디렉토리에 읽기[r] 와 쓰기[w] 사용자 권한 부여:
```shell
chmod u+rw {{파일명_또는_디렉토리명}}
```
#### 그룹[g]에서 실행 권한 제거:
```shell
chmod g-x {{파일명}}
```
#### 모든[a] 사용자에게 읽기 및 실행 권한 부여:
```shell
chmod a+rx {{파일명}}
```
#### 다른[o] 사람(파일 소유자의 그룹이 아님)에게 그룹과 동일한 권한 부여:
```shell
chmod o=g {{파일명}}
```
#### 그룹[g] 및 다른 사람[o]에 대한 쓰기[w]에 대한 권한을 재귀적으로 변경:
```shell
chmod -R g+w,o+w {{디렉토리명}}
```
{% endraw %}{% raw %}
<h2 id="chown">
  <a href="/ko/common/chown.html">chown</a> <a href="#chown"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일과 디렉토리의 사용자 및 그룹 소유권을 변경.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/chown>.

#### 파일/디렉토리의 소유 사용자 변경:
```shell
chown {{사용자}} {{경로/파일명_또는_디렉토리명}}
```
#### 파일/디렉토리의 소유 사용자 및 그룹 변경:
```shell
chown {{사용자}}:{{그룹}} {{경로/파일명_또는_디렉토리명}}
```
#### 디렉토리 소유자와 그 내용을 재귀적으로 변경:
```shell
chown -R {{사용자}} {{경로/디렉토리명}}
```
#### 심볼릭 링크의 소유자 변경:
```shell
chown -h {{사용자}} {{경로/심볼릭_링크}}
```
#### 참조 파일과 일치하도록 파일/디렉토리 소유자 변경:
```shell
chown --reference={{경로/참조_파일명}} {{경로/파일명_또는_디렉토리명}}
```
{% endraw %}{% raw %}
<h2 id="chromium">
  <a href="/ko/common/chromium.html">chromium</a> <a href="#chromium"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 구글에서 제공하는 오픈소스 웹 브라우저.
> 더 많은 정보: <https://chromium.org>.

#### 파일 열기:
```shell
chromium {{경로/파일명.html}}
```
#### URL 열기:
```shell
chromium {{example.com}}
```
#### 익명으로 열기:
```shell
chromium --incognito {{example.com}}
```
#### 새 창에서 열기:
```shell
chromium --new-window {{example.com}}
```
#### 앱 모드로 열기 (툴바, URL 바, 버튼 등 제외):
```shell
chromium --app='{{https://example.com}}'
```
#### 프록시 서버 사용:
```shell
chromium --proxy-server="{{socks5://hostname:66}}" {{example.com}}
```
{% endraw %}{% raw %}
<h2 id="chroot">
  <a href="/ko/common/chroot.html">chroot</a> <a href="#chroot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 특수 루트 디렉토리를 사용하여 명령 또는 대화형 쉘 실행.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/chroot>.

#### 새로운 루트 디렉토리로 명령어 실행:
```shell
chroot {{/경로/새로운/루트/디렉토리}} {{명령어}}
```
#### 사용할 사용자 및 그룹(ID 또는 이름) 지정:
```shell
chroot --userspec={{사용자:그룹}}
```
{% endraw %}{% raw %}
<h2 id="chsh">
  <a href="/ko/common/chsh.html">chsh</a> <a href="#chsh"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 사용자 로그인 쉘을 변경합니다.
> 더 많은 정보: <https://manned.org/chsh>.

#### 쉘 변경하기:
```shell
chsh -s {{경로/쉘_바이너리명}} {{사용자이름}}
```
{% endraw %}{% raw %}
<h2 id="cksum">
  <a href="/ko/common/cksum.html">cksum</a> <a href="#cksum"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일의 바이트 개수나 CRC 무결성 검사를 계산합니다.
> 알립니다, 오래된 UNIX 시스템은 CRC 검사가 다를 수 있습니다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/cksum>.

#### 바이트 단위의 사이즈와 파일이름의 32비트 무결성 검사를 보여줍니다:
```shell
cksum {{파일명}}
```
{% endraw %}{% raw %}
<h2 id="clamscan">
  <a href="/ko/common/clamscan.html">clamscan</a> <a href="#clamscan"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 바이러스 검사를 하는 줄 명령어.
> 더 많은 정보: <https://www.clamav.net>.

#### 약점이 있는 파일을 검사합니다:
```shell
clamscan {{경로/파일}}
```
#### 특정 디렉토리의 모든 파일을 재귀적으로 검사합니다:
```shell
clamscan -r {{경로/디렉토리}}
```
#### stdin 으로부터 데이터를 검사합니다:
```shell
{{명령어}} | clamscan -
```
#### 바이러스 데이터베이스 파일 또는 파일 디렉토리 지정합니다:
```shell
clamscan --database {{경로/데이터베이스_파일_혹은_디렉토리}}
```
#### 현재 디렉토리를 검색하고 감염된 파일만 출력합니다:
```shell
clamscan --infected
```
#### 검사한 리포트를 로그 파일로 내보냅니다:
```shell
clamscan --log {{경로/로그파일}}
```
#### 특정 디렉토리로 감염된 파일을 보냅니다:
```shell
clamscan --move {{경로/감염된_디렉토리}}
```
#### 감연된 파일을 제거합니다:
```shell
clamscan --remove yes
```
{% endraw %}{% raw %}
<h2 id="clang">
  <a href="/ko/common/clang.html">clang</a> <a href="#clang"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> C, C++ 그리고 Objective-C 소스 파일을 컴파일합니다. GCC의 드롭인 대체로 사용할 수 있습니다.
> 더 많은 정보: <https://clang.llvm.org/docs/ClangCommandLineReference.html>.

#### 실행 가능한 바이너리 파일로 소스 코드를 컴파일합니다:
```shell
clang {{입력_소스.c}} -o {{출력_실행가능파일}}
```
#### 모든 에러와 경고 메시지를 출력하도록 활성화합니다:
```shell
clang {{입력_소스.c}} -Wall -o {{출력_실행가능파일}}
```
#### 소스 파일과 다른 경로에 있는 라이브러리를 포함합니다:
```shell
clang {{입력_소스.c}} -o {{출력_실행가능파일}} -I{{헤더_경로}} -L{{라이브러리_경로}} -l{{라이브러리명}}
```
#### 소스 코드를 LLVM Intermediate Representation(IR)로 컴파일 합니다:
```shell
clang -S -emit-llvm {{파일.c}} -o {{파일.ll}}
```
{% endraw %}{% raw %}
<h2 id="clear">
  <a href="/ko/common/clear.html">clear</a> <a href="#clear"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 터미널 화면을 지웁니다(clear).
> 더 많은 정보: <https://manned.org/clear>.

#### 터미널 화면을 지웁니다 (bash 쉘에서 Control-L을 누르는 것과 같은 기능입니다):
```shell
clear
```
{% endraw %}{% raw %}
<h2 id="clementine">
  <a href="/ko/common/clementine.html">clementine</a> <a href="#clementine"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 현대적인 음악 플레이어이자 라이브러리 생성자.
> 더 많은 정보: <https://www.clementine-player.org>.

#### Clementine 열기:
```shell
clementine
```
#### 음악 파일을 실행합니다:
```shell
clementine {{url_혹은_경로/파일.ext}}
```
#### 정지, 재생 버튼(Toggle):
```shell
clementine --play-pause
```
#### 재생 멈추기:
```shell
clementine --stop
```
#### 다음 트랙 넘기기:
```shell
clementine --next
```
#### 이전 트랙 넘기기:
```shell
clementine --previous
```
#### 플레이리스트 파일 불러오기:
```shell
clementine --load {{경로/재생리스트.ext}}
```
#### 현재 불러온 플레이리스트에서 5번째 트랙 재생하기:
```shell
clementine --play-track {{5}}
```
{% endraw %}{% raw %}
<h2 id="cloc">
  <a href="/ko/common/cloc.html">cloc</a> <a href="#cloc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 소스코드와 주석의 줄 개수를 세고 차이를 계산합니다.
> 더 많은 정보: <https://github.com/AlDanial/cloc>.

#### 디렉토리 안의 모든 코드의 줄 개수를 셉니다:
```shell
cloc {{/경로/디렉토리}}
```
#### 진행 바로 현재 진행 중인 과정을 보여주면서 디렉토리 안의 모든 코드의 줄 개수를 셉니다:
```shell
cloc --progress=1 {{/경로/디렉토리}}
```
#### 두 개의 디렉토리 구조를 비교하고 차이의 개수를 셉니다:
```shell
cloc --diff {{/디렉토리/첫번째}} {{/디렉토리/두번째}}
```
{% endraw %}{% raw %}
<h2 id="clockwork-cli">
  <a href="/ko/common/clockwork-cli.html">clockwork-cli</a> <a href="#clockwork-cli"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Clockwork PHP 디버깅 프레임워크를 위한 줄 명령어 인터페이스.
> 더 많은 정보: <https://github.com/ptrofimov/clockwork-cli>.

#### 현재 프로젝트의 Clockwork 로그들을 모니터링 합니다:
```shell
clockwork-cli
```
#### 특정 프로젝트의 Clockwork 로그들을 모니터링 합니다:
```shell
clockwork-cli {{경로/디렉토리}}
```
#### 여러 개의 프로젝트의 Clockwork 로그들을 모니터링 합니다:
```shell
clockwork-cli {{경로/디렉토리1 경로/디렉토리2 …}}
```
{% endraw %}{% raw %}
<h2 id="cmake">
  <a href="/ko/common/cmake.html">cmake</a> <a href="#cmake"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 빌드 시스템을 생성하는 크로스 플랫폼으로 선택한 시스템에 따라 Makefiles, Visual Studio 프로젝트 또는 기타를 생성합니다.
> 더 많은 정보: <https://cmake.org/cmake/help/v3.2/manual/cmake.1.html>.

#### 작성 파일을 생성하고 이를 사용하여 원본과 동일한 디렉토리에서 프로젝트를 컴파일합니다:
```shell
cmake && make
```
#### Makefile을 생성하고 이를 사용하여 별도의 "빌드" 디렉토리(소스 외 빌드)에 프로젝트를 컴파일합니다:
```shell
cmake -H. -B{{빌드}} && make -C {{빌드}}
```
#### 대화형 모드로 cmake를 실행 (기본값을 사용하는 대신 각 변수에 대해 요청합니다):
```shell
cmake -i
```
{% endraw %}{% raw %}
<h2 id="cmark">
  <a href="/ko/common/cmark.html">cmark</a> <a href="#cmark"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> CommonMark Markdown 텍스트를 다른 텍스트 형식으로 변환합니다.
> 더 많은 정보: <https://github.com/commonmark/cmark>.

#### CommonMark Markdown 파일을 HTML 파일로 렌더링합니다:
```shell
cmark --to html {{파일명.md}}
```
#### 데이터를 표준 입력에서 라텍스로 변환:
```shell
cmark --to latex
```
#### 직선 따옴표를 스마트 따옴표로 변환:
```shell
cmark --smart --to html {{파일명.md}}
```
#### UTF-8 문자들을 검증:
```shell
cmark --validate-utf8 {{파일명.md}}
```
{% endraw %}{% raw %}
<h2 id="cmp">
  <a href="/ko/common/cmp.html">cmp</a> <a href="#cmp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 두 개의 파일 비교.
> 더 많은 정보: <https://www.gnu.org/software/diffutils/manual/html_node/Invoking-cmp.html>.

#### 파일 간의 첫 번째 바이트 번호와 선 번호의 차이를 찾습니다:
```shell
cmp {{파일1}} {{파일2}}
```
#### 모든 바이트 수와 다른 바이트의 차이 찾기:
```shell
cmp -l {{파일1}} {{파일2}}
```
{% endraw %}{% raw %}
<h2 id="code">
  <a href="/ko/common/code.html">code</a> <a href="#code"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 비주얼 스튜디오 코드.
> 더 많은 정보: <https://github.com/microsoft/vscode>.

#### VS Code 열기:
```shell
code
```
#### 현재 디렉토리에서 VS Code 열기:
```shell
code .
```
#### 파일이나 디렉토리에서 VS Code 열기:
```shell
code {{경로/파일_혹은_디렉토리}}
```
#### 현재 열려 있는 VS 코드 창에서 파일 또는 디렉토리를 열기:
```shell
code --reuse-window {{경로/파일_혹은_디렉토리}}
```
#### 두 개의 VS Code 파일 비교:
```shell
code -d {{파일1}} {{파일2}}
```
{% endraw %}{% raw %}
<h2 id="coffee">
  <a href="/ko/common/coffee.html">coffee</a> <a href="#coffee"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Coffee Script를 실행하거나 JavaScript로 컴파일합니다.
> 더 많은 정보: <https://coffeescript.org#cli>.

#### 스크립트 실행:
```shell
coffee {{경로/파일.coffee}}
```
#### JavaScript로 컴파일 하거나 같은 이름의 파일로 저장합니다:
```shell
coffee --compile {{경로/파일.coffee}}
```
#### JavaScript로 컴파일 하거나 주어진 출력 파일로 저장합니다:
```shell
coffee --compile {{경로/파일.coffee}} --output {{경로/파일.js}}
```
#### 대화형 REPL 실행:
```shell
coffee --interactive
```
#### 스크립트의 변화를 보거나 다시 실행합니다:
```shell
coffee --watch {{경로/파일.coffee}}
```
{% endraw %}{% raw %}
<h2 id="column">
  <a href="/ko/common/column.html">column</a> <a href="#column"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 표준 입력 또는 파일을 여러 열로 포맷 설정.
> 행 앞에 열이 채워짐; 기본 구분 기호는 공백입니다.
> 더 많은 정보: <https://manned.org/column>.

#### 30자 폭 디스플레이의 형식 출력으로 포맷 정하기:
```shell
printf "header1 header2\nbar foo\n" | column --output-width {{30}}
```
#### 열 자동 분할 및 자동 정렬을 표 형식으로 분할:
```shell
printf "header1 header2\nbar foo\n" | column --table
```
#### -t 옵션(예: "", csv)에 대한 열 구분 기호 문자를 지정; 기본값은 공백입니다:
```shell
printf "header1,header2\nbar,foo\n" | column --table --separator {{,}}
```
#### 열을 채우기 전에 행 채우기:
```shell
printf "header1\nbar\nfoobar\n" | column --output-width {{30}} --fillrows
```
{% endraw %}{% raw %}
<h2 id="comm">
  <a href="/ko/common/comm.html">comm</a> <a href="#comm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 두 파일의 공통되는 줄을 선택하거나 거절합니다.
> 두 파일 모두 정렬되어 있어야합니다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/comm>.

#### 세 개의 탭으로 구분된 열을 생성합니다: 첫 번째 파일에는 줄만, 두 번째 파일에서는 줄들과 공통 줄:
```shell
comm {{파일1}} {{파일2}}
```
#### 두 파일의 공통된 줄들만 출력:
```shell
comm -12 {{파일1}} {{파일2}}
```
#### stdin으로 읽어드린 하나의 파일과 나머지 파일의 공통된 줄들만 출력:
```shell
cat {{파일1}} | comm -12 - {{파일2}}
```
#### 첫 번째 파일에서만 줄을 가져오고 결과를 세 번째 파일에 저장:
```shell
comm -23 {{파일1}} {{파일2}} > {{파일1_only}}
```
#### 파일이 정렬되지 않은 경우 두 번째 파일에서만 줄을 출력합니다:
```shell
comm -13 <(sort {{파일1}}) <(sort {{파일2}})
```
{% endraw %}{% raw %}
<h2 id="command">
  <a href="/ko/common/command.html">command</a> <a href="#command"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Command 명령은 쉘이 프로그램을 실행하고 동일한 이름의 기능, 빌드인 및 별칭을 무시하도록 합니다.
> 더 많은 정보: <https://manned.org/command>.

#### ls 별칭이 존재하더라도 문자 그대로 `ls` 프로그램을 실행:
```shell
command {{ls}}
```
{% endraw %}{% raw %}
<h2 id="complete">
  <a href="/ko/common/complete.html">complete</a> <a href="#complete"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 쉘 명령어에 자동 완성 인자를 제공합니다.
> 더 많은 정보: <https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html>.

#### 함수에 명령어 자동 완성 기능을 적용합니다:
```shell
complete -F {{함수}} {{명령어}}
```
#### 다른 명령어에 명령어 자동 완성 기능을 적용합니다:
```shell
complete -C {{자동완성_명령어}} {{명령어}}
```
#### 작성 완료된 단어에 공백을 추가하지 않고 자동 완성 기능을 적용합니다:
```shell
complete -o nospace -F {{함수}} {{명령어}}
```
{% endraw %}{% raw %}
<h2 id="composer">
  <a href="/ko/common/composer.html">composer</a> <a href="#composer"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> PHP 프로젝트의 의존성(dependency)을 기반으로 한 매니저 패키지.
> 더 많은 정보: <https://getcomposer.org/>.

#### 프로젝트의 의존성(dependency)으로 패키지를 추가합니다, 다음에 추가합니다 `composer.json`:
```shell
composer require {{사용자/패키지명}}
```
#### 프로젝트의 `composer.json` 안에 모든 의존성(dependency)를 설치합니다 :
```shell
composer install
```
#### 프로젝트의 패키지를 제거하며 `composer.json` 안의 모든 의존성(dependency)를 제거합니다:
```shell
composer remove {{사용자/패키지명}}
```
#### 프로젝트의 `composer.json` 파일의 모든 의존성(dependency)를 업데이트 합니다:
```shell
composer update
```
#### composer를 최신 버전으로 업데이트 합니다:
```shell
composer self-update
```
{% endraw %}{% raw %}
<h2 id="conda">
  <a href="/ko/common/conda.html">conda</a> <a href="#conda"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 프로그래밍 언어에 대한 패키지, 의존성 및 환경 관리.
> 더 많은 정보: <https://github.com/conda/conda>.

#### 새로운 환경을 생성합니다, 이름이 주어진 패키지로 설치합니다:
```shell
conda create --name {{환경_이름}} {{python=2.7 matplotlib}}
```
#### 모든 환경의 리스트를 보여줍니다:
```shell
conda info --envs
```
#### 환경을 불러오거나 내립니다:
```shell
conda {{활성화|비활성화}} {{환경_이름}}
```
#### 모든 환경을 제거합니다 (모든 패키지 제거):
```shell
conda remove --name {{환경_이름}} --all
```
#### 패키지 이름으로 conda의 채널을 찾습니다:
```shell
conda search {{패키지명}}
```
#### 현재 환경의 패키지를 설치합니다:
```shell
conda install {{python=3.4 numpy}}
```
#### 현재 혼경의 설치된 패키지의 리스트를 보여줍니다:
```shell
conda list
```
#### 사용하지 않는 패키지나 캐시를 제거합니다:
```shell
conda clean --all
```
{% endraw %}{% raw %}
<h2 id="consul-kv">
  <a href="/ko/common/consul-kv.html">consul-kv</a> <a href="#consul-kv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 서비스 검색 기능과 상태 확인을 위한 분산된 키-값(key-value)쌍 저장.
> 더 많은 정보: <https://learn.hashicorp.com/consul/getting-started/kv>.

#### 키-값(key-value)쌍으로 저장된 값 읽기:
```shell
consul kv get {{키}}
```
#### 새로운 키-값(key-value)쌍으로 저장:
```shell
consul kv put {{키}} {{값}}
```
#### 키-값(key-value)쌍 제거:
```shell
consul kv delete {{키}}
```
{% endraw %}{% raw %}
<h2 id="consul">
  <a href="/ko/common/consul.html">consul</a> <a href="#consul"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 서비스 검색 기능과 상태 확인을 위한 분산된 키-값(key-value)쌍 저장.
> 더 많은 정보: <https://www.consul.io/commands>.

#### Consul 버전을 체크합니다:
```shell
consul --version
```
#### 일반 도움말을 보여줍니다:
```shell
consul --help
```
#### 서브 명령어를 위한 도움말을 보여줍니다:
```shell
consul {{하위-명령어}} --help
```
{% endraw %}{% raw %}
<h2 id="convert">
  <a href="/ko/common/convert.html">convert</a> <a href="#convert"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ImageMagick 이미지 변환 도구.
> 더 많은 정보: <https://imagemagick.org/script/convert.php>.

#### JPG이미지를 PNG이미지로 변환:
```shell
convert {{이미지.jpg}} {{이미지.png}}
```
#### 이미지를 원래 크기의 50%로 조정:
```shell
convert {{이미지.png}} -resize 50% {{이미지2.png}}
```
#### 원래 종횡비를 유지하면서 이미지를 최대 640x480 크기로 조정:
```shell
convert {{이미지.png}} -resize 640x480 {{이미지2.png}}
```
#### 이미지를 가로로 추가:
```shell
convert {{이미지1.png}} {{이미지2.png}} {{이미지3.png}} +append {{이미지123.png}}
```
#### 이미지를 세로로 추가:
```shell
convert {{이미지1.png}} {{이미지2.png}} {{이미지3.png}} -append {{이미지123.png}}
```
#### 100ms 지연된 일련의 이미지에서 GIF 만들기:
```shell
convert {{이미지1.png}} {{이미지2.png}} {{이미지3.png}} -delay {{100}} {{애니메이션.gif}}
```
#### 단색 배경만으로 이미지 만들기:
```shell
convert -size {{800x600}} "xc:{{#ff0000}}" {{이미지.png}}
```
{% endraw %}{% raw %}
<h2 id="convmv">
  <a href="/ko/common/convmv.html">convmv</a> <a href="#convmv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 한 인코딩에서 다른 인코딩으로 파일 이름(파일 내용 X)을 변환.
> 더 많은 정보: <https://www.j3e.de/linux/convmv/man/>.

#### 파일 이름 인코딩 변환 테스트(파일 이름을 실제로 변경하지 마십시오):
```shell
convmv -f {{인코딩_에서}} -t {{인코딩_으로}} {{입력_파일}}
```
#### 파일 이름 인코딩을 변환하고 파일 이름을 새 인코딩으로 변환:
```shell
convmv -f {{인코딩_에서}} -t {{인코딩_으로}} --notest {{입력_파일}}
```
{% endraw %}{% raw %}
<h2 id="copyq">
  <a href="/ko/common/copyq.html">copyq</a> <a href="#copyq"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 고급 기능을 갖춘 클립보드 매니저.
> 더 많은 정보: <https://hluk.github.io/CopyQ/>.

#### copyQ를 시작하여 클립보드 기록 저장:
```shell
copyq
```
#### 현재 클립보드 내용 표시:
```shell
copyq clipboard
```
#### 클립보드 기록에 원본 텍스트 삽입:
```shell
copyq add -- {{텍스트1}} {{텍스트2}} {{텍스트3}}
```
#### 이스케이프 시퀀스 ('\n', '\t')가 포함 된 텍스트를 클립보드 기록에 삽입:
```shell
copyq add {{첫째 줄\n둘째 줄}}
```
#### 클립보드 기록에서 처음 3개 항목의 내용을 출력:
```shell
copyq read 0 1 2
```
#### 파일 내용을 클립보드에 복사:
```shell
copyq copy < {{파일.txt}}
```
#### JPEG 이미지를 클립보드에 복사:
```shell
copyq copy image/jpeg < {{이미지.jpg}}
```
{% endraw %}{% raw %}
<h2 id="cordova">
  <a href="/ko/common/cordova.html">cordova</a> <a href="#cordova"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> HTML, CSS 및 JS가 포함된 모바일 앱.
> 더 많은 정보: <https://cordova.apache.org/docs/en/latest/guide/cli/>.

#### cordova 프로젝트 생성:
```shell
cordova create {{경로}} {{패키지_명}} {{프로젝트_명}}
```
#### 현재 작업 공간 상태 표시:
```shell
cordova info
```
#### cordova 플랫폼 추가:
```shell
cordova platform add {{플랫폼}}
```
#### cordova 플랫폼 제거:
```shell
cordova platform remove {{플랫폼}}
```
#### cordova 플러그인 추가:
```shell
cordova plugin add {{플러그인id}}
```
#### cordova 플러그인 제거:
```shell
cordova plugin remove {{플러그인id}}
```
{% endraw %}{% raw %}
<h2 id="cotton">
  <a href="/ko/common/cotton.html">cotton</a> <a href="#cotton"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 마크다운 테스트 사양 러너.
> 더 많은 정보: <https://github.com/chonla/cotton>.

#### 특정 기본 URL 사용하기:
```shell
cotton -u {{기본_url}} {{파일}}.md
```
#### 인증서 확인 비활성화(비 보안 모드):
```shell
cotton -u {{기본_url}} -i {{파일}}.md
```
#### 테스트 실패시 실행 중지:
```shell
cotton -u {{기본_url}} -s {{파일}}.md
```
{% endraw %}{% raw %}
<h2 id="couchdb">
  <a href="/ko/common/couchdb.html">couchdb</a> <a href="#couchdb"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Apache CouchDB 데이터베이스 서버의 명령 행 인터페이스.
> 더 많은 정보: <https://couchdb.apache.org>.

#### couchdb 시작하기:
```shell
couchdb
```
#### couchdb 대화식 쉘 시작하기:
```shell
couchdb -i
```
#### 백그라운드 프로세스로 couchdb 시작하기:
```shell
couchdb -b
```
#### 백그라운드 프로세스 종료(참고 : 필요한 경우 다시 생성됨):
```shell
couchdb -k
```
#### 백그라운드 프로세스 종료:
```shell
couchdb -d
```
{% endraw %}{% raw %}
<h2 id="cowsay">
  <a href="/ko/common/cowsay.html">cowsay</a> <a href="#cowsay"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 무언가를 말하거나 생각하는 ASCII 문자(기본적으로 cow)를 생성.
> 더 많은 정보: <https://github.com/tnalpgge/rank-amateur-cowsay>.

#### "Hello world"라고 말하는 ASCII cow 출력:
```shell
cowsay "Hello world"
```
#### 풍선에 표준 입력의 텍스트 사용:
```shell
echo "Hello" | cowsay
```
#### 사용 가능한 모든 문자 나열:
```shell
cowsay -l
```
#### "Hello"라고 말하는 ASCII dragon 출력:
```shell
cowsay -f dragon "Hello"
```
#### 돌로 된 생각하는 ASCII cow 출력:
```shell
cowthink -s "I'm just a cow, not a great thinker..."
```
{% endraw %}{% raw %}
<h2 id="cp">
  <a href="/ko/common/cp.html">cp</a> <a href="#cp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 및 디렉토리 복사.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/cp>.

#### 파일을 다른 위치로 복사:
```shell
cp {{파일.ext/의/경로}} {{복사본.ext/의/경로}}
```
#### 파일 이름을 유지하면서 파일을 다른 디렉토리에 복사:
```shell
cp {{파일.ext/의/경로}} {{타겟_부모_디렉토리/의/경로}}
```
#### 디렉토리의 내용을 다른 위치에 재귀적으로 복사(대상이 존재하면 디렉토리가 그 안에 복사됨):
```shell
cp -r {{디렉토리/의/경로}} {{복사본/의/경로}}
```
#### 상세모드에서 디렉토리를 재귀적으로 복사(파일이 복사 될 때 표시됨):
```shell
cp -vr {{디렉토리/의/경로}} {{복사본/의/경로}}
```
#### 대화식 모드에서 텍스트 파일을 다른 위치로 복사(덮어 쓰기 전에 사용자에게 일러줌):
```shell
cp -i {{*.txt}} {{타겟_디렉토리/의/경로}}
```
{% endraw %}{% raw %}
<h2 id="cpio">
  <a href="/ko/common/cpio.html">cpio</a> <a href="#cpio"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 아카이브 안팎으로 파일을 복사. cpio의 custom binary, old ASCII, new ASCII, crc, HPUX binary, HPUX old ASCII, old tar, POSIX.1 tar.와 같은 아카이브 형식을 지원함.
> 더 많은 정보: <https://www.gnu.org/software/cpio>.

#### 표준 입력에서 파일 이름 목록을 가져와서 cpio의 이진 형식으로 아카이브[o]에 추가:
```shell
echo "{{파일1}} {{파일2}} {{파일3}}" | cpio -o > {{archive.cpio}}
```
#### 디렉토리의 모든 파일과 디렉토리를 복사하여 [v]상세모드에서 아카이브[o]에 추가:
```shell
find {{디렉토리/의/경로}} | cpio -ov > {{archive.cpio}}
```
#### 아카이브에 모든 파일을 [i]선택하여 필요한 경우 [v]상세모드로 [d]디렉토리를 생성:
```shell
cpio -idv < {{archive.cpio}}
```
{% endraw %}{% raw %}
<h2 id="cppcheck">
  <a href="/ko/common/cppcheck.html">cppcheck</a> <a href="#cppcheck"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> C/C++ 코드를 위한 정적 분석 도구.
> 구문 오류 대신 컴파일러가 일반적으로 감지하지 못하는 버그 유형에 중점을 둠.
> 더 많은 정보: <http://cppcheck.sourceforge.net>.

#### 화면에 진행률을 표시하고 오류 메시지를 파일에 로깅하여 현재 디렉토리를 반복적으로 확인:
```shell
cppcheck . 2> cppcheck.log
```
#### 주어진 디렉토리를 재귀적으로 확인하고, 진행 메시지를 출력하지 않음:
```shell
cppcheck --quiet {{디렉토리/의/경로}}
```
#### 수행 할 테스트를 지정하여 주어진 파일을 확인(기본적으로 오류만 표시됨):
```shell
cppcheck --enable={{error|warning|style|performance|portability|information|all}} {{file.cpp/의/경로}}
```
#### 사용 가능한 테스트 목록:
```shell
cppcheck --errorlist
```
#### 특정 테스트를 무시하고 주어진 파일을 확인:
```shell
cppcheck --suppress={{test_id1}} --suppress={{test_id2}} {{file.cpp/의/경로}}
```
#### 현재 디렉토리를 확인하여 외부에 있는 include 파일의 경로를 제공(예 : 외부 라이브러리):
```shell
cppcheck -I {{include/디렉토리_1}} -I {{include/디렉토리_2}} .
```
#### Microsoft Visual Studio 프로젝트 (`*.vcxproj`) 또는 솔루션 (`*.sln`)을 확인:
```shell
cppcheck --project={{project.sln/의/경로}}
```
{% endraw %}{% raw %}
<h2 id="cppclean">
  <a href="/ko/common/cppclean.html">cppclean</a> <a href="#cppclean"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> C++ 프로젝트에서 사용하지 않는 코드 찾기.
> 더 많은 정보: <https://github.com/myint/cppclean>.

#### 프로젝트 디렉토리에서 실행:
```shell
cppclean {{프로젝트/의/경로}}
```
#### 헤더가 `inc1/` 및 `inc2/` 디렉토리에 있는 프로젝트에서 실행:
```shell
cppclean {{프로젝트/의/경로}} --include-path={{inc1}} --include-path={{inc2}}
```
#### 특정 팡리 `main.cpp`에서 실행:
```shell
cppclean {{main.cpp}}
```
#### `build`디렉토리를 제외한 현재 디렉토리에서 실행:
```shell
cppclean {{.}} --exclude={{build}}
```
{% endraw %}{% raw %}
<h2 id="cradle-deploy">
  <a href="/ko/common/cradle-deploy.html">cradle deploy</a> <a href="#cradle-deploy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle 배포 관리.
> 더 많은 정보: <https://cradlephp.github.io/docs/3.B.-Reference-Command-Line-Tools.html#deploy>.

#### 서버에 Cradle을 배포:
```shell
cradle deploy production
```
#### 아마존 S3에 정적 자산 배포:
```shell
cradle deploy s3
```
#### Yarn "components" 디렉토리를 포함하여 정적 자산 배포:
```shell
cradle deploy s3 --include-yarn
```
#### "upload" 디렉토리를 포함한 정적 자산 배포:
```shell
cradle deploy s3 --include-upload
```
{% endraw %}{% raw %}
<h2 id="cradle-elastic">
  <a href="/ko/common/cradle-elastic.html">cradle elastic</a> <a href="#cradle-elastic"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle 인스턴스의 ElasticSearch 인스턴스 관리.
> 더 많은 정보: <https://cradlephp.github.io/docs/3.B.-Reference-Command-Line-Tools.html#elastic>.

#### ElasticSearch 색인 자르기:
```shell
cradle elastic flush
```
#### 특정 패키지에 대한 ElasticSearch 색인 자르기:
```shell
cradle elastic flush {{패키지_명}}
```
#### ElasticSearch 스키마 제출:
```shell
cradle elastic map
```
#### 특정 패키지에 대한 ElasticSearch 스키마 제출:
```shell
cradle elastic map {{패키지_명}}
```
#### 모든 패키지에 대한 ElasticSearch 색인 채우기:
```shell
cradle elastic populate
```
#### 특정 패키지에 대한 ElasticSearch 색인 채우기:
```shell
cradle elastic populate {{패키지_명}}
```
{% endraw %}{% raw %}
<h2 id="cradle-install">
  <a href="/ko/common/cradle-install.html">cradle install</a> <a href="#cradle-install"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle PHP 프레임워크 구성 요소를 설치.
> 더 많은 정보: <https://cradlephp.github.io/docs/3.B.-Reference-Command-Line-Tools.html#install>.

#### Cradle의 구성요소 설치 (유저는 자세한 내용을 묻는 메시지를 받음):
```shell
cradle install
```
#### 파일을 강제로 덮어 쓰기:
```shell
cradle install --force
```
#### 실행중인 SQL 마이그레이션 건너 뛰기:
```shell
cradle install --skip-sql
```
#### 실행중인 패키지 업데이트 건너 뛰기:
```shell
cradle install --skip-versioning
```
#### 특정 데이터베이스 세부 사항 사용:
```shell
cradle install -h {{호스트명}} -u {{유저명}} -p {{비밀번호}}
```
{% endraw %}{% raw %}
<h2 id="cradle-package">
  <a href="/ko/common/cradle-package.html">cradle package</a> <a href="#cradle-package"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle 인스턴스의 패키지 관리.
> 더 많은 정보: <https://cradlephp.github.io/docs/3.B.-Reference-Command-Line-Tools.html#package>.

#### 사용가능한 패키지 목록 표시:
```shell
cradle package list
```
#### 패키지 검색:
```shell
cradle package search {{패키지}}
```
#### Packagist에서 패키지 설치:
```shell
cradle package install {{패키지}}
```
#### 특정 버전의 패키지 설치:
```shell
cradle package install {{패키지}} {{버전}}
```
#### 패키지 업데이트:
```shell
cradle package update {{패키지}}
```
#### 패키지를 특정 버전으로 업데이트:
```shell
cradle package update {{패키지}} {{버전}}
```
#### 특정 패키지 제거:
```shell
cradle package remove {{패키지}}
```
{% endraw %}{% raw %}
<h2 id="cradle-sql">
  <a href="/ko/common/cradle-sql.html">cradle sql</a> <a href="#cradle-sql"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle SQL 데이터베이스 관리.
> 더 많은 정보: <https://cradlephp.github.io/docs/3.B.-Reference-Command-Line-Tools.html#sql>.

#### 데이터베이스 스키마 재구축:
```shell
cradle sql build
```
#### 특정 패키지에 대한 데이터베이스 스키마 재구축:
```shell
cradle sql build {{패키지_명}}
```
#### 전체 데이터베이스 비우기:
```shell
cradle sql flush
```
#### 특정 패키지에 대한 데이터베이스 테이블 비우기:
```shell
cradle sql flush {{패키지_명}}
```
#### 모든 패키지에 대한 테이블 채우기:
```shell
cradle sql populate
```
#### 특정 패키지에 대한 테이블 채우기:
```shell
cradle sql populate {{패키지_명}}
```
{% endraw %}{% raw %}
<h2 id="cradle">
  <a href="/ko/common/cradle.html">cradle</a> <a href="#cradle"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cradle PHP 프레임워크.
> 추가 정보는 `cradle-install`, `cradle-deploy` 및 기타 페이지 참조.
> 더 많은 정보: <https://cradlephp.github.io>.

#### 서버에 연결:
```shell
cradle connect {{서버_명}}
```
#### 일반적인 도움말 표시:
```shell
cradle help
```
#### 특정 명령에 대한 도움말 표시:
```shell
cradle {{명령}} help
```
#### Cradle 명령 실행:
```shell
cradle {{명령}}
```
{% endraw %}{% raw %}
<h2 id="crontab">
  <a href="/ko/common/crontab.html">crontab</a> <a href="#crontab"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 현재 사용자의 시간 간격으로 cron작업이 실행되도록 스케줄.
> 작업 정의 형식: "(분) (시) (날짜) (달) (요일) 실행 할 명령".
> 더 많은 정보: <https://manned.org/crontab>.

#### 현재 사용자의 crontab파일 편집:
```shell
crontab -e
```
#### 특정 사용자에 대한 crontab파일 편집:
```shell
sudo crontab -e -u {{사용자}}
```
#### 현재 사용자의 기존 cron작업 목록 보기:
```shell
crontab -l
```
#### 현재 사용자의 모든 cron작업 제거:
```shell
crontab -r
```
#### 매일 10:00에 실행되는 샘플 작업 (* 은 모든 값을 의미 함):
```shell
0 10 * * * {{실행_할_명령}}
```
#### 4월 3일에 1분마다 실행되는 샘플 작업:
```shell
* * 3 Apr * {{실행_할_명령}}
```
#### 매주 금요일 02:30에 특정 스크립트를 실행하는 샘플 작업 :
```shell
30 2 * * Fri {{/script.sh/의/절대/경로}}
```
{% endraw %}{% raw %}
<h2 id="cryfs">
  <a href="/ko/common/cryfs.html">cryfs</a> <a href="#cryfs"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 클라우드용 암호화 파일 시스템.
> 더 많은 정보: <https://www.cryfs.org/>.

#### 암호화 된 파일 시스템 마운트. 초기화 마법사는 처음 실행될 때 시작:
```shell
cryfs {{cipher_dir/의/경로}} {{마운트_포인트/의/경로}}
```
#### 암호화 된 파일 시스템 마운트 해제:
```shell
cryfs-unmount {{마운트_포인트/의/경로}}
```
#### 10분 동안 활동이 없으면 자동으로 마운트 해제:
```shell
cryfs --unmount-idle {{10}} {{cipher_dir/의/경로}} {{마운트_포인트/의/경로}}
```
#### 지원되는 암호 목록 표시:
```shell
cryfs --show-ciphers
```
{% endraw %}{% raw %}
<h2 id="crystal">
  <a href="/ko/common/crystal.html">crystal</a> <a href="#crystal"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Crystal 소스 코드를 위한 관리도구.
> 더 많은 정보: <https://crystal-lang.org/reference/using_the_compiler>.

#### Crystal 파일 실행:
```shell
crystal {{경로/파일.cr}}
```
#### 단일 실행 파일로의 종속성 및 파일 컴파일:
```shell
crystal build {{경로/파일.cr}}
```
#### 언어 테스트를 위한 로컬 대화형 서버 시작:
```shell
crystal play
```
#### Cystal 응용 프로그램을 위한 프로젝트 디렉토리 생성:
```shell
crystal init app {{어플리케이션명}}
```
#### 도움말 옵션 표시:
```shell
crystal help
```
{% endraw %}{% raw %}
<h2 id="csc">
  <a href="/ko/common/csc.html">csc</a> <a href="#csc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 마이크로 소프트 사의 C# 컴파일러.
> 더 많은 정보: <https://docs.microsoft.com/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe>.

#### 하나 이상의 C# 파일을 CIL 실행파일로 컴파일:
```shell
csc {{경로/입력파일_a.cs}} {{경로/입력파일_b.cs}}
```
#### 출력 파일 이름 지정:
```shell
csc /out:{{경로/파일명}} {{경로/입력파일.cs}}
```
#### 실행 파일 대신 '.dll' 라이브러리로 컴파일:
```shell
csc /target:library {{경로/입력파일.cs}}
```
#### 다른 어셈블리 참조:
```shell
csc /reference:{{경로/라이브러리.dll}} {{경로/입력파일.cs}}
```
#### 리소스 포함:
```shell
csc /resource:{{경로/리소스파일}} {{경로/입력파일.cs}}
```
#### XML 문서 자동 생성:
```shell
csc /doc:{{경로/출력파일.xml}} {{경로/입력파일.cs}}
```
#### 아이콘 지정:
```shell
csc /win32icon:{{경로/아이콘.ico}} {{경로/입력파일.cs}}
```
#### 키 파일을 사용하여 결과 어셈블리의 이름 지정:
```shell
csc /keyfile:{{경로/키파일}} {{경로/입력파일.cs}}
```
{% endraw %}{% raw %}
<h2 id="csslint">
  <a href="/ko/common/csslint.html">csslint</a> <a href="#csslint"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> CSS 코드용 린터.
> 더 많은 정보: <https://github.com/CSSLint/csslint/wiki/Command-line-interface>.

#### 하나의 CSS 파일을 린트:
```shell
csslint {{파일.css}}
```
#### 여러개의 CSS 파일을 린트:
```shell
csslint {{파일1.css}} {{파일2.css}} {{파일3.css}}
```
#### 가능한 모든 스타일 규칙 나열:
```shell
csslint --list-rules
```
#### 특정 규칙을 오류로 지정 (종료 코드가 0이아닌 결과로 도출):
```shell
csslint --errors={{에러,보편적-선택자,임포트}} {{파일.css}}
```
#### 특정 규칙을 경고로 지정:
```shell
csslint --warnings={{박스-사이징,선택자-최대값,플롯}} {{파일.css}}
```
#### 완전히 무시할 특정 규칙을 지정:
```shell
csslint --ignore={{ids,규칙-수,속기}} {{파일.css}}
```
{% endraw %}{% raw %}
<h2 id="csvclean">
  <a href="/ko/common/csvclean.html">csvclean</a> <a href="#csvclean"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV 파일의 공통 문법 오류 찾기 및 정리.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvclean.html>.

#### CSV 파일 정리:
```shell
csvclean {{파일.csv}}
```
#### CSV 파일의 문법 오류 위치 나열:
```shell
csvclean -n {{파일.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvcut">
  <a href="/ko/common/csvcut.html">csvcut</a> <a href="#csvcut"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 유닉스의 `cut` 명령어와 같이 CSV 파일 필터링 및 잘라내기, tabular 데이터 보존을 위해. csvkit에 포함된 CSV 파일만 해당.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvcut.html>.

#### 모든 열의 인덱스 및 이름 출력:
```shell
csvcut -n {{데이터.csv}}
```
#### 첫번째 및 세번째 열 출력:
```shell
csvcut -c {{1,3}} {{데이터.csv}}
```
#### 네번째 열을 **제외한** 모든 열 출력:
```shell
csvcut -C {{4}} {{데이터.csv}}
```
#### "id" 및 "first name" (이 순서대로) 열 출력:
```shell
csvcut -c {{id,"first name"}} {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvformat">
  <a href="/ko/common/csvformat.html">csvformat</a> <a href="#csvformat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV 파일을 사용자 정의 출력으로 변환.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvformat.html>.

#### 탭으로 구분된 파일(TSV)로 변환:
```shell
csvformat -T {{데이터.csv}}
```
#### 구분자를 사용자 지정 문자로 변환:
```shell
csvformat -D "{{사용자_지정_문자}}" {{데이터.csv}}
```
#### 라인의 끝을 캐리지 리턴 (^M) + 라인 바꿈으로 변환:
```shell
csvformat -M "{{\r\n}}" {{데이터.csv}}
```
#### 인용문 사용 최소화:
```shell
csvformat -U 0 {{데이터.csv}}
```
#### 인용문 사용 최대화:
```shell
csvformat -U 1 {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvgrep">
  <a href="/ko/common/csvgrep.html">csvgrep</a> <a href="#csvgrep"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV행의 문자열 및 패턴 매칭 필터링.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvgrep.html>.

#### 1 열에 특정 문자열이 있는 행 찾기:
```shell
csvgrep -c {{1}} -m {{찾을_문자열}} {{데이터.csv}}
```
#### 3열 또는 4열에서 특정 정규식 패턴과 일치하는 행 찾기:
```shell
csvgrep -c {{3,4}} -r {{정규식_패턴}} {{데이터.csv}}
```
#### "이름" 열에서 "John Doe"가 포함되지 않는 행 찾기:
```shell
csvgrep -i -c {{이름}} -m "{{John Doe}}" {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvlook">
  <a href="/ko/common/csvlook.html">csvlook</a> <a href="#csvlook"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 콘솔에서 csvkit에 포함된 CSV 파일을 고정 너비 테이블로 렌더링.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvlook.html>.

#### CSV 파일 보기:
```shell
csvlook {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvpy">
  <a href="/ko/common/csvpy.html">csvpy</a> <a href="#csvpy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV 파일을 Python 쉘로 로드.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvpy.html>.

#### CSV 파일을 `CSVKitReader` 오브젝트에 로드:
```shell
csvpy {{데이터.csv}}
```
#### CSV 파일을 `CSVKitDictReader` 오브젝트에 로드:
```shell
csvpy --dict {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvsort">
  <a href="/ko/common/csvsort.html">csvsort</a> <a href="#csvsort"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV 파일을 정렬.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvsort.html>.

#### CSV 파일을 9열을 기준으로 정렬:
```shell
csvsort -c {{9}} {{데이터.csv}}
```
#### CSV 파일을 "이름" 열에 따라 내림차순으로 정렬:
```shell
csvsort -r -c {{이름}} {{데이터.csv}}
```
#### CSV 파일을 2열, 4열을 기준으로 정렬:
```shell
csvsort -c {{2,4}} {{데이터.csv}}
```
#### 데이터 형식과 관계 없이 CSV 파일 정렬:
```shell
csvsort --no-inference -c {{열}} {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="csvstat">
  <a href="/ko/common/csvstat.html">csvstat</a> <a href="#csvstat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> csvkit에 포함된 CSV 파일의 모든 열에 대한 설명 통계 출력.
> 더 많은 정보: <https://csvkit.readthedocs.io/en/latest/scripts/csvstat.html>.

#### 모든 열에 대한 정보 출력:
```shell
csvstat {{데이터.csv}}
```
#### 2열 , 4열의 모든 정보 출력:
```shell
csvstat -c {{2,4}} {{데이터.csv}}
```
#### 모든 열의 합계 출력:
```shell
csvstat --sum {{data.csv}}
```
#### 3열에 대한 최대값 길이 출력:
```shell
csvstat -c {{3}} --len {{데이터.csv}}
```
#### "이름" 열에 고유 값의 수 출력:
```shell
csvstat -c {{이름}} --unique {{데이터.csv}}
```
{% endraw %}{% raw %}
<h2 id="ctest">
  <a href="/ko/common/ctest.html">ctest</a> <a href="#ctest"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> CMake 테스트 드라이버 프로그램.
> 더 많은 정보: <https://gitlab.kitware.com/cmake/community/wikis/doc/ctest/Testing-With-CTest>.

#### CMake 프로젝트에 정의된 모든 테스트를 실행하며 , 한번에 4개의 작업을 병렬 실행:
```shell
ctest -j{{4}} --output-on-failure
```
#### 사용 가능한 테스트 목록 표시:
```shell
ctest -N
```
#### 이름을 기준으로 단일 테스트를 실행하거나 정규식을 기준으로 필터링:
```shell
ctest --output-on-failure -R '^{{테스트명}}$'
```
{% endraw %}{% raw %}
<h2 id="curl">
  <a href="/ko/common/curl.html">curl</a> <a href="#curl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 데이터를 서버에서 혹은 서버로 전송.
> HTTP,FTP 및 POP3를 포함한 대부분의 프로토콜 지원.
> 더 많은 정보: <https://curl.se>.

#### URL의 내용을 파일로 다운로드:
```shell
curl {{http://example.com}} --output {{파일명}}
```
#### URL에 표시된 파일 명으로 출력을 저장하고 파일을 다운로드:
```shell
curl --remote-name {{http://example.com/filename}}
```
#### [L]위치 리다이렉션 후 파일을 다운로드 하고, 자동으로 이전 파일 [C]전송(재시작):
```shell
curl --remote-name --location --continue-at - {{http://example.com/filename}}
```
#### 양식 인코딩 데이터 전송(`application/x-www-form-urlencoded`유형의 POST 요청):
```shell
curl --data {{'name=bob'}} {{http://example.com/form}}
```
#### 사용자 지정 HTTP 메서드를 사용하여 추가 헤더로 요청 전송:
```shell
curl --header {{'X-My-Header: 123'}} --request {{PUT}} {{http://example.com}}
```
#### 적절한 컨텐츠 유형 헤더를 지정하여 JSON 포멧으로 데이터 전송:
```shell
curl --data {{'{"name":"bob"}'}} --header {{'Content-Type: application/json'}} {{http://example.com/users/123}}
```
#### 서버 인증을 위한 사용자 이름 및 비밀번호 전달:
```shell
curl --user myusername:mypassword {{http://example.com}}
```
#### 리소스에 대한 클라이언트 인증서 및 키 전달, 인증서 유효성 검사 스킵:
```shell
curl --cert {{클라이언트.pem}} --key {{키.pem}} --insecure {{https://example.com}}
```
{% endraw %}{% raw %}
<h2 id="cut">
  <a href="/ko/common/cut.html">cut</a> <a href="#cut"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> stdin 혹은 파일에서 출력 필드를 자른다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/cut>.

#### stdin의 각 라인에 첫번째 16개의 문자를 자르기:
```shell
cut -c {{1-16}}
```
#### 지정된 파일의 각 라인의 첫번째 16개 문자를 자르기:
```shell
cut -c {{1-16}} {{파일}}
```
#### 3번째 문자 부터 각 라인의 끝까지 모든 문자를 자르기:
```shell
cut -c {{3-}}
```
#### `:` 을 필드 구분 기호로 사용하여 각 라인의 5번째 필드를 자르기(기본 구분 기호 : 탭):
```shell
cut -d'{{:}}' -f{{5}}
```
#### `;` 을 구분 기호로 사용하여 각 라인의 2번째와 10번째 필드를 자르기:
```shell
cut -d'{{;}}' -f{{2,10}}
```
#### 공백을 구분 기호로 사용하여 각 라인의 끝까지 필드 3을 자르기:
```shell
cut -d'{{ }}' -f{{3-}}
```
{% endraw %}{% raw %}
<h2 id="darkhttpd">
  <a href="/ko/common/darkhttpd.html">darkhttpd</a> <a href="#darkhttpd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Darkhttpd 웹 서버.
> 더 많은 정보: <https://unix4lyfe.org/darkhttpd>.

#### 지정된 문서 경로를 제공하는 서버 시작:
```shell
darkhttpd {{경로/문서}}
```
#### 지정된 포트에서 서버 시작(루트가 아닌 사용자로 시작되는 경우 8080포트가 기본값):
```shell
darkhttpd {{경로/문서}} --port {{포트번호}}
```
#### 지정된 IP 주소에서만 수신 (기본적으로 서버는 모든 인터페이스에서 수신):
```shell
darkhttpd {{경로/문서}} --addr {{ip주소}}
```
{% endraw %}{% raw %}
<h2 id="date">
  <a href="/ko/common/date.html">date</a> <a href="#date"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 시스템 날짜 설정 및 표시.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/date>.

#### 기본 로컬 형식을 사용하여 현재 날짜 표시:
```shell
date +"%c"
```
#### 현재 날짜를 UTC 및 ISO 8601 형식으로 표시:
```shell
date -u +"%Y-%m-%dT%H:%M:%SZ"
```
#### 현재 날짜를 Unix 타임스탬프로 표시 (Unix epoch 이후 몇 초):
```shell
date +%s
```
#### 기본 형식을 사용하여 특정 날짜 표시(Unix 타임스탬프로 표시):
```shell
date -d @1473305798
```
#### 특정 날짜를 Unix 타임스탬프 형식으로 변환:
```shell
date -d "{{2018-09-01 00:00}}" +%s --utc
```
{% endraw %}{% raw %}
<h2 id="deluge-console">
  <a href="/ko/common/deluge-console.html">deluge-console</a> <a href="#deluge-console"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Deluge BitTorrent 클라이언트를 위한 대화형 인터페이스.
> 더 많은 정보: <https://deluge-torrent.org/>.

#### 대화형 콘솔 인터페이스 시작:
```shell
deluge-console
```
#### Deluge 데몬 객체에 연결:
```shell
connect {{호스트이름}}:{{포트번호}}
```
#### 데몬에 토렌트 추가:
```shell
add {{url|magnet|파일/경로}}
```
#### 모든 토렌트에 대한 정보 표시:
```shell
info
```
#### 특정 토렌트에 대한 정보 표시:
```shell
info {{토렌트_아이디}}
```
#### 토렌트 일시정지:
```shell
pause {{토렌트_아이디}}
```
#### 토렌트 재시작:
```shell
resume {{토렌트_아이디}}
```
#### 데몬으로부터 토렌트 제거:
```shell
rm {{토렌트_아이디}}
```
{% endraw %}{% raw %}
<h2 id="deluge">
  <a href="/ko/common/deluge.html">deluge</a> <a href="#deluge"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> BitTorrent 클라이언트 명령어.
> 더 많은 정보: <https://deluge-torrent.org/>.

#### 토렌트 다운로드:
```shell
deluge {{url|마그넷|경로/파일명}}
```
#### 특정 구성 파일을 사용하여 토렌트를 다운로드하십시오:
```shell
deluge -c {{경로/구성_파일}} {{url|마그넷|경로/파일명}}
```
#### 토렌트를 다운로드하고 지정된 사용자 인터페이스로 시작:
```shell
deluge -u {{gtk|웹|콘솔}} {{url|마그넷|경로/파일명}}
```
#### 토렌트를 다운로드하고 로그를 파일로 출력:
```shell
deluge -l {{경로/로그_파일}} {{url|마그넷|경로/파일명}}
```
{% endraw %}{% raw %}
<h2 id="deluged">
  <a href="/ko/common/deluged.html">deluged</a> <a href="#deluged"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Deluge BitTorrent 클라이언트를 위한 데몬 프로세스.
> 더 많은 정보: <https://deluge-torrent.org/>.

#### Deluge 데몬 시작하기:
```shell
deluged
```
#### 특정 포트에서 Deluge 데몬 시작하기:
```shell
deluged -p {{포트번호}}
```
#### 특정 구성파일을 이용하여 Deluge 데몬 시작하기:
```shell
deluged -c {{경로/구성_파일명}}
```
#### Deluge 데몬을 시작하고 파일에 로그 출력하기:
```shell
deluged -l {{경로/로그_파일명}}
```
{% endraw %}{% raw %}
<h2 id="dep">
  <a href="/ko/common/dep.html">dep</a> <a href="#dep"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Go 프로젝트에서 종속성 관리를 위한 툴.
> 더 많은 정보: <https://golang.github.io/dep>.

#### 현재 디렉토리를 Go 프로젝트의 루트 디렉토리로 초기화:
```shell
dep init
```
#### 누락된 종속성 설치(Gopkg.toml 과 .go 파일들 스캔):
```shell
dep ensure
```
#### 프로젝트의 종속성의 상태 보고:
```shell
dep status
```
#### 프로젝트에 종속성 추가:
```shell
dep ensure -add {{패키지_url}}
```
#### 모든 종속성들의 잠긴 버전 업데이트:
```shell
dep ensure -update
```
{% endraw %}{% raw %}
<h2 id="detox">
  <a href="/ko/common/detox.html">detox</a> <a href="#detox"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 작업하기 쉽도록 파일 이름을 다시 설정합니다.
> 그것은 공백과 다른 중복된 밑줄 문자같은 골칫거리들을 제거한다.
> 더 많은 정보: <https://github.com/dharple/detox>.

#### 파일의 이름으로부터 공백과 다른 바람직하지 않은 문자들을 제거:
```shell
detox {{파일명}}
```
#### detox가 디렉토리 트리에서 모든 파일 이름을 재설정하는 방법 출력:
```shell
detox --dry-run -r {{디렉토리명}}
```
#### 디렉토리 트리에서 모든 파일들로부터 공백과 다른 바람직하지 않은 문자들을 제거:
```shell
detox -r {{디렉토리명}}
```
{% endraw %}{% raw %}
<h2 id="dexdump">
  <a href="/ko/common/dexdump.html">dexdump</a> <a href="#dexdump"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 안드로이드 DEX 파일들에 대한 정보 출력.
> 더 많은 정보: <https://manpages.ubuntu.com/manpages/latest/en/man1/dexdump.1.html>.

#### APK 파일으로부터 클래스들과 메서드들 추출:
```shell
dexdump {{경로/파일명.apk}}
```
#### APK 파일에 포함된 DEX 파일들의 헤더 정보 출력:
```shell
dexdump -f {{경로/파일명.apk}}
```
#### 실행가능한 섹션의 분해된 결과 출력:
```shell
dexdump -d {{경로/파일명.apk}}
```
#### 파일로 결과 출력:
```shell
dexdump -o {{경로/파일명}} {{경로/파일명.apk}}
```
{% endraw %}{% raw %}
<h2 id="dexter">
  <a href="/ko/common/dexter.html">dexter</a> <a href="#dexter"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> OpenId Connect를 사용하여 Kubectl 사용자를 인증하는 도구.
> 더 많은 정보: <https://github.com/gini/dexter>.

#### Google OIDC로 사용자 생성 및 인증:
```shell
dexter auth -i {{클라이언트_아이디}} -s {{클라이언트_secret}}
```
#### 기본 kube 구성파일 위치 재정의:
```shell
dexter auth -i {{클라이언트_아이디}} -s {{클라이언트_secret}} --kube-config {{예시/구성파일}}
```
{% endraw %}{% raw %}
<h2 id="df">
  <a href="/ko/common/df.html">df</a> <a href="#df"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일 시스템 디스크 공간 사용량에 대한 개요를 제공합니다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/df>.

#### 모든 파일 시스템들과 그들의 디스크 사용량 출력:
```shell
df
```
#### 사람이 읽을 수 있는 형태로 모든 파일시스템들과 그들의 디스크 사용량 출력:
```shell
df -h
```
#### 주어진 파일이나 디렉토리를 포함하는 파일 시스템과 그것의 디스크 사용량 출력:
```shell
df {{경로/파일_혹은_디렉토리명}}
```
#### 사용 가능한 inode들의 수에 대한 통계 출력:
```shell
df -i
```
{% endraw %}{% raw %}
<h2 id="dhclient">
  <a href="/ko/common/dhclient.html">dhclient</a> <a href="#dhclient"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> DHCP 클라이언트.
> 더 많은 정보: <https://manned.org/dhclient>.

#### 'eht0' 인터페이스의 IP 주소 얻기:
```shell
sudo dhclient {{eth0}}
```
#### 'eth0' 인터페이스의 IP 주소 해제하기:
```shell
sudo dhclient -r {{eth0}}
```
{% endraw %}{% raw %}
<h2 id="dhcpwn">
  <a href="/ko/common/dhcpwn.html">dhcpwn</a> <a href="#dhcpwn"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> DHCP IP 소진하는 공격을 테스트하고 로컬 DHCP 트래픽을 스니핑한다.
> 더 많은 정보: <https://github.com/mschwager/dhcpwn>.

#### 네트워크에 IP 요청들로 쇄도하기:
```shell
dhcpwn --interface {{네트워크_인터페이스}} flood --count {{요청들의_수}}
```
#### 로컬 DHCP 트래픽 스니핑하기:
```shell
dhcpwn --interface {{네트워크_인터페이스}} sniff
```
{% endraw %}{% raw %}
<h2 id="diff">
  <a href="/ko/common/diff.html">diff</a> <a href="#diff"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 파일들과 디렉토리들을 비교한다.

#### 파일들 비교하기 (`이전_파일명`을 `새_파일명`으로 바꾸는 변경점들 목록):
```shell
diff {{이전_파일명}} {{새_파일명}}
```
#### 공백들을 무시하고, 파일들 비교하기:
```shell
diff -w {{이전_파일명}} {{새_파일명}}
```
#### 차이점들을 나란히 보여주는 파일들 비교하기:
```shell
diff -y {{이전_파일명}} {{새_파일명}}
```
#### 통합된 포맷의 차이점들 표시하며 파일들 비교하기 (`git diff`에서 사용되는 것 같이):
```shell
diff -u {{이전_파일명}} {{새_파일명}}
```
#### 재귀적으로 디렉토리들 비교하기 (다른 파일/디렉토리들의 이름 및 파일에 대한 변경점 출력):
```shell
diff -r {{이전_디렉토리명}} {{새_디렉토리명}}
```
#### 디렉토리들을 비교하고, 서로 다른 파일이름만 표시하기:
```shell
diff -rq {{이전_디렉토리명}} {{새_디렉토리명}}
```
{% endraw %}{% raw %}
<h2 id="diffstat">
  <a href="/ko/common/diffstat.html">diffstat</a> <a href="#diffstat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> `diff` 명령어의 결과로부터 히스토그램을 생성한다.
> 더 많은 정보: <https://manned.org/diffstat>.

#### 히스토그램에서 변경점들 표시:
```shell
diff {{파일명1}} {{파일명2}} | diffstat
```
#### 삽입, 삭제 및 수정된 변경점들을 테이블로 표시:
```shell
diff {{파일명1}} {{파일명2}} | diffstat -t
```
{% endraw %}{% raw %}
<h2 id="dig">
  <a href="/ko/common/dig.html">dig</a> <a href="#dig"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> DNS 조회 유틸리티.
> 더 많은 정보: <https://manpages.debian.org/dnsutils/dig.1.html>.

#### 호스트이름과 관련된 IP 조회하기 (A records):
```shell
dig +short {{example.com}}
```
#### 주어진 도메인 이름과 관련된 메일 서버 조회하기 (MX record):
```shell
dig +short {{example.com}} MX
```
#### 주어진 도메인 이름에 대한 모든 유형의 레코드들 가져오기:
```shell
dig {{example.com}} ANY
```
#### 쿼리할 대체 DNS 서버를 지정하기:
```shell
dig @{{8.8.8.8}} {{example.com}}
```
#### IP 주소에서 역방향 DNS 조회하기 (PTR record):
```shell
dig -x {{8.8.8.8}}
```
#### 영역에 대해 권한있는 이름 서버들을 찾고 SOA 레코드들 표시하기:
```shell
dig +nssearch {{example.com}}
```
#### 반복적인 쿼리들을 수행하고 도메인 이름을 분석하기 위해 전체 추적 경로를 표시하기:
```shell
dig +trace {{example.com}}
```
{% endraw %}{% raw %}
<h2 id="dircolors">
  <a href="/ko/common/dircolors.html">dircolors</a> <a href="#dircolors"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> LS_COLOR 환경변수와 스타일 `ls`, `dir`, 등을 설정하기 위한 명령어들을 출력한다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/dircolors>.

#### 기본 색상을 사용하여 LS_COLOR를 설정하는 명령어들 출력하기:
```shell
dircolors
```
#### 파일로부터 색상을 사용하여 LS_COLOR를 설정하는 명령어들 출력하기:
```shell
dircolors {{파일명}}
```
#### Bourne 쉘에 관한 명령어들 출력:
```shell
dircolors --bourne-shell
```
#### C 쉘에 관한 명령어들 출력:
```shell
dircolors --c-shell
```
#### 파일 유형과 확장에 대한 기본 색상들 보기:
```shell
dircolors --print-data
```
{% endraw %}{% raw %}
<h2 id="dirname">
  <a href="/ko/common/dirname.html">dirname</a> <a href="#dirname"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 주어진 파일 혹은 디렉토리 경로의 부모 디렉토리를 계산한다.
> 더 많은 정보: <https://www.gnu.org/software/coreutils/dirname>.

#### 주어진 경로의 부모 디렉토리 계산:
```shell
dirname {{경로/파일_또는_디렉토리}}
```
#### 복수 경로의 부모 디렉토리 계산:
```shell
dirname {{경로/a_파일}} {{경로/b_디렉토리}}
```
#### 개행 대신 NUL 문자로 출력을 구분하기 (`xargs`와 결합 시 유용함):
```shell
dirname --zero {{경로/a_디렉토리}} {{경로/b_파일}}
```
{% endraw %}{% raw %}
<h2 id="dirs">
  <a href="/ko/common/dirs.html">dirs</a> <a href="#dirs"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 디렉토리 스택을 표시하거나 조작한다.
> 디렉토리 스택은 `pushd`과 `popd` 명령어로 조작할 수 있는 최근 방문한 디렉토리의 목록이다.
> 더 많은 정보: <https://www.gnu.org/software/bash/manual/bash.html#Directory-Stack-Builtins>.

#### 각각의 엔트리 사이에서 공백으로 디렉토리 스택을 표시하기:
```shell
dirs
```
#### 하나의 엔트리에 하나의 라인으로 디렉토리 스택 표시하기:
```shell
dirs -p
```
#### 0부터 시작하는 디렉토리 스택에 n번째 항만 표시하기:
```shell
dirs +{{N}}
```
#### 디렉토리 스택 초기화하기:
```shell
dirs -c
```
{% endraw %}{% raw %}
<h2 id="dive">
  <a href="/ko/common/dive.html">dive</a> <a href="#dive"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커 이미지, 레이어 컨텐츠, 그리고 축소 방법 탐색을 위한 도구.
> 더 많은 정보: <https://github.com/wagoodman/dive>.

#### 도커 이미지 분석하기:
```shell
dive {{이미지_태그}}
```
#### 이미지 구축과 분석 시작하기:
```shell
dive build -t {{몇_가지_태그}}
```
{% endraw %}{% raw %}
<h2 id="docker-compose">
  <a href="/ko/common/docker-compose.html">docker-compose</a> <a href="#docker-compose"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 다중 도커 응용 프로그램 실행 및 관리합니다.
> 더 많은 정보: <https://docs.docker.com/compose/reference/overview/>.

#### 실행 중인 모든 컨테이너들 목록:
```shell
docker-compose ps
```
#### 현재 디렉토리로로부터 `docker-compose.yml` 파일을 사용하여 백그라운드에서 모든 컨테이너들을 생성하고 실행하기:
```shell
docker-compose up -d
```
#### 모든 컨테이너들을 실행하고, 필요 시 재조립:
```shell
docker-compose up --build
```
#### 대체 구성 파일을 사용하여 모든 컨테이너들 실행하기:
```shell
docker-compose --file {{경로/파일명}} up
```
#### 실행중인 모든 컨테이너들 중지하기:
```shell
docker-compose stop
```
#### 모든 컨테이너들, 네트워크, 이미지, 그리고 볼륨을 중지하고 제거하기:
```shell
docker-compose down --rmi all --volumes
```
#### 모든 컨테이너들에 대한 로그들 팔로우:
```shell
docker-compose logs --follow
```
{% endraw %}{% raw %}
<h2 id="docker-container">
  <a href="/ko/common/docker-container.html">docker container</a> <a href="#docker-container"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커 컨테이너들을 관리한다.
> 더 많은 정보: <https://docs.docker.com/engine/reference/commandline/container/>.

#### 현재 실행중인 도커 컨테이너들의 목록:
```shell
docker container ls
```
#### 하나 혹은 더 많은 정지된 컨테이너들 실행하기:
```shell
docker container start {{컨테이너1_이름}} {{컨테이너2_이름}}
```
#### 하나 혹은 더 많은 실행중인 컨테이너들 종료하기:
```shell
docker container kill {{컨테이너_이름}}
```
#### 하나 혹은 더 많은 실행중인 컨테이너들 중지하기:
```shell
docker container stop {{컨테이너_이름}}
```
#### 하나 혹은 더 많은 컨테이너들 내에서 모든 프로세스들 일시중지하기:
```shell
docker container pause {{컨테이너_이름}}
```
#### 하나 혹은 더 많은 컨테이너들에 대한 상세 정보 표시하기:
```shell
docker container inspect {{컨테이너_이름}}
```
#### 컨테이너의 파일 시스템을 tar 아카이브로 내보내기:
```shell
docker container export {{컨테이너_이름}}
```
#### 컨테이너의 변경점들로부터 새 이미지 생성하기:
```shell
docker container commit {{컨테이너_이름}}
```
{% endraw %}{% raw %}
<h2 id="docker-images">
  <a href="/ko/common/docker-images.html">docker images</a> <a href="#docker-images"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커 이미지를 관리한다.
> 더 많은 정보: <https://docs.docker.com/engine/reference/commandline/images/>.

#### 모든 도커 이미지 목록보기:
```shell
docker images
```
#### 중간자를 포함한 모든 도커 이미지 목록보기:
```shell
docker images -a
```
#### 잔잔한 모드로 결과 목록보기(수로 표현된 ID들만):
```shell
docker images -q
```
#### 어떠한 컨테이너에서도 사용되지 않은 모든 도커 이미지 목록보기:
```shell
docker images --filter dangling=true
```
{% endraw %}{% raw %}
<h2 id="docker-logs">
  <a href="/ko/common/docker-logs.html">docker logs</a> <a href="#docker-logs"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 컨테이너 로그들을 출력한다.
> 더 많은 정보: <https://docs.docker.com/engine/reference/commandline/logs>.

#### 컨테이너로부터 로그들을 출력하기:
```shell
docker logs {{컨테이너_이름}}
```
#### 로그들을 출력하고 추적하기:
```shell
docker logs -f {{컨테이너_이름}}
```
#### 최근 5줄만 출력하기:
```shell
docker logs {{컨테이너_이름}} --tail {{5}}
```
#### 로그들을 출력하고 타임스태프 추가하기:
```shell
docker logs -t {{컨테이너_이름}}
```
#### 특정 시점의 컨테이너 실행 시점으로부터 로그 출력하기 (예시. 23m, 10s, 2013-01-02T13:23:37):
```shell
docker logs {{컨테이너_이름}} --until {{시간}}
```
{% endraw %}{% raw %}
<h2 id="docker-machine">
  <a href="/ko/common/docker-machine.html">docker-machine</a> <a href="#docker-machine"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커를 실행하는 머신들을 생성하고 관리한다.
> 더 많은 정보: <https://docs.docker.com/machine/reference/>.

#### 현재 실행중인 도커 머신들 목록보기:
```shell
docker-machine ls
```
#### 특정 이름으로 새로운 도커 머신 생성하기:
```shell
docker-machine create {{이름}}
```
#### 머신의 상태 가져오기:
```shell
docker-machine status {{이름}}
```
#### 머신 시작하기:
```shell
docker-machine start {{이름}}
```
#### 머신 중지하기:
```shell
docker-machine stop {{이름}}
```
#### 머신에 대한 정보 검사하기:
```shell
docker-machine inspect {{이름}}
```
{% endraw %}{% raw %}
<h2 id="docker">
  <a href="/ko/common/docker.html">docker</a> <a href="#docker"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커 컨테이너들과 이미지들을 관리한다.
> 더 많은 정보: <https://docs.docker.com/engine/reference/commandline/cli/>.

#### 현재 실행중인 도커 컨테이너들 목록보기:
```shell
docker ps
```
#### 모든 도커 컨테이너들(실행중이고 중지된) 목록 보기:
```shell
docker ps -a
```
#### 사용자 정의 이름으로 이미지로부터 컨테이너 실행:
```shell
docker run --name {{컨테이너_이름}} {{이미지}}
```
#### 기존 컨테이너 실행 또는 중지하기:
```shell
docker {{실행|중지}} {{컨테이너_이름}}
```
#### 도커 레지스트리로부터 이미지 가져오기:
```shell
docker pull {{이미지}}
```
#### 이미 실행중인 컨테이너 내부에서 쉘 열기:
```shell
docker exec -it {{컨테이너_이름}} {{쉘}}
```
#### 중지된 컨테이너 제거하기:
```shell
docker rm {{컨테이너_이름}}
```
#### 컨테이너 로그를 가져오고 팔로우하기:
```shell
docker logs -f {{컨테이너_이름}}
```
{% endraw %}{% raw %}
<h2 id="dokku">
  <a href="/ko/common/dokku.html">dokku</a> <a href="#dokku"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 도커로 구동되는 미니-Heroku (PaaS).
> 하나의 `git-push` 명령을 사용하여 여러 언어로 다른 앱을 쉽게 배포 할수 있습니다.
> 더 많은 정보: <https://github.com/dokku/dokku>.

#### 실행중인 앱들 목록보기:
```shell
dokku apps
```
#### 앱 생성하기:
```shell
dokku apps:create {{앱_이름}}
```
#### 앱 제거하기:
```shell
dokku apps:destroy {{앱_이름}}
```
#### 플러그인 설치하기:
```shell
dokku plugin:install {{전체_폴더_경로}}
```
#### 앱에 데이터베이스 연결하기:
```shell
dokku {{db}}:link {{데이터베이스_이름}} {{앱_이름}}
```
{% endraw %}{% raw %}
<h2 id="dot">
  <a href="/ko/common/dot.html">dot</a> <a href="#dot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 방향 그래프의 레이어 도면을 생성하는 명령 도구입니다.
> 더 많은 정보: <https://www.graphviz.org/pdf/dotguide.pdf>.

#### 입력 파일 이름과 선택한 포맷을 기반으로 이미지 파일을 랜더링하고 출력파일 이름 결정하기:
```shell
dot -Tpng -O {{경로/파일명.dot}}
```
#### DOT 파일로부터 SVG 생성하기:
```shell
dot -Tsvg -o {{경로/출력_파일명.svg}} {{경로/파일명.dot}}
```
{% endraw %}{% raw %}
<h2 id="dotnet">
  <a href="/ko/common/dotnet.html">dotnet</a> <a href="#dotnet"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> .NET Core를 위한 크로스 플랫폼 .NET 명령어 도구.
> 더 많은 정보: <https://docs.microsoft.com/dotnet/core/tools>.

#### 새 .NET 프로젝트 초기화하기:
```shell
dotnet new {{짧은_템플릿_이름}}
```
#### nuget 패키지들 복구하기:
```shell
dotnet restore
```
#### 현재 디렉토리에서 .NET 프로젝트를 빌드하고 실행하기:
```shell
dotnet run
```
#### 패키지화 된 dotnet 어플리케이션을 실행하기(런타임만 필요하며, 나머지 명령어들은 .NET Core SDK 설치가 필요):
```shell
dotnet {{경로/어플리케이션.dll}}
```
{% endraw %}{% raw %}
<h2 id="tldr">
  <a href="/ko/common/tldr.html">tldr</a> <a href="#tldr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 간단한 매뉴얼 페이지.
> 더 많은 정보: <https://tldr.sh>.

#### 명령어 형식적 사용법 가져오기 (힌트 : 이걸 사용하는 방법입니다!):
```shell
tldr {{명령어}}
```
#### Linux에서 tar에 대한 tldr 문서 표시하기:
```shell
tldr -p {{linux}} {{tar}}
```
#### git 부속명령에 대한 도움말 가져오기:
```shell
tldr {{git checkout}}
```
{% endraw %}