---
layout: default
title: "ZH"
date: 2021-06-25 18:12:13 +02:00
---
## Table of contents
* <a href="#android">Android</a>
  * <a href="#am">am</a>
  * <a href="#bugreport">bugreport</a>
  * <a href="#cmd">cmd</a>
  * <a href="#dalvikvm">dalvikvm</a>
  * <a href="#dumpsys">dumpsys</a>
  * <a href="#getprop">getprop</a>
  * <a href="#input">input</a>
  * <a href="#logcat">logcat</a>
  * <a href="#pm">pm</a>
  * <a href="#settings">settings</a>
  * <a href="#wm">wm</a>

* <a href="#common">Common</a>
  * <a href="#7z">7z</a>
  * <a href="#7za">7za</a>
  * <a href="#7zr">7zr</a>
  * <a href="#adguardhome">AdGuardHome</a>
  * <a href="#aapt">aapt</a>
  * <a href="#ab">ab</a>
  * <a href="#abduco">abduco</a>
  * <a href="#ack">ack</a>
  * <a href="#act">act</a>
  * <a href="#adb">adb</a>
  * <a href="#adb-install">adb install</a>
  * <a href="#adb-reverse">adb reverse</a>
  * <a href="#adb-shell">adb shell</a>
  * <a href="#ag">ag</a>
  * <a href="#airpaste">airpaste</a>
  * <a href="#alacritty">alacritty</a>
  * <a href="#alias">alias</a>
  * <a href="#androguard">androguard</a>
  * <a href="#ansible">ansible</a>
  * <a href="#ansible-galaxy">ansible-galaxy</a>
  * <a href="#ansible-playbook">ansible-playbook</a>
  * <a href="#ansiweather">ansiweather</a>
  * <a href="#apg">apg</a>
  * <a href="#apktool">apktool</a>
  * <a href="#apm">apm</a>
  * <a href="#apropos">apropos</a>
  * <a href="#ar">ar</a>
  * <a href="#arch">arch</a>
  * <a href="#aria2">aria2</a>
  * <a href="#aria2c">aria2c</a>
  * <a href="#arp">arp</a>
  * <a href="#asar">asar</a>
  * <a href="#asciinema">asciinema</a>
  * <a href="#asdf">asdf</a>
  * <a href="#atom">atom</a>
  * <a href="#autoflake">autoflake</a>
  * <a href="#autojump">autojump</a>
  * <a href="#axel">axel</a>
  * <a href="#babel">babel</a>
  * <a href="#banner">banner</a>
  * <a href="#base32">base32</a>
  * <a href="#base64">base64</a>
  * <a href="#basename">basename</a>
  * <a href="#bash">bash</a>
  * <a href="#bashmarks">bashmarks</a>
  * <a href="#bat">bat</a>
  * <a href="#behat">behat</a>
  * <a href="#bg">bg</a>
  * <a href="#bmaptool">bmaptool</a>
  * <a href="#bower">bower</a>
  * <a href="#browser-sync">browser-sync</a>
  * <a href="#btm">btm</a>
  * <a href="#buku">buku</a>
  * <a href="#carbon-now">carbon-now</a>
  * <a href="#case">case</a>
  * <a href="#cat">cat</a>
  * <a href="#cd">cd</a>
  * <a href="#clear">clear</a>
  * <a href="#code">code</a>
  * <a href="#command">command</a>
  * <a href="#cp">cp</a>
  * <a href="#curl">curl</a>
  * <a href="#echo">echo</a>
  * <a href="#etcd">etcd</a>
  * <a href="#exit">exit</a>
  * <a href="#gh-gist">gh gist</a>
  * <a href="#gh-repo">gh repo</a>
  * <a href="#gpg">gpg</a>
  * <a href="#gpg-zip">gpg-zip</a>
  * <a href="#gpg2">gpg2</a>
  * <a href="#gpgv">gpgv</a>
  * <a href="#gunicorn">gunicorn</a>
  * <a href="#heroku">heroku</a>
  * <a href="#hexo">hexo</a>
  * <a href="#jar">jar</a>
  * <a href="#jarsigner">jarsigner</a>
  * <a href="#java">java</a>
  * <a href="#javac">javac</a>
  * <a href="#javadoc">javadoc</a>
  * <a href="#jps">jps</a>
  * <a href="#make">make</a>
  * <a href="#matlab">matlab</a>
  * <a href="#md5sum">md5sum</a>
  * <a href="#mongod">mongod</a>
  * <a href="#mpv">mpv</a>
  * <a href="#mvn">mvn</a>
  * <a href="#ninja">ninja</a>
  * <a href="#nmap">nmap</a>
  * <a href="#node">node</a>
  * <a href="#rsync">rsync</a>
  * <a href="#runit">runit</a>
  * <a href="#runsv">runsv</a>
  * <a href="#runsvchdir">runsvchdir</a>
  * <a href="#runsvdir">runsvdir</a>
  * <a href="#rustfmt">rustfmt</a>
  * <a href="#shasum">shasum</a>
  * <a href="#stty">stty</a>
  * <a href="#sv">sv</a>
  * <a href="#tldr">tldr</a>
  * <a href="#uname">uname</a>
  * <a href="#units">units</a>
  * <a href="#view">view</a>
  * <a href="#vim">vim</a>
  * <a href="#virtualenv">virtualenv</a>
  * <a href="#vlc">vlc</a>
  * <a href="#vue-cli">vue-cli</a>
  * <a href="#w">w</a>
  * <a href="#wget">wget</a>
  * <a href="#where">where</a>
  * <a href="#which">which</a>
  * <a href="#write">write</a>
  * <a href="#yarn">yarn</a>
  * <a href="#yarn-why">yarn-why</a>
  * <a href="#z">z</a>
  * <a href="#zsh">zsh</a>
  * <a href="#zstd">zstd</a>

* <a href="#linux">Linux</a>
  * <a href="#a2disconf">a2disconf</a>
  * <a href="#a2dismod">a2dismod</a>
  * <a href="#a2dissite">a2dissite</a>
  * <a href="#a2enconf">a2enconf</a>
  * <a href="#a2enmod">a2enmod</a>
  * <a href="#a2ensite">a2ensite</a>
  * <a href="#a2query">a2query</a>
  * <a href="#ac">ac</a>
  * <a href="#acpi">acpi</a>
  * <a href="#add-apt-repository">add-apt-repository</a>
  * <a href="#addpart">addpart</a>
  * <a href="#addr2line">addr2line</a>
  * <a href="#adduser">adduser</a>
  * <a href="#alpine">alpine</a>
  * <a href="#amixer">amixer</a>
  * <a href="#apache2ctl">apache2ctl</a>
  * <a href="#apk">apk</a>
  * <a href="#aplay">aplay</a>
  * <a href="#apport-bug">apport-bug</a>
  * <a href="#apt">apt</a>
  * <a href="#apt-add-repository">apt-add-repository</a>
  * <a href="#apt-cache">apt-cache</a>
  * <a href="#apt-file">apt-file</a>
  * <a href="#apt-get">apt-get</a>
  * <a href="#apt-key">apt-key</a>
  * <a href="#apt-mark">apt-mark</a>
  * <a href="#aptitude">aptitude</a>
  * <a href="#arch">arch</a>
  * <a href="#archey">archey</a>
  * <a href="#archlinux-java">archlinux-java</a>
  * <a href="#arecored">arecored</a>
  * <a href="#arithmetic">arithmetic</a>
  * <a href="#ark">ark</a>
  * <a href="#arp-scan">arp-scan</a>
  * <a href="#as">as</a>
  * <a href="#ascii">ascii</a>
  * <a href="#asciiart">asciiart</a>
  * <a href="#aspell">aspell</a>
  * <a href="#asterisk">asterisk</a>
  * <a href="#at">at</a>
  * <a href="#auracle">auracle</a>
  * <a href="#authconfig">authconfig</a>
  * <a href="#autorandr">autorandr</a>
  * <a href="#avahi-browse">avahi-browse</a>
  * <a href="#boltctl">boltctl</a>
  * <a href="#btrfs">btrfs</a>
  * <a href="#btrfs-device">btrfs device</a>
  * <a href="#btrfs-filesystem">btrfs filesystem</a>
  * <a href="#btrfs-scrub">btrfs scrub</a>
  * <a href="#btrfs-subvolume">btrfs subvolume</a>
  * <a href="#cpuid">cpuid</a>
  * <a href="#debootstrap">debootstrap</a>
  * <a href="#debuild">debuild</a>
  * <a href="#dmenu">dmenu</a>
  * <a href="#dmesg">dmesg</a>
  * <a href="#dos2unix">dos2unix</a>
  * <a href="#fc-cache">fc-cache</a>
  * <a href="#fc-list">fc-list</a>
  * <a href="#flameshot">flameshot</a>
  * <a href="#flatpak">flatpak</a>
  * <a href="#i3">i3</a>
  * <a href="#iptables">iptables</a>
  * <a href="#konsole">konsole</a>
  * <a href="#logsave">logsave</a>
  * <a href="#mac2unix">mac2unix</a>
  * <a href="#pacman">pacman</a>
  * <a href="#poweroff">poweroff</a>
  * <a href="#reboot">reboot</a>
  * <a href="#unix2dos">unix2dos</a>
  * <a href="#unix2mac">unix2mac</a>
  * <a href="#yaourt">yaourt</a>
  * <a href="#yay">yay</a>
  * <a href="#zypper">zypper</a>

* <a href="#osx">Osx</a>
  * <a href="#getfileinfo">GetFileInfo</a>
  * <a href="#afinfo">afinfo</a>
  * <a href="#airport">airport</a>
  * <a href="#apachectl">apachectl</a>
  * <a href="#archey">archey</a>
  * <a href="#as">as</a>
  * <a href="#asr">asr</a>
  * <a href="#base64">base64</a>
  * <a href="#brew">brew</a>
  * <a href="#brew-cask">brew cask</a>
  * <a href="#brew-mas">brew mas</a>
  * <a href="#brightness">brightness</a>
  * <a href="#caffeinate">caffeinate</a>
  * <a href="#cal">cal</a>
  * <a href="#carthage">carthage</a>
  * <a href="#chflags">chflags</a>
  * <a href="#codesign">codesign</a>
  * <a href="#compgen">compgen</a>
  * <a href="#date">date</a>
  * <a href="#dd">dd</a>
  * <a href="#defaults">defaults</a>
  * <a href="#diskutil">diskutil</a>
  * <a href="#ditto">ditto</a>
  * <a href="#dmesg">dmesg</a>
  * <a href="#drutil">drutil</a>
  * <a href="#du">du</a>
  * <a href="#duti">duti</a>
  * <a href="#eval">eval</a>
  * <a href="#export">export</a>
  * <a href="#fc">fc</a>
  * <a href="#feh">feh</a>
  * <a href="#file">file</a>
  * <a href="#fsck">fsck</a>
  * <a href="#head">head</a>
  * <a href="#hexdump">hexdump</a>
  * <a href="#hostname">hostname</a>
  * <a href="#imgcat">imgcat</a>
  * <a href="#launchctl">launchctl</a>
  * <a href="#lldb">lldb</a>
  * <a href="#locate">locate</a>
  * <a href="#logger">logger</a>
  * <a href="#look">look</a>
  * <a href="#m">m</a>
  * <a href="#md5">md5</a>
  * <a href="#mdfind">mdfind</a>
  * <a href="#mdutil">mdutil</a>
  * <a href="#mkfile">mkfile</a>
  * <a href="#n">n</a>
  * <a href="#netstat">netstat</a>
  * <a href="#networksetup">networksetup</a>
  * <a href="#oathtool">oathtool</a>
  * <a href="#open">open</a>
  * <a href="#opensnoop">opensnoop</a>
  * <a href="#osascript">osascript</a>
  * <a href="#pbcopy">pbcopy</a>
  * <a href="#pbpaste">pbpaste</a>
  * <a href="#pdfgrep">pdfgrep</a>
  * <a href="#ping">ping</a>
  * <a href="#pmset">pmset</a>
  * <a href="#pod">pod</a>
  * <a href="#popd">popd</a>
  * <a href="#port">port</a>
  * <a href="#pushd">pushd</a>
  * <a href="#pwgen">pwgen</a>
  * <a href="#qlmanage">qlmanage</a>
  * <a href="#reboot">reboot</a>
  * <a href="#route">route</a>
  * <a href="#rubocop">rubocop</a>
  * <a href="#say">say</a>
  * <a href="#scutil">scutil</a>
  * <a href="#sed">sed</a>
  * <a href="#shuf">shuf</a>
  * <a href="#shutdown">shutdown</a>
  * <a href="#sips">sips</a>
  * <a href="#softwareupdate">softwareupdate</a>
  * <a href="#split">split</a>
  * <a href="#ssh-add">ssh-add</a>
  * <a href="#sshuttle">sshuttle</a>
  * <a href="#stat">stat</a>
  * <a href="#sw_vers">sw_vers</a>
  * <a href="#sysctl">sysctl</a>
  * <a href="#system_profiler">system_profiler</a>
  * <a href="#systemsetup">systemsetup</a>
  * <a href="#textutil">textutil</a>
  * <a href="#top">top</a>
  * <a href="#trap">trap</a>
  * <a href="#tree">tree</a>
  * <a href="#uname">uname</a>
  * <a href="#w">w</a>
  * <a href="#wacaw">wacaw</a>
  * <a href="#whereis">whereis</a>
  * <a href="#wifi-password">wifi-password</a>
  * <a href="#xattr">xattr</a>
  * <a href="#xcodebuild">xcodebuild</a>
  * <a href="#xctool">xctool</a>
  * <a href="#xed">xed</a>
  * <a href="#xsltproc">xsltproc</a>
  * <a href="#yank">yank</a>

* <a href="#sunos">Sunos</a>
  * <a href="#dmesg">dmesg</a>

* <a href="#windows">Windows</a>
  * <a href="#assoc">assoc</a>
  * <a href="#attrib">attrib</a>
  * <a href="#choco">choco</a>
  * <a href="#choco-feature">choco feature</a>
  * <a href="#choco-info">choco info</a>
  * <a href="#choco-install">choco install</a>
  * <a href="#choco-list">choco list</a>
  * <a href="#choco-new">choco new</a>
  * <a href="#choco-outdated">choco outdated</a>
  * <a href="#choco-pack">choco pack</a>
  * <a href="#choco-pin">choco pin</a>
  * <a href="#choco-search">choco search</a>
  * <a href="#choco-source">choco source</a>
  * <a href="#choco-uninstall">choco uninstall</a>
  * <a href="#choco-upgrade">choco upgrade</a>
  * <a href="#cipher">cipher</a>
  * <a href="#clip">clip</a>
  * <a href="#cls">cls</a>
  * <a href="#cmd">cmd</a>
  * <a href="#cmstp">cmstp</a>
  * <a href="#color">color</a>
  * <a href="#comp">comp</a>
  * <a href="#del">del</a>
  * <a href="#dir">dir</a>
  * <a href="#doskey">doskey</a>
  * <a href="#driverquery">driverquery</a>
  * <a href="#eventcreate">eventcreate</a>
  * <a href="#exit">exit</a>
  * <a href="#expand">expand</a>
  * <a href="#explorer">explorer</a>
  * <a href="#fc">fc</a>
  * <a href="#find">find</a>
  * <a href="#findstr">findstr</a>
  * <a href="#finger">finger</a>
  * <a href="#fondue">fondue</a>
  * <a href="#forfiles">forfiles</a>
  * <a href="#ftp">ftp</a>
  * <a href="#ftype">ftype</a>
  * <a href="#getmac">getmac</a>
  * <a href="#ipconfig">ipconfig</a>
  * <a href="#iscc">iscc</a>
  * <a href="#logoff">logoff</a>
  * <a href="#mkdir">mkdir</a>
  * <a href="#mklink">mklink</a>
  * <a href="#more">more</a>
  * <a href="#msg">msg</a>
  * <a href="#path">path</a>
  * <a href="#pathping">pathping</a>
  * <a href="#popd">popd</a>
  * <a href="#powershell">powershell</a>
  * <a href="#print">print</a>
  * <a href="#pushd">pushd</a>
  * <a href="#pwlauncher">pwlauncher</a>
  * <a href="#rdpsign">rdpsign</a>
  * <a href="#reg">reg</a>
  * <a href="#reg-add">reg add</a>
  * <a href="#reg-compare">reg compare</a>
  * <a href="#reg-copy">reg copy</a>
  * <a href="#reg-delete">reg delete</a>
  * <a href="#reg-export">reg export</a>
  * <a href="#reg-flags">reg flags</a>
  * <a href="#reg-import">reg import</a>
  * <a href="#reg-load">reg load</a>
  * <a href="#reg-query">reg query</a>
  * <a href="#reg-restore">reg restore</a>
  * <a href="#reg-save">reg save</a>
  * <a href="#reg-unload">reg unload</a>
  * <a href="#repair-bde">repair-bde</a>
  * <a href="#rmdir">rmdir</a>
  * <a href="#scoop">scoop</a>
  * <a href="#scoop-bucket">scoop bucket</a>
  * <a href="#set">set</a>
  * <a href="#sfc">sfc</a>
  * <a href="#shutdown">shutdown</a>
  * <a href="#subst">subst</a>
  * <a href="#systeminfo">systeminfo</a>
  * <a href="#takeown">takeown</a>
  * <a href="#taskkill">taskkill</a>
  * <a href="#tasklist">tasklist</a>
  * <a href="#title">title</a>
  * <a href="#tree">tree</a>
  * <a href="#type">type</a>
  * <a href="#tzutil">tzutil</a>
  * <a href="#ver">ver</a>
  * <a href="#vol">vol</a>
  * <a href="#where">where</a>
  * <a href="#whoami">whoami</a>
  * <a href="#winget">winget</a>
  * <a href="#wsl">wsl</a>
  * <a href="#xcopy">xcopy</a>


# Linux
{% raw %}
<h2 id="a2disconf">
  <a href="/zh/linux/a2disconf.html">a2disconf</a> <a href="#a2disconf"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上禁用 Apache 配置文件.
> 更多信息: <https://manpages.debian.org/latest/apache2/a2disconf.8.html>.

#### 禁用配置文件:
```shell
sudo a2disconf {{配置文件}}
```
#### 不显示信息性消息:
```shell
sudo a2disconf --quiet {{配置文件}}
```
{% endraw %}{% raw %}
<h2 id="a2dismod">
  <a href="/zh/linux/a2dismod.html">a2dismod</a> <a href="#a2dismod"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上禁用 Apache 模块。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2dismod.8.html>.

#### 禁用模块：
```shell
sudo a2dismod {{模块路径}}
```
#### 不显示信息性消息：
```shell
sudo a2dismod --quiet {{模块路径}}
```
{% endraw %}{% raw %}
<h2 id="a2dissite">
  <a href="/zh/linux/a2dissite.html">a2dissite</a> <a href="#a2dissite"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上禁用 Apache 虚拟主机。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2dissite.8.html>.

#### 禁用虚拟主机：
```shell
sudo a2dissite {{虚拟主机名}}
```
#### 不显示信息性消息：
```shell
sudo a2dissite --quiet {{虚拟主机名}}
```
{% endraw %}{% raw %}
<h2 id="a2enconf">
  <a href="/zh/linux/a2enconf.html">a2enconf</a> <a href="#a2enconf"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上启用 Apache 配置文件。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2enconf.8.html>.

#### 启用配置文件：
```shell
sudo a2enconf {{配置文件}}
```
#### 不显示信息性消息：
```shell
sudo a2enconf --quiet {{配置文件}}
```
{% endraw %}{% raw %}
<h2 id="a2enmod">
  <a href="/zh/linux/a2enmod.html">a2enmod</a> <a href="#a2enmod"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上启用 Apache 模块。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2enmod.8.html>.

#### 启用模块：
```shell
sudo a2enmod {{模块名}}
```
#### 不显示信息性消息：
```shell
sudo a2enmod --quiet {{模块名}}
```
{% endraw %}{% raw %}
<h2 id="a2ensite">
  <a href="/zh/linux/a2ensite.html">a2ensite</a> <a href="#a2ensite"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上启用 Apache 虚拟主机。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2ensite.8.html>.

#### 启用虚拟主机：
```shell
sudo a2ensite {{虚拟主机名}}
```
#### 不显示信息性消息：
```shell
sudo a2ensite --quiet {{虚拟主机名}}
```
{% endraw %}{% raw %}
<h2 id="a2query">
  <a href="/zh/linux/a2query.html">a2query</a> <a href="#a2query"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在基于 Debian 的操作系统上查看 Apache 运行配置。
> 更多信息：<https://manpages.debian.org/latest/apache2/a2query.1.html>.

#### 列出启用的 Apache 模块：
```shell
sudo a2query -m
```
#### 查看某个模块是否已安装：
```shell
sudo a2query -m {{模块名}}
```
#### 列出已启用的虚拟主机：
```shell
sudo a2query -s
```
#### 显示已启用的多进程模块：
```shell
sudo a2query -M
```
#### 显示 Apache 版本：
```shell
sudo a2query -v
```
{% endraw %}{% raw %}
<h2 id="ac">
  <a href="/zh/linux/ac.html">ac</a> <a href="#ac"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打印用户连接时长数据。

#### 以小时为单位打印当前用户连接时间：
```shell
ac
```
#### 以小时为单位打印所有用户连接时间：
```shell
ac --individual-totals
```
#### 以小时为单位打印特定用户连接时间：
```shell
ac --individual-totals {{用户名}}
```
#### 以小时为单位打印特定用户每天连接时间：
```shell
ac --daily-totals --individual-totals {{用户名}}
```
#### 显示附加明细：
```shell
ac --compatibility
```
{% endraw %}{% raw %}
<h2 id="acpi">
  <a href="/zh/linux/acpi.html">acpi</a> <a href="#acpi"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示电池状态或热量信息。
> 更多信息：<https://sourceforge.net/projects/acpiclient/files/acpiclient/>.

#### 显示电池信息：
```shell
acpi
```
#### 显示热量（温度）信息：
```shell
acpi -t
```
#### 显示冷却设备信息：
```shell
acpi -c
```
#### 用华氏度单位显示热量（温度）信息：
```shell
acpi -tf
```
#### 显示所有信息：
```shell
acpi -V
```
#### 从 `/proc` 而非 `/sys` 中提取信息：
```shell
acpi -p
```
{% endraw %}{% raw %}
<h2 id="add-apt-repository">
  <a href="/zh/linux/add-apt-repository.html">add-apt-repository</a> <a href="#add-apt-repository"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> apt 仓库管理。

#### 添加一个新的 apt 仓库：
```shell
add-apt-repository {{指定仓库}}
```
#### 移除一个 apt 仓库：
```shell
add-apt-repository --remove {{指定仓库}}
```
#### 添加一个仓库并更新缓存：
```shell
add-apt-repository --update {{指定仓库}}
```
#### 允许从指定仓库下载源码：
```shell
add-apt-repository --enable-source {{指定仓库}}
```
{% endraw %}{% raw %}
<h2 id="addpart">
  <a href="/zh/linux/addpart.html">addpart</a> <a href="#addpart"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将特定分区的存在告知 Linux 内核。
> 这个命令是 `add partition` ioctl 的简单封装。
> 更多信息：<https://manned.org/addpart>.

#### 将特定分区的存在告知 Linux 内核：
```shell
addpart {{设备名}} {{分区名}} {{起始点}} {{长度}}
```
{% endraw %}{% raw %}
<h2 id="addr2line">
  <a href="/zh/linux/addr2line.html">addr2line</a> <a href="#addr2line"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将二进制文件地址转换成文件名和行数。

#### 显示可执行文件的指令地址对应源代码的文件名和行数：
```shell
addr2line --exe={{可执行文件路径}} {{地址}}
```
#### 显示函数名、文件名和行数：
```shell
addr2line --exe={{可执行文件路径}} --functions {{地址}}
```
#### 将 c++ 代码函数名符号重组：
```shell
addr2line --exe={{可执行文件地址}} --functions --demangle {{地址}}
```
{% endraw %}{% raw %}
<h2 id="adduser">
  <a href="/zh/linux/adduser.html">adduser</a> <a href="#adduser"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 添加用户的工具.
> 更多信息： <https://manpages.debian.org/latest/adduser/adduser.html>.

#### 创建一个新用户，在默认路径创建 home 目录，并提示用户设置密码:
```shell
adduser {{用户名}}
```
#### 创建一个新用户，不生成 home 目录:
```shell
adduser --no-create-home {{用户名}}
```
#### 创建一个新用户，并在指定路径下创建 home 目录:
```shell
adduser --home {{home 路径}} {{用户名}}
```
#### 创建一个新用户，并指定登录 shell:
```shell
adduser --shell {{shell 路径}} {{用户名}}
```
#### 创建一个新用户，并指定其用户组:
```shell
adduser --ingroup {{用户组}} {{用户名}}
```
{% endraw %}{% raw %}
<h2 id="alpine">
  <a href="/zh/linux/alpine.html">alpine</a> <a href="#alpine"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个电子邮件客户端和 usenet 新闻组程序，具有 pico/nano 风格的界面
> 通过 IMAP 支持大多数现代电子邮件服务

#### 正常打开 alpine:
```shell
alpine
```
#### 直接打开写信息界面，并指定电子邮件发送地址:
```shell
alpine {{邮箱地址}}
```
#### 退出 alpine:
```shell
'q' 然后 'y'
```
{% endraw %}{% raw %}
<h2 id="amixer">
  <a href="/zh/linux/amixer.html">amixer</a> <a href="#amixer"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ALSA 声卡驱动程序的混合器。

#### 增加 10% 的主音量：
```shell
amixer -D pulse sset Master {{10%+}}
```
#### 降低 10% 的主音量：
```shell
amixer -D pulse sset Master {{10%-}}
```
{% endraw %}{% raw %}
<h2 id="apache2ctl">
  <a href="/zh/linux/apache2ctl.html">apache2ctl</a> <a href="#apache2ctl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Apache HTTP web 服务器命令行管理工具。
> 基于 Debian 的操作系统自带该命令，基于 RHEL 的查看 `httpd`。

#### 启动 Apache 守护进程。如果已运行则发送一个消息：
```shell
sudo apache2ctl start
```
#### 关闭 Apache 守护进程：
```shell
sudo apache2ctl stop
```
#### 重启 Apache 守护进程：
```shell
sudo apache2ctl restart
```
#### 检查配置文件语法：
```shell
sudo apache2ctl -t
```
#### 列出已加载模块：
```shell
sudo apache2ctl -M
```
{% endraw %}{% raw %}
<h2 id="apk">
  <a href="/zh/linux/apk.html">apk</a> <a href="#apk"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Alpine Linux 的包管理工具.

#### 从所有的远程仓库中更新仓库索引:
```shell
apk update
```
#### 安装一个新软件包:
```shell
apk add {{软件包}}
```
#### 移除一个软件包:
```shell
apk del {{软件包}}
```
#### 修复或更新软件包而不修改主依赖项:
```shell
apk fix {{软件包}}
```
#### 通过关键字查找软件包:
```shell
apk search {{关键字}}
```
#### 获取指定软件包的相关信息:
```shell
apk info {{软件包}}
```
{% endraw %}{% raw %}
<h2 id="aplay">
  <a href="/zh/linux/aplay.html">aplay</a> <a href="#aplay"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ALSA 声卡驱动程序的命令行声音播放器。
> 更多信息：<https://manned.org/aplay>.

#### 播放一个文件（会自动根据文件格式确定采样率、位深等）：
```shell
aplay {{文件路径}}
```
#### 以 2500 Hz 播放指定文件的前 10 秒：
```shell
aplay --duration={{10}} --rate={{2500}} {{文件路径}}
```
#### 以 22050 Hz，mono，8-bit，Mu-Law 和 `.au` 格式来播放指定原始文件：
```shell
aplay --channels={{1}} --file-type {{raw}} --rate={{22050}} --format={{mu_law}} {{文件路径}}
```
{% endraw %}{% raw %}
<h2 id="apport-bug">
  <a href="/zh/linux/apport-bug.html">apport-bug</a> <a href="#apport-bug"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 Ubuntu 上提交错误报告。
> 更多信息：<https://wiki.ubuntu.com/Apport>.

#### 报告整个系统的错误：
```shell
apport-bug
```
#### 报告某个软件包的错误：
```shell
apport-bug {{包名}}
```
#### 报告某个可执行文件的错误：
```shell
apport-bug {{可执行文件路径}}
```
#### 报告某个进程的错误：
```shell
apport-bug {{PID}}
```
{% endraw %}{% raw %}
<h2 id="apt-add-repository">
  <a href="/zh/linux/apt-add-repository.html">apt-add-repository</a> <a href="#apt-add-repository"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 apt 仓库。

#### 添加一个 apt 仓库：
```shell
apt-add-repository {{repository_spec}}
```
#### 移除一个 apt 仓库：
```shell
apt-add-repository --remove {{repository_spec}}
```
#### 添加一个 apt 仓库之后更新包缓存：
```shell
apt-add-repository --update {{repository_spec}}
```
#### 开启源码包：
```shell
apt-add-repository --enable-source {{repository_spec}}
```
{% endraw %}{% raw %}
<h2 id="apt-cache">
  <a href="/zh/linux/apt-cache.html">apt-cache</a> <a href="#apt-cache"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Debian 和 Ubuntu 的包查询工具.
> 更多信息： <https://manpages.debian.org/latest/apt/apt-cache.8.html>.

#### 在当前的软件源中查找一个软件包:
```shell
apt-cache search {{软件包}}
```
#### 显示指定软件包的相关信息:
```shell
apt-cache show {{软件包}}
```
#### 查看一个软件包是否安装或是否为最新:
```shell
apt-cache policy {{软件包}}
```
#### 显示一个软件包的依赖项:
```shell
apt-cache depends {{软件包}}
```
#### 列出依赖指定软件包的所有软件包:
```shell
apt-cache rdepends {{软件包}}
```
{% endraw %}{% raw %}
<h2 id="apt-file">
  <a href="/zh/linux/apt-file.html">apt-file</a> <a href="#apt-file"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 apt 软件包中查找文件，其中也包括未安装的软件
> 更多信息： <https://manpages.debian.org/latest/apt-file/apt-file.1.html>.

#### 更新元数据的数据库:
```shell
sudo apt update
```
#### 查找包含指定文件或路径的软件包:
```shell
apt-file search {{文件名或路径}}
```
#### 列出指定包的内容:
```shell
apt-file list {{软件包名}}
```
{% endraw %}{% raw %}
<h2 id="apt-get">
  <a href="/zh/linux/apt-get.html">apt-get</a> <a href="#apt-get"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Debian 和 Ubuntu 的软件包管理工具.
> 使用`apt-cache`查找包.
> 更多信息： <https://manpages.debian.org/latest/apt/apt-get.8.html>.

#### 更新可用软件包及其版本列表（推荐在其他`apt-get`命令运行之前使用）:
```shell
apt-get update
```
#### 安装一个软件包或更新到最新版本:
```shell
apt-get install {{软件包}}
```
#### 移除一个软件包:
```shell
apt-get remove {{软件包}}
```
#### 升级所有已安装软件包到最新版本:
```shell
apt-get upgrade
```
#### 移除所有不再需要的软件包:
```shell
apt-get autoremove
```
#### 升级已安装的软件包（类似于`upgrade`）, 移除过时的软件包并安装额外的软件包以满足新的依赖:
```shell
apt-get dist-upgrade
```
{% endraw %}{% raw %}
<h2 id="apt-key">
  <a href="/zh/linux/apt-key.html">apt-key</a> <a href="#apt-key"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Debian 和 Ubuntu 上的 APT 软件包管理器的密钥管理工具
> 更多信息： <https://manpages.debian.org/latest/apt/apt-key.8.html>.

#### 列出可信密钥:
```shell
apt-key list
```
#### 向可信密钥库中添加一个密钥:
```shell
apt-key add {{密钥文件.asc}}
```
#### 从可信密钥库中移除一个密钥:
```shell
apt-key del {{密钥 id}}
```
#### 向可信密钥库中添加一个远程密钥:
```shell
wget -qO - {{https://host.tld/filename.key}} | apt-key add -
```
#### 指定密钥 ID, 从密钥服务器中添加一个密钥:
```shell
apt-key adv --keyserver {{pgp.mit.edu}} --recv {{密钥 id}}
```
{% endraw %}{% raw %}
<h2 id="apt-mark">
  <a href="/zh/linux/apt-mark.html">apt-mark</a> <a href="#apt-mark"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 修改已安装软件包状态的工具
> 更多信息： <https://manpages.debian.org/latest/apt/apt-mark.8.html>.

#### 将一个软件包标记为自动安装:
```shell
sudo apt-mark auto {{软件包名}}
```
#### 将一个软件包保持在当前版本，防止对其更新:
```shell
sudo apt-mark hold {{软件包名}}
```
#### 允许对一个软件包更新:
```shell
sudo apt-mark unhold {{软件包名}}
```
#### 列出手动安装的软件包:
```shell
apt-mark showmanual
```
#### 列出保持当前版本而不更新的软件包:
```shell
apt-mark showhold
```
{% endraw %}{% raw %}
<h2 id="apt">
  <a href="/zh/linux/apt.html">apt</a> <a href="#apt"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 基于 Debian 的发行版上的软件包管理工具.
> 更多信息： <https://manpages.debian.org/latest/apt/apt.8.html>.

#### 更新可用软件包及其版本列表（推荐在运行其他 apt 命令前首先运行该命令）:
```shell
sudo apt update
```
#### 查找指定软件包:
```shell
apt search {{软件包}}
```
#### 显示关于指定软件包的信息:
```shell
apt show {{软件包}}
```
#### 安装指定软件包或将指定软件包更新到最新版本:
```shell
sudo apt install {{软件包}}
```
#### 移除指定软件包（使用`purge`可以同时移除其配置文件）:
```shell
sudo apt remove {{软件包}}
```
#### 将所有已安装软件包更新到最新可用版本:
```shell
sudo apt upgrade
```
{% endraw %}{% raw %}
<h2 id="aptitude">
  <a href="/zh/linux/aptitude.html">aptitude</a> <a href="#aptitude"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Debian 和 Ubuntu 上的软件包管理工具.
> 更多信息： <https://manpages.debian.org/latest/aptitude/aptitude.8.html>.

#### 同步可用软件包及其版本列表，在运行后续 aptitude 命令前，应该首先运行该命令:
```shell
aptitude update
```
#### 安装一个新的软件包及其依赖项:
```shell
aptitude install {{软件包}}
```
#### 查找软件包:
```shell
aptitude search {{软件包}}
```
#### 移除一个软件包并移除所有依赖它的软件包:
```shell
aptitude remove {{软件包}}
```
#### 更新已安装软件包到最新版本:
```shell
aptitude upgrade
```
#### 更新已安装的软件包（类似于`aptitude upgrade`命令）， 移除过时的软件包并安装额外的软件包以满足新的软件包依赖项:
```shell
aptitude full-upgrade
```
{% endraw %}{% raw %}
<h2 id="arch">
  <a href="/zh/linux/arch.html">arch</a> <a href="#arch"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示当前系统架构名称.
> 参阅`uname`.

#### 显示当前系统架构名称:
```shell
arch
```
{% endraw %}{% raw %}
<h2 id="archey">
  <a href="/zh/linux/archey.html">archey</a> <a href="#archey"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个可以以新颖的方式显示系统信息的简单工具.

#### 显示系统信息:
```shell
archey
```
{% endraw %}{% raw %}
<h2 id="archlinux-java">
  <a href="/zh/linux/archlinux-java.html">archlinux-java</a> <a href="#archlinux-java"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 提供 Java 环境设置功能的一个帮助脚本。
> 更多信息：<https://github.com/michaellass/archlinux-java-run>.

#### 列出已安装的 Java 环境：
```shell
archlinux-java status
```
#### 设置默认的 Java 环境：
```shell
archlinux-java set {{java_environment}}
```
#### 取消默认的 Java 环境：
```shell
archlinux-java unset
```
#### 自动设置默认的 Java 环境：
```shell
archlinux-java fix
```
{% endraw %}{% raw %}
<h2 id="arecored">
  <a href="/zh/linux/arecored.html">arecored</a> <a href="#arecored"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> ALSA 声卡驱动的声音录制器。
> 更多信息：<https://manned.org/aplay>.

#### 以 "CD" 质量录制一段声音（录制结束以 Ctrl-C 停止）：
```shell
arecord -vv --format=cd {{路径/文件名.wav}}
```
#### 以 "CD" 质量录制 10 秒钟声音：
```shell
arecord -vv --format=cd --duration={{10}} {{路径/文件名.wav}}
```
#### 录制一段声音并以 mp3 格式保存（录制结束以 Ctrl-C 停止）：
```shell
arecord -vv --format=cd --file-type raw | lame -r - {{路径/文件名.mp3}}
```
#### 列出所有的声卡和数字音频设备：
```shell
arecord --list-devices
```
#### 允许交互式界面（例如使用空格键或回车键来播放或暂停）：
```shell
arecord --interactive
```
{% endraw %}{% raw %}
<h2 id="arithmetic">
  <a href="/zh/linux/arithmetic.html">arithmetic</a> <a href="#arithmetic"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 测试见到你的算术问题。
> 更多信息：<https://manpages.debian.org/bsdgames/arithmetic.6.html>.

#### 开始算术测试：
```shell
arithmetic
```
#### 指定一个或多个算术运算符来设计问题：
```shell
arithmetic -o {{+|-|x|/}}
```
#### 指定范围。加法和乘法问题限定 0 到指定范围之间的数字，包含上区间。减法和除法问题限制结果和运算数字必须在 0 到指定范围之间：
```shell
arithmetic -r {{7}}
```
{% endraw %}{% raw %}
<h2 id="ark">
  <a href="/zh/linux/ark.html">ark</a> <a href="#ark"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> KDE 归档工具。
> 更多信息： <https://docs.kde.org/stable5/en/kdeutils/ark/>.

#### 将存档解压缩到当前目录：
```shell
ark --batch {{存档名}}
```
#### 改变解压缩目录：
```shell
ark --batch --destination {{解压缩目录路径}} {{存档名}}
```
#### 创建一个原本不存在的存档并向它添加文件：
```shell
ark --add-to {{存档名}} {{文件1}} {{文件2}}
```
{% endraw %}{% raw %}
<h2 id="arp-scan">
  <a href="/zh/linux/arp-scan.html">arp-scan</a> <a href="#arp-scan"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 发送 ARP 数据包到特定主机（指定 IP 地址或主机名），来扫描本地网络.

#### 扫描当前本地网络:
```shell
arp-scan --localnet
```
#### 扫描带有自定义位掩码的 IP 网络:
```shell
arp-scan {{192.168.1.1}}/{{24}}
```
#### 扫描自定义范围内的 IP 网络:
```shell
arp-scan {{127.0.0.0}}-{{127.0.0.31}}
```
#### 扫描带有自定义子网掩码的 IP 网络:
```shell
arp-scan {{10.0.0.0}}:{{255.255.255.0}}
```
{% endraw %}{% raw %}
<h2 id="as">
  <a href="/zh/linux/as.html">as</a> <a href="#as"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个可移植的 GUN 汇编器.
> 主要用于汇编`gcc`的输出，以供链接器`ld`使用.

#### 汇编一个文件，输出为 a.out:
```shell
as {{文件.s}}
```
#### 汇编文件，并指定输出文件:
```shell
as {{文件.s}} -o {{输出.o}}
```
#### 通过跳过空格和注释的预处理过程来更快的产生输出文件（只应该用于可信任的编译器的输出）:
```shell
as -f {{文件.s}}
```
#### 将给定路径添加到目录列表，来搜索.include 指令指定的文件:
```shell
as -I {{目录路径}} {{文件.s}}
```
{% endraw %}{% raw %}
<h2 id="ascii">
  <a href="/zh/linux/ascii.html">ascii</a> <a href="#ascii"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示 ASCII 字符的别名。
> 更多信息：<http://www.catb.org/~esr/ascii/>.

#### 显示一个 ASCII 字符的别名：
```shell
ascii {{a}}
```
#### 以较短和脚本友好模式显示 ASCII 字符的别名：
```shell
ascii -t {{a}}
```
#### 显示多个 ASCII 字符的别名：
```shell
ascii -s {{tldr}}
```
#### 显示十进制 ASCII 字符表：
```shell
ascii -d
```
#### 显示十六进制 ASCII 字符表：
```shell
ascii -x
```
#### 显示八进制 ASCII 字符表：
```shell
ascii -o
```
#### 显示二进制 ASCII 字符表：
```shell
ascii -b
```
#### 显示选项总结和整个 ASCII 字符表：
```shell
ascii
```
{% endraw %}{% raw %}
<h2 id="asciiart">
  <a href="/zh/linux/asciiart.html">asciiart</a> <a href="#asciiart"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将图像转换为 ASCII.
> 更多信息: <https://github.com/nodanaonlyzuul/asciiart>.

#### 从文件中读取图像并以 ASCII 打印:
```shell
asciiart {{路径/image.jpg}}
```
#### 从 URL 中读取图像并以 ASCII 打印:
```shell
asciiart {{www.example.com/image.jpg}}
```
#### 选择输出宽度 (默认为 100):
```shell
asciiart -width {{50}} {{路径/image.jpg}}
```
#### 对 ASCII 输出进行着色:
```shell
asciiart --color {{路径/image.jpg}}
```
#### 选择输出格式 (默认格式为文本):
```shell
asciiart --format {{text|html}} {{路径/image.jpg}}
```
#### 反转字符映射:
```shell
asciiart --invert-chars {{路径/image.jpg}}
```
{% endraw %}{% raw %}
<h2 id="aspell">
  <a href="/zh/linux/aspell.html">aspell</a> <a href="#aspell"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 交互式拼写检查工具.

#### 为一个文件做拼写检查:
```shell
aspell check {{文件路径}}
```
#### 列出来自标准输入的拼写错误单词:
```shell
cat {{文件}} | aspell list
```
#### 列出可用的字典语言:
```shell
aspell dicts
```
#### 指定不同的语言（取 ISO 639 语言代码的 2 个字母）来运行 aspell:
```shell
aspell --lang={{cs}}
```
#### 列出来自标准输入的拼写错误单词，并且忽略个人单词列表中的单词:
```shell
cat {{文件}} | aspell --personal={{个人单词列表.pws}} {{列表}}
```
{% endraw %}{% raw %}
<h2 id="asterisk">
  <a href="/zh/linux/asterisk.html">asterisk</a> <a href="#asterisk"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 电话和交换（手机）服务器。
> 用于管理服务器自身和管理已经在运行的实例。
> 更多信息：<https://wiki.asterisk.org/wiki/display/AST/Home>.

#### 重新连接一个正在运行的服务器，并打开 3 级的日志详细度：
```shell
asterisk -r -vvv
```
#### 重新连接一个正在运行的服务器，执行一个命令，然后返回：
```shell
asterisk -r -x "{{命令}}"
```
#### 显示 chan_SIP 客户端（手机）：
```shell
asterisk -r -x "sip show peers"
```
#### 显示激活的通话和频道：
```shell
asterisk -r -x "core show channels"
```
#### 显示语音邮箱：
```shell
asterisk -r -x "voicemail show users"
```
#### 终止一个频道：
```shell
asterisk -r -x "hangup request {{频道 ID}}"
```
#### 重新载入 chan_SIP 设置：
```shell
asterisk -r -x "sip reload"
```
{% endraw %}{% raw %}
<h2 id="at">
  <a href="/zh/linux/at.html">at</a> <a href="#at"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在指定时间执行命令.
> 更多信息： <https://man.archlinux.org/man/at.1>.

#### 打开`at`提示符创建一组新的定时命令，按`Ctrl + D`保存并退出:
```shell
at {{hh:mm:ss}}
```
#### 运行命令并通过本地电子邮件程序（例如 sendmail) 发送运行结果:
```shell
at {{hh:mm:ss}} -m
```
#### 在指定时间执行一个脚本:
```shell
at {{hh:mm:ss}} -f {{文件路径}}
```
{% endraw %}{% raw %}
<h2 id="auracle">
  <a href="/zh/linux/auracle.html">auracle</a> <a href="#auracle"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用来和 Arch Linux 用户仓库交互的命令行工具，这个仓库通常被称作 AUR。
> 更多信息：<https://github.com/falconindy/auracle>.

#### 显示符合一个正则表达式的 AUR 包：
```shell
auracle search '{{regular_expression}}'
```
#### 显示 AUR 包列表的包信息，包名以一个单独的空格分隔：
```shell
auracle info {{package1}} {{package2}}
```
#### 显示 AUR 包列表的 `PKGBUILD` 文件（编译信息），包名以一个单独的空格分隔：
```shell
auracle show {{package1}} {{package2}}
```
#### 显示已安装 AUR 包的更新：
```shell
auracle outdated
```
{% endraw %}{% raw %}
<h2 id="authconfig">
  <a href="/zh/linux/authconfig.html">authconfig</a> <a href="#authconfig"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于设置系统认证资源的命令行界面。

#### 显示当前的配置（或空运行）：
```shell
authconfig --test
```
#### 设置服务器使用另一种不同的密码散列算法：
```shell
authconfig --update --passalgo={{算法名}}
```
#### 启用 LDAP 认证：
```shell
authconfig --update --enableldapauth
```
#### 关闭 LDAP 认证：
```shell
authconfig --update --disableldapauth
```
#### 开启网络信息服务（NIS）：
```shell
authconfig --update --enablenis
```
#### 开启 Kerberos：
```shell
authconfig --update --enablekrb5
```
#### 开启 Winbind （活动目录）认证：
```shell
authconfig --update --enablewinbindauth
```
#### 开启本地认证：
```shell
authconfig --update --enablelocauthorize
```
{% endraw %}{% raw %}
<h2 id="autorandr">
  <a href="/zh/linux/autorandr.html">autorandr</a> <a href="#autorandr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 自动调节屏幕布局。

#### 保存当前屏幕布局：
```shell
autorandr -s {{配置文件名}}
```
#### 显示保存的配置：
```shell
autorandr
```
#### 切换设置：
```shell
autorandr -l {{配置文件名}}
```
#### 设置默认设置：
```shell
autorandr -d {{配置文件名}}
```
{% endraw %}{% raw %}
<h2 id="avahi-browse">
  <a href="/zh/linux/avahi-browse.html">avahi-browse</a> <a href="#avahi-browse"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示通过 mDNS/DNS-SD 暴露在本地网络的服务和主机。
> Avahi 与苹果设备的 Bonjour (Zeroconf) 兼容。
> 更多信息：<https://www.avahi.org/>.

#### 列出本地网络中的所有服务和他们的地址与端口，忽略他们本地的地址和端口：
```shell
avahi-browse --all --resolve --ignore-local
```
#### 列出所有的域名：
```shell
avahi-browse --browse-domains
```
#### 只搜索一个特定的域名：
```shell
avahi-browse --all --domain={{domain}}
```
{% endraw %}{% raw %}
<h2 id="boltctl">
  <a href="/zh/linux/boltctl.html">boltctl</a> <a href="#boltctl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 控制雷电 (thunderbolt) 设备。
> 更多信息：<https://manned.org/boltctl>.

#### 列出已连接并授权的设备：
```shell
boltctl
```
#### 列出已连接的设备，且包含未授权的设备：
```shell
boltctl list
```
#### 临时授权一个设备：
```shell
boltctl authorize {{设备uuid}}
```
#### 授权并记住一个设备：
```shell
boltctl enroll {{设备uuid}}
```
#### 取消一个设备的授权：
```shell
boltctl forget {{设备uuid}}
```
#### 显示一个设备的详细信息：
```shell
boltctl info {{设备uuid}}
```
{% endraw %}{% raw %}
<h2 id="btrfs-device">
  <a href="/zh/linux/btrfs-device.html">btrfs device</a> <a href="#btrfs-device"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 btrfs 文件系统中的设备。
> 更多信息：<https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-device>。

#### 将一个或多个设备添加到 b​​trfs 文件系统中：
```shell
sudo btrfs device add {{指向设备1的路径}} [{{指向设备2的路径}}] {{指向 btrfs 文件系统的路径}}
```
#### 从 btrfs 文件系统中删除设备：
```shell
sudo btrfs device remove {{指向设备的路径|设备 ID}} [{{...}}]
```
#### 显示错误统计：
```shell
sudo btrfs device stats {{指向 btrfs 文件系统的路径}}
```
#### 扫描所有磁盘并将所有检测到的 btrfs 文件系统通知内核：
```shell
sudo btrfs device scan --all-devices
```
#### 显示详细的每个磁盘的空间分配统计信息：
```shell
sudo btrfs device usage {{指向 btrfs 文件系统的路径}}
```
{% endraw %}{% raw %}
<h2 id="btrfs-filesystem">
  <a href="/zh/linux/btrfs-filesystem.html">btrfs filesystem</a> <a href="#btrfs-filesystem"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 btrfs 文件系统。
> 更多信息：<https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-filesystem>。

#### 显示文件系统使用情况（可以选择以 root 身份运行以显示详细信息）：
```shell
btrfs filesystem usage {{指向挂载点的路径}}
```
#### 显示各个设备的使用情况：
```shell
sudo btrfs filesystem show {{指向挂载点的路径}}
```
#### 对 btrfs 文件系统上的单个文件进行碎片整理（避免在运行数据去重的同时运行）：
```shell
sudo btrfs filesystem defragment -v {{指向文件的路径}}
```
#### 递归对目录进行碎片整理（不跨越子卷边界）：
```shell
sudo btrfs filesystem defragment -v -r {{指向目录的路径}}
```
#### 强制将未写入的数据块同步到磁盘：
```shell
sudo btrfs filesystem sync {{指向挂载点的路径}}
```
#### 递归总结目录中文件的磁盘使用情况：
```shell
sudo btrfs filesystem du --summarize {{指向目录的路径}}
```
{% endraw %}{% raw %}
<h2 id="btrfs-scrub">
  <a href="/zh/linux/btrfs-scrub.html">btrfs scrub</a> <a href="#btrfs-scrub"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 清理 btrfs 文件系统以验证数据完整性。
> 建议每月运行一次 scrub。
> 更多信息：<https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-scrub>。

#### 开始 scrub：
```shell
sudo btrfs scrub start {{指向挂载点的路径}}
```
#### 显示正在进行或上次完成的 scrub 的状态：
```shell
sudo btrfs scrub status {{指向挂载点的路径}}
```
#### 取消正在进行的 scrub：
```shell
sudo btrfs scrub cancel {{指向挂载点的路径}}
```
#### 恢复先前取消的 scrub：
```shell
sudo btrfs scrub resume {{指向挂载点的路径}}
```
#### 开始擦洗，但要等到 scrub 完成后才能退出：
```shell
sudo btrfs scrub start -B {{指向挂载点的路径}}
```
#### 在安静模式下启动 scrub（不打印错误或统计信息）：
```shell
sudo btrfs scrub start -q {{指向挂载点的路径}}
```
{% endraw %}{% raw %}
<h2 id="btrfs-subvolume">
  <a href="/zh/linux/btrfs-subvolume.html">btrfs subvolume</a> <a href="#btrfs-subvolume"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 btrfs 子卷和快照。
> 更多信息：<https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-subvolume>。

#### 创建一个新的空子卷：
```shell
sudo btrfs subvolume create {{指向新子卷的路径}}
```
#### 列出指定文件系统中的所有子卷和快照：
```shell
sudo btrfs subvolume list {{指向 btrfs 文件系统的路径}}
```
#### 删除一个子卷：
```shell
sudo btrfs subvolume delete {{指向子卷的路径}}
```
#### 创建现有子卷的只读快照：
```shell
sudo btrfs subvolume snapshot -r {{指向源子卷的路径}} {{指向目标的路径}}
```
#### 创建现有子卷的读写快照：
```shell
sudo btrfs subvolume snapshot {{指向源子卷的路径}} {{指向目标的路径}}
```
#### 显示有关子卷的详细信息：
```shell
sudo btrfs subvolume show {{指向子卷的路径}}
```
{% endraw %}{% raw %}
<h2 id="btrfs">
  <a href="/zh/linux/btrfs.html">btrfs</a> <a href="#btrfs"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一种基于写时复制（COW）原理的 Linux 文件系统。

#### 创建子卷：
```shell
sudo btrfs subvolume create {{指向子卷的路径}}
```
#### 列出子卷：
```shell
sudo btrfs subvolume list {{指向挂载点的路径}}
```
#### 显示空间使用情况信息：
```shell
sudo btrfs filesystem df {{指向挂载点的路径}}
```
#### 启用配额（quota）：
```shell
sudo btrfs quota enable {{指向子卷的路径}}
```
#### 显示配额（quota）：
```shell
sudo btrfs qgroup show {{指向子卷的路径}}
```
{% endraw %}{% raw %}
<h2 id="cpuid">
  <a href="/zh/linux/cpuid.html">cpuid</a> <a href="#cpuid"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示有关所有 CPU 的详细信息.

#### 显示所有 CPU 的信息:
```shell
cpuid
```
#### 仅显示当前 CPU 的信息:
```shell
cpuid -1
```
#### 显示原始十六进制信息，不进行解码:
```shell
cpuid -r
```
{% endraw %}{% raw %}
<h2 id="debootstrap">
  <a href="/zh/linux/debootstrap.html">debootstrap</a> <a href="#debootstrap"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建一个基本的 `Debian` 系统。
> 更多信息：<https://wiki.debian.org/Debootstrap>.

#### 在 `debian-root` 目录中创建一个 `Debian` 稳定分支系统：
```shell
sudo debootstrap stable {{path/to/debian-root/}} http://deb.debian.org/debian
```
#### 使用本地镜像在 `focal-root` 目录中创建一个 `Ubuntu 20.04` 系统：
```shell
sudo debootstrap focal {{path/to/focal-root/}} {{file:///path/to/mirror/}}
```
#### 切换到可引导系统：
```shell
sudo chroot {{path/to/root}}
```
#### 列出可用的版本：
```shell
ls /usr/share/debootstrap/scripts/
```
{% endraw %}{% raw %}
<h2 id="debuild">
  <a href="/zh/linux/debuild.html">debuild</a> <a href="#debuild"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从源代码构建 `Debian` 软件包的工具。
> 更多信息：<https://manpages.debian.org/debuild>.

#### 在当前目录中生成软件包：
```shell
debuild
```
#### 仅构建二进制包：
```shell
debuild -b
```
#### 生成软件包后，不运行 `lintian` （检查常见打包错误）：
```shell
debuild --no-lintian
```
{% endraw %}{% raw %}
<h2 id="dmenu">
  <a href="/zh/linux/dmenu.html">dmenu</a> <a href="#dmenu"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 动态菜单。
> 根据文本输入创建菜单，其中每一项都在新行中。

#### 显示 `ls` 命令输出的菜单：
```shell
{{ls}} | dmenu
```
#### 显示包含自定义项目的菜单，并用新行（`\n`）分隔：
```shell
echo -e "{{red}}\n{{green}}\n{{blue}}" | dmenu
```
#### 让用户在多个项目之间进行选择，然后将所选项目保存到文件中：
```shell
echo -e "{{red}}\n{{green}}\n{{blue}}" | dmenu > {{color.txt}}
```
#### 在特定的监视器上启动 `dmenu`：
```shell
ls | dmenu -m {{1}}
```
#### 在屏幕底部显示 `dmenu`：
```shell
ls | dmenu -b
```
{% endraw %}{% raw %}
<h2 id="dmesg">
  <a href="/zh/linux/dmesg.html">dmesg</a> <a href="#dmesg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或控制内核环形缓冲区。
> 更多信息：<https://manned.org/dmesg>.

#### 显示来自内核环形缓冲区的所有消息：
```shell
dmesg
```
#### 只显示严重错误级别的消息：
```shell
dmesg --level err
```
#### 等待新消息。仅在具有可读性的系统上支持此功能，类似于 `tail -f`（从内核 3.5.0 版本开始）：
```shell
dmesg -w
```
#### 显示此系统上有多少物理内存可用：
```shell
dmesg | grep -i memory
```
#### 以分页方式显示内核缓冲区的所有消息：
```shell
dmesg | less
```
#### 打印人类可读的时间戳（从内核 3.5.0 版本开始）：
```shell
dmesg -T
```
#### 启用人类可读的输出：
```shell
dmesg -H
```
#### 着色输出：
```shell
dmesg -L
```
{% endraw %}{% raw %}
<h2 id="dos2unix">
  <a href="/zh/linux/dos2unix.html">dos2unix</a> <a href="#dos2unix"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将 DOS 样式的行尾更改为 Unix 样式.
> 用 CR 替换 CRLF.

#### 更改文件的行尾:
```shell
dos2unix {{文件名}}
```
#### 使用 Unix 样式的行尾创建副本:
```shell
dos2unix -n {{文件名}} {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="fc-cache">
  <a href="/zh/linux/fc-cache.html">fc-cache</a> <a href="#fc-cache"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 扫描字体目录，以便建立字体缓存文件。

#### 生成字体缓存文件：
```shell
fc-cache
```
#### 强制重建所有字体缓存文件，而不检查缓存是否为最新版本：
```shell
fc-cache -f
```
#### 删除字体缓存文件，然后生成新的字体缓存文件：
```shell
fc-cache -r
```
{% endraw %}{% raw %}
<h2 id="fc-list">
  <a href="/zh/linux/fc-list.html">fc-list</a> <a href="#fc-list"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 列出系统上安装的可用字体。

#### 返回系统中已安装字体的列表：
```shell
fc-list
```
#### 返回具有给定名称的已安装字体的列表：
```shell
fc-list | grep '{{DejaVu Serif}}'
```
#### 返回系统中已安装字体的数量：
```shell
fc-list | wc -l
```
{% endraw %}{% raw %}
<h2 id="flameshot">
  <a href="/zh/linux/flameshot.html">flameshot</a> <a href="#flameshot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 带有gui界面的Screenshot工具，支持基本的图像编辑，例如文本，形状，颜色和imgur.
> 更多信息: <https://flameshot.js.org>.

#### 在GUI模式下启动Flameshot:
```shell
flameshot launcher
```
#### 通过单击并拖动来截取屏幕截图:
```shell
flameshot gui
```
#### 全屏截图:
```shell
flameshot full
```
#### 将保存屏幕快照的路径设置为:
```shell
flameshot full --path {{path/to/directory}}
```
#### 将屏幕截图延迟N毫秒，然后输出到剪贴板:
```shell
flameshot full --delay {{2000}} --clipboard
```
{% endraw %}{% raw %}
<h2 id="flatpak">
  <a href="/zh/linux/flatpak.html">flatpak</a> <a href="#flatpak"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 构建、安装和运行 Flatpak 应用和运行时。

#### 运行已安装应用：
```shell
flatpak run {{应用名}}
```
#### 从远程源安装应用：
```shell
flatpak install {{远程源名}} {{应用名}}
```
#### 列出所有应用和运行时：
```shell
flatpak list
```
#### 更新所有已安装的应用和运行时：
```shell
flatpak update
```
#### 添加远程源：
```shell
flatpak remote-add --if-not-exists {{远程源名}} {{远程源网址}}
```
#### 列出所有已配置的远程源：
```shell
flatpak remote-list
```
{% endraw %}{% raw %}
<h2 id="i3">
  <a href="/zh/linux/i3.html">i3</a> <a href="#i3"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一款动态平铺窗口管理器。
> 更多信息：https://i3wm.org/docs/userguide.html>.

#### 启动 i3（注意在此命令运行前，务必关闭其它先前存在的窗口管理器）：
```shell
i3
```
#### 打开新终端窗口：
```shell
Super + Return
```
#### 创建新工作区：
```shell
Super + Shift + {{数字键}}
```
#### 切换到 {{数字}} 号工作区：
```shell
Super + {{数字键}}
```
#### 水平布局打开新窗口：
```shell
Super + h
```
#### 垂直布局打开新窗口：
```shell
Super + v
```
#### 打开应用（在执行命令后输入应用名称）：
```shell
Super + D
```
{% endraw %}{% raw %}
<h2 id="iptables">
  <a href="/zh/linux/iptables.html">iptables</a> <a href="#iptables"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 可用于配置 Linux 内核防火墙提供的过滤表、规则链和规则的程序。
> 更多信息： <https://www.netfilter.org/projects/iptables/>.

#### 查看过滤表的规则链、规则以及数据包/字节计数器：
```shell
sudo iptables -vnL
```
#### 设定规则链策略规则：
```shell
sudo iptables -P {{规则链}} {{规则}}
```
#### 追加规则到 IP 的规则链策略：
```shell
sudo iptables -A {{规则链}} -s {{ip}} -j {{规则}}
```
#### 追加规则到 IP 的规则链策略（考虑协议与端口）：
```shell
sudo iptables -A {{规则链}} -s {{ip}} -p {{协议}} --dport {{端口}} -j {{规则}}
```
#### 删除规则链中的规则：
```shell
sudo iptables -D {{规则链}} {{规则所在行号}}
```
#### 将指定过滤表的 iptables 配置保存到文件中：
```shell
sudo iptables-save -t {{过滤表名}} > {{iptables_文件路径}}
```
#### 从文件中还原 iptables 配置：
```shell
sudo iptables-restore < {{iptables_文件路径}}
```
{% endraw %}{% raw %}
<h2 id="konsole">
  <a href="/zh/linux/konsole.html">konsole</a> <a href="#konsole"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Konsole: KDE 终端模拟器.
> 更多信息: <https://konsole.kde.org>.

#### 在特定目录中打开一个新的 Konsole:
```shell
konsole --workdir {{path/to/directory}}
```
#### 运行特定命令，退出窗口后不要关闭窗口:
```shell
konsole --noclose -e {{命令}}
```
#### 打开新标签页:
```shell
konsole --new-tab
```
#### 在后台打开 Konsole 并在按下 Ctrl+Shift+F12 (默认) 时显示在最前面:
```shell
konsole --background-mode
```
#### 使用紧急备冗配置文件打开 Konsole:
```shell
konsole --fallback-profile
```
{% endraw %}{% raw %}
<h2 id="logsave">
  <a href="/zh/linux/logsave.html">logsave</a> <a href="#logsave"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将一个命令的输出保存在日志文件中.
> 更多信息: <https://manned.org/logsave>.

#### 使用指定的参数执行命令并将其输出保存到日志文件中:
```shell
logsave {{path/to/logfile}} {{command}}
```
#### 从标准输入中获取输入并将其保存在日志文件中:
```shell
logsave {{logfile}} -
```
#### 将输出追加到日志文件，而不是替换其当前内容:
```shell
logsave -a {{logfile}} {{command}}
```
#### 显示详细输出:
```shell
logsave -v {{logfile}} {{command}}
```
{% endraw %}{% raw %}
<h2 id="mac2unix">
  <a href="/zh/linux/mac2unix.html">mac2unix</a> <a href="#mac2unix"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将 macOS 样式的行尾更改为 Unix 样式.
> 用 CR 替换 LF.

#### 更改文件的行尾:
```shell
mac2unix {{文件名}}
```
#### 使用 Unix 样式的行尾创建副本:
```shell
mac2unix -n {{文件名}} {{新文件名}}
```
{% endraw %}{% raw %}
<h2 id="pacman">
  <a href="/zh/linux/pacman.html">pacman</a> <a href="#pacman"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Arch Linux 的软件包管理器工具。
> 更多信息: <https://man.archlinux.org/man/pacman.8>.

#### 同步并更新所有软件包：
```shell
pacman -Syu
```
#### 安装一个新的软件包：
```shell
pacman -S {{软件包}}
```
#### 删除一个软件包及其依赖：
```shell
pacman -Rs {{软件包}}
```
#### 在软件包数据库中搜索正则表达式或关键字：
```shell
pacman -Ss "{{软件包}}"
```
#### 列出已安装的软件包和版本：
```shell
pacman -Q
```
#### 仅列出明确安装的软件包和版本：
```shell
pacman -Qe
```
#### 查找哪个包拥有某个文件：
```shell
pacman -Qo {{文件名}}
```
#### 清空软件包缓存以释放空间：
```shell
pacman -Scc
```
{% endraw %}{% raw %}
<h2 id="poweroff">
  <a href="/zh/linux/poweroff.html">poweroff</a> <a href="#poweroff"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 关闭系统.

#### 关闭系统电源:
```shell
sudo poweroff
```
{% endraw %}{% raw %}
<h2 id="reboot">
  <a href="/zh/linux/reboot.html">reboot</a> <a href="#reboot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 重新启动系统.

#### 立即重新启动:
```shell
reboot
```
#### 立即重启，而无需正常关闭:
```shell
reboot -f
```
{% endraw %}{% raw %}
<h2 id="unix2dos">
  <a href="/zh/linux/unix2dos.html">unix2dos</a> <a href="#unix2dos"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将 Unix 样式的行尾更改为 DOS 样式.
> 用 CRLF 替换 CR.

#### 更改文件的行尾:
```shell
unix2dos {{文件名}}
```
#### 使用 DOS 样式的行尾创建副本:
```shell
unix2dos -n {{文件名}} {{新文件名}}
```
{% endraw %}{% raw %}
<h2 id="unix2mac">
  <a href="/zh/linux/unix2mac.html">unix2mac</a> <a href="#unix2mac"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将 Unix 样式的行尾更改为 macOS 样式.
> 用 LF 替换 CR.

#### 更改文件的行尾:
```shell
unix2mac {{文件名}}
```
#### 使用 macOS 样式的行尾创建副本:
```shell
unix2mac -n {{文件名}} {{新文件名}}
```
{% endraw %}{% raw %}
<h2 id="yaourt">
  <a href="/zh/linux/yaourt.html">yaourt</a> <a href="#yaourt"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Arch Linux 中用于从 Arch User Repository 中构建软件包的工具。

#### 同步并更新所有软件包（包括 AUR）：
```shell
yaourt -Syua
```
#### 安装一个新的软件包（包括 AUR）：
```shell
yaourt -S {{软件包}}
```
#### 移除一个软件包和它的依赖（包括 AUR 软件包）：
```shell
yaourt -Rs {{软件包}}
```
#### 在软件包数据库中搜索一个关键字（包括 AUR）：
```shell
yaourt -Ss {{软件包}}
```
#### 列出已安装的软件包、版本和仓库（AUR 软件包将被列在 'local' 仓库下):
```shell
yaourt -Q
```
{% endraw %}{% raw %}
<h2 id="yay">
  <a href="/zh/linux/yay.html">yay</a> <a href="#yay"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Yet Another Yogurt: 一个用于 Arch Linux 的工具，用于从 Arch User Repository 中构建和安装软件包。
> 另见 `pacman`。
> 更多信息: <https://github.com/Jguer/yay>.

#### 从仓库和 AUR 中交互式搜索和安装软件包：
```shell
yay {{软件包|搜索词}}
```
#### 同步并更新所有来自仓库和 AUR 的软件包：
```shell
yay
```
#### 只同步和更新 AUR 软件包：
```shell
yay -Sua
```
#### 从仓库和 AUR 中安装一个新的软件包。
```shell
yay -S {{软件包}}
```
#### 从仓库和 AUR 中搜索软件包数据库中的关键词：
```shell
yay -Ss {{关键词}}
```
#### 显示已安装软件包和系统健康状况的统计数据：
```shell
yay -Ps
```
{% endraw %}{% raw %}
<h2 id="zypper">
  <a href="/zh/linux/zypper.html">zypper</a> <a href="#zypper"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> SUSE & openSUSE 的软件包管理工具。

#### 同步可用的软件包和版本列表：
```shell
zypper refresh
```
#### 安装一个新的软件包：
```shell
zypper install {{软件包}}
```
#### 移除一个软件包：
```shell
zypper remove {{软件包}}
```
#### 将已安装的软件包升级到最新的可用版本：
```shell
zypper update
```
#### 通过关键字搜索软件包：
```shell
zypper search {{关键字}}
```
{% endraw %}# Osx
{% raw %}
<h2 id="afinfo">
  <a href="/zh/osx/afinfo.html">afinfo</a> <a href="#afinfo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示音频文件元数据 (Metadata) 详细信息 (OS X).
> OS X 自带命令.

#### 显示给定音频文件的详细信息:
```shell
afinfo {{目标 / 路径 / 文件}}
```
#### 显示简化的音频文件信息 (单行):
```shell
afinfo -b {{目标 / 路径 / 文件}}
```
#### 显示音频文件的元数据信息以及其 InfoDictionary 词典:
```shell
afinfo -i {{目标 / 路径 / 文件}}
```
#### 以 xml 格式显示音频文件信息:
```shell
afinfo -x {{目标 / 路径 / 文件}}
```
#### 显示警告信息 (如存在):
```shell
afinfo --warnings {{目标 / 路径 / 文件}}
```
#### 显示完整用法帮助:
```shell
afinfo -h
```
{% endraw %}{% raw %}
<h2 id="airport">
  <a href="/zh/osx/airport.html">airport</a> <a href="#airport"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 无线网络配置工具.

#### 显示当前的无线状态信息:
```shell
airport -I
```
#### 在通道 1 上监察（嗅探）无线流量:
```shell
airport sniff {{1}}
```
#### 扫描可用的无线网络:
```shell
airport -s
```
#### 与当前的 Airport 网络脱离连接:
```shell
sudo airport -z
```
{% endraw %}{% raw %}
<h2 id="apachectl">
  <a href="/zh/osx/apachectl.html">apachectl</a> <a href="#apachectl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于 macOS 的 Apache HTTP Server 控制接口（工具）.

#### 启动 org.apache.httpd 服务:
```shell
apachectl start
```
#### 停止已启动的服务:
```shell
apachectl stop
```
#### 重新启动服务:
```shell
apachectl restart
```
{% endraw %}{% raw %}
<h2 id="archey">
  <a href="/zh/osx/archey.html">archey</a> <a href="#archey"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 漂亮地显示简单系统信息工具.

#### 显示系统信息（彩色的）:
```shell
archey
```
#### 显示系统信息（单色的）:
```shell
archey --nocolor
```
#### 显示系统信息，使用 MacPorts（命令行软件安装管理工具 port) 来替代 Homebrew（另一种更常用的 mac 命令行软件安装管理工具）:
```shell
archey --macports
```
#### 显示系统信息，但不进行 IP 地址获取和验证:
```shell
archey --offline
```
{% endraw %}{% raw %}
<h2 id="as">
  <a href="/zh/osx/as.html">as</a> <a href="#as"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 便携式 GNU 汇编程序.
> 主要用于汇编 `gcc` 的输出以供 `ld` 使用

#### 汇编文件，将输出写入 a.out:
```shell
as {{文件.s}}
```
#### 将输出汇编到给定文件:
```shell
as {{文件.s}} -o {{输出.o}}
```
#### 通过跳过空白和注释预处理来更快地生成输出.（应该只用于受信任的编译器）:
```shell
as -f {{文件.s}}
```
#### 在目录列表中包含一个给定路径，以搜索 .include 指令中指定的文件:
```shell
as -I {{目标文件夹}} {{文件.s}}
```
{% endraw %}{% raw %}
<h2 id="asr">
  <a href="/zh/osx/asr.html">asr</a> <a href="#asr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将磁盘映像还原（复制）到卷上.
> 命令名称是 Apple Software Restore 的缩写.

#### 将磁盘映像复制到目标卷:
```shell
sudo asr restore --source {{映像名}}.dmg --target {{卷路径}}
```
#### 在复制之前擦除目标卷:
```shell
sudo asr restore --source {{映像名}}.dmg --target {{卷路径}} --erase
```
#### 恢复后跳过验证步骤:
```shell
sudo asr restore --source {{映像名}}.dmg --target {{卷路径}} --noverify
```
#### 不使用中间磁盘映像直接复制卷中的数据:
```shell
sudo asr restore --source {{卷路径}} --target {{复制卷路径}}
```
{% endraw %}{% raw %}
<h2 id="base64">
  <a href="/zh/osx/base64.html">base64</a> <a href="#base64"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Base64 来进行编码和解码.

#### 编码目标文件:
```shell
base64 --input={{目标文件}}
```
#### 解码目标文件:
```shell
base64 --decode --input={{base64 编码文件}}
```
#### 通过标准输入管道进行解码:
```shell
echo -n {{目标字符串}} | base64
```
#### 解码标准输入管道内容:
```shell
echo -n {{base64 字符串}} | base64 --decode
```
{% endraw %}{% raw %}
<h2 id="brew-cask">
  <a href="/zh/osx/brew-cask.html">brew cask</a> <a href="#brew-cask"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> macOS 上的应用程序包管理工具.

#### 模糊搜索可用命令行工具和软件包:
```shell
brew search {{软件名}}
```
#### 安装一个软件:
```shell
brew cask install {{软件名}}
```
#### 列出全部已安装软件:
```shell
brew cask list
```
#### 列出全部已安装的软件中，可以升级的:
```shell
brew cask outdated
```
#### 将一个已安装的软件升级到最新的版本:
```shell
brew cask upgrade {{软件名}}
```
#### 删除一个软件（仅通过 brew cask install 方式安装的）:
```shell
brew cask uninstall {{软件名}}
```
#### 卸载一个软件并删除相关的设置和文件:
```shell
brew cask zap {{软件名}}
```
#### 显示指定软件的相关信息:
```shell
brew cask info {{软件名}}
```
{% endraw %}{% raw %}
<h2 id="brew-mas">
  <a href="/zh/osx/brew-mas.html">brew mas</a> <a href="#brew-mas"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Mas 是一个简单的 Mac App Store 命令行界面.

#### 按应用名称搜索 Mac App Store 并返回匹配的标识符:
```shell
mas search {{应用名}}
```
#### 安装或更新以前购买的应用程序:
```shell
mas install {{应用名}} {{应用 ID}}
```
#### 显示所有已安装的应用程序及其应用 ID:
```shell
mas list
```
#### 列出等待更新的已安装应用:
```shell
mas outdated
```
#### 升级所有可升级的应用:
```shell
mas upgrade
```
#### 升级指定的应用:
```shell
mas upgrade {{应用 ID}}
```
{% endraw %}{% raw %}
<h2 id="brew">
  <a href="/zh/osx/brew.html">brew</a> <a href="#brew"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> macOS 上的软件包管理工具.

#### 搜索可用的命令行和软件安装包:
```shell
brew search {{软件名}}
```
#### 安装最新版本的命令行软件 （使用 `--devel` 可以指定安装更新的开发版）:
```shell
brew install {{软件名}}
```
#### 列出已（通过 brew) 安装的命令行工具:
```shell
brew list
```
#### 升级已安装的命令行软件（如果未给出命令行软件名称，则升级所有已安装的软件）:
```shell
brew upgrade {{软件名}}
```
#### 从 GitHub 上升级 brew 和软件库到最新:
```shell
brew update
```
#### 显示有关指定软件的信息（版本，安装路径，依赖关系等）:
```shell
brew info {{软件名}}
```
#### 检查本地 Homebrew 安装是否存在潜在问题，并给出一些解决建议:
```shell
brew doctor
```
#### 启动通过 brew 安装的服务，如 nginx,mysql 等。启动后还会自动随开机启动，直到你选择 stop 停止.（缺点是如果发生错误，它也会返回成功，而不是报错）:
```shell
brew services {{start|stop|restart}} {{软件名}}
```
{% endraw %}{% raw %}
<h2 id="brightness">
  <a href="/zh/osx/brightness.html">brightness</a> <a href="#brightness"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 获取或设置所有显示设备的亮度等级.

#### 显示当前亮度:
```shell
brightness -l
```
#### 设置亮度到 100%::
```shell
brightness {{1}}
```
#### 设置亮度到 50%::
```shell
brightness {{0.5}}
```
{% endraw %}{% raw %}
<h2 id="caffeinate">
  <a href="/zh/osx/caffeinate.html">caffeinate</a> <a href="#caffeinate"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 防止 Mac 进入休眠模式.

#### 防止进入休眠模式 , 1 小时内 (3600 秒）:
```shell
caffeinate -u -t {{3600}}
```
#### 在指定命令执行完前，禁止进入休眠:
```shell
caffeinate -s {{命令}}
```
#### 在你按 Ctrl-C 之前禁止进入休眠模式:
```shell
caffeinate -i
```
{% endraw %}{% raw %}
<h2 id="cal">
  <a href="/zh/osx/cal.html">cal</a> <a href="#cal"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打印日历信息.

#### 打印本月日历:
```shell
cal
```
#### 显示上个月，当前月，下个月的日历:
```shell
cal -3
```
#### 显示指定月份的日历（月份为 1-12 月）:
```shell
cal -m {{月}}
```
#### 显示全年日历:
```shell
cal -y
```
#### 显示指定某年的日历（年份为 4 个数字）:
```shell
cal {{年}}
```
#### 显示特定年和月的日历:
```shell
cal {{月}} {{年}}
```
#### 显示指定年的复活节日期:
```shell
ncal -e {{年}}
```
{% endraw %}{% raw %}
<h2 id="carthage">
  <a href="/zh/osx/carthage.html">carthage</a> <a href="#carthage"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Cocoa 应用程序的依赖性管理工具

#### 下载 Cartfile 中提到的所有依赖项的最新版本，并编译它们:
```shell
carthage update
```
#### 仅针对 IOS 平台，升级依赖文件 :
```shell
carthage update --platform ios
```
#### 仅更新依赖，但不编译它们 :
```shell
carthage update --no-build
```
#### 下载并重新生成依赖项的当前版本（不更新它们）:
```shell
carthage bootstrap
```
#### 重新编译特定依赖项 :
```shell
carthage build {{依赖包}}
```
{% endraw %}{% raw %}
<h2 id="chflags">
  <a href="/zh/osx/chflags.html">chflags</a> <a href="#chflags"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 更改文件或文件夹的标志.

#### 给文件设置 hidden（隐藏） 标签:
```shell
chflags {{hidden}} {{文件路径}}
```
#### 取消文件的 hidden 标签:
```shell
chflags {{hidden}} {{文件路径}}
```
#### 递归地给文件夹中每个文件设置 uchg 标志:
```shell
chflags -R {{uchg}} {{文件夹路径}}
```
#### 递归地撤销文件夹中每个文件设置的 uchg 标志:
```shell
chflags -R {{nouchg}} {{文件夹路径}}
```
{% endraw %}{% raw %}
<h2 id="codesign">
  <a href="/zh/osx/codesign.html">codesign</a> <a href="#codesign"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 为 macOS 的应用程序签名.

#### 用证书签名:
```shell
codesign -s "{{公司名称}}" {{路径 / 应用名.app}}
```
#### 验证应用程序的签名:
```shell
codesign -v {{路径 / 应用名.app}}
```
{% endraw %}{% raw %}
<h2 id="compgen">
  <a href="/zh/osx/compgen.html">compgen</a> <a href="#compgen"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于在 bash 中自动完成的内置命令，按两次 tab 键即可调用该命令.

#### 显示所有可以执行的命令:
```shell
compgen -c
```
#### 列出所有别名:
```shell
compgen -a
```
#### 列出所有可以运行的函数:
```shell
compgen -A function
```
#### 列出所有 shell 的保留关键字:
```shell
compgen -k
```
#### 查看以 'ls' 开头的所有可用命令和别名:
```shell
compgen -ac {{ls}}
```
{% endraw %}{% raw %}
<h2 id="date">
  <a href="/zh/osx/date.html">date</a> <a href="#date"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 设置或显示系统日期.

#### 使用默认区域设置的格式显示当前日期 :
```shell
date +"%c"
```
#### 以 UTC 和 ISO 8601 格式显示当前日期:
```shell
date -u +"%Y-%m-%dT%H:%M:%SZ"
```
#### 将当前日期显示为 unix 时间戳（自 1970-01-01 00:00:00 以来的秒数）
```shell
date +%s
```
#### 使用默认格式显示特定日期（格式化指定 UNIX 时间戳）:
```shell
date -r 1473305798
```
{% endraw %}{% raw %}
<h2 id="dd">
  <a href="/zh/osx/dd.html">dd</a> <a href="#dd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 转换并复制文件.

#### 从 isohybrid 文件（如 archlinux-xxx.iso）制作可用于引导系统启动的 USB 驱动器.
```shell
dd if={{文件.iso}} of=/dev/{{usb 设备}}
```
#### 将驱动器克隆到具有 4MB 块的另一个驱动器并忽略错误:
```shell
dd if=/dev/{{源设备}} of=/dev/{{目标设备}} bs=4m conv=noerror
```
#### 使用内核随机驱动程序生成 100 个随机字节的文件:
```shell
dd if=/dev/urandom of={{目标驱动器，接收随机数据文件名}} bs=100 count=1
```
#### 对磁盘的写入性能进行基准测试:
```shell
dd if=/dev/zero of={{1GB 的文件名}} bs=1024 count=1000000
```
{% endraw %}{% raw %}
<h2 id="defaults">
  <a href="/zh/osx/defaults.html">defaults</a> <a href="#defaults"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 读取和写入 macOS 应用程序的用户配置.

#### 读取应用程序选项的系统默认值:
```shell
defaults read {{应用名}} {{选项}}
```
#### 读取应用程序选项的默认值:
```shell
defaults read -app {{应用名}} {{选项}}
```
#### 写入应用程序选项的默认值:
```shell
defaults write {{应用名}} {{选项}} {{- 类型}} {{值}}
```
#### 加速任务控制界面弹出动画 （时间设置为 0.1):
```shell
defaults write com.apple.Dock expose-animation-duration -float 0.1
```
#### 删除应用程序的所有默认值:
```shell
defaults delete {{应用名}}
```
{% endraw %}{% raw %}
<h2 id="diskutil">
  <a href="/zh/osx/diskutil.html">diskutil</a> <a href="#diskutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于管理本地磁盘和卷的实用程序.

#### 列出所有当前可用的磁盘、分区和已装入的卷:
```shell
diskutil list
```
#### 修复卷的文件系统数据结构:
```shell
diskutil repairVolume {{目标卷文件}}
```
#### 卸载卷:
```shell
diskutil unmountDisk {{目标卷文件}}
```
#### 弹出 CD/DVD （先卸载）:
```shell
diskutil eject {{/dev/ 光驱文件名}}
```
{% endraw %}{% raw %}
<h2 id="ditto">
  <a href="/zh/osx/ditto.html">ditto</a> <a href="#ditto"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 复制文件和目录.

#### 用源目录的内容覆盖目标目录的内容:
```shell
ditto {{源文件路径}} {{目标文件路径}}
```
#### 为复制的每个文件打印一行到终端窗口:
```shell
ditto -V {{源文件路径}} {{目标文件路径}}
```
#### 复制给定的文件或目录，同时保留原始文件权限:
```shell
ditto -rsrc {{源文件路径}} {{目标文件路径}}
```
{% endraw %}{% raw %}
<h2 id="dmesg">
  <a href="/zh/osx/dmesg.html">dmesg</a> <a href="#dmesg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将内核消息写入标准输出.

#### 显示内核消息:
```shell
dmesg
```
#### 显示此系统上有多少可用的物理内存:
```shell
dmesg | grep -i memory
```
#### 一次显示一页内核消息:
```shell
dmesg | less
```
{% endraw %}{% raw %}
<h2 id="drutil">
  <a href="/zh/osx/drutil.html">drutil</a> <a href="#drutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 与 DVD 刻录机交互.

#### 从驱动器中弹出磁盘:
```shell
drutil eject
```
#### 将目录作为 iso9660 文件系统刻录到 DVD 上。完成后不验证和弹出:
```shell
drutil burn -noverify -eject -iso9660
```
{% endraw %}{% raw %}
<h2 id="du">
  <a href="/zh/osx/du.html">du</a> <a href="#du"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 磁盘使用率：估计和汇总文件和目录空间使用率.

#### 以给定单位（kb/mb/gb）列出目录和所有子目录的大小:
```shell
du -{{k|m|g}} {{目标文件夹}}
```
#### 以可读形式列出目录和任何子目录的大小（即自动为转换为选择的适当单位 kb|mb|gb）:
```shell
du -h {{目标文件夹}}
```
#### 以可读单位显示目录大小:
```shell
du -sh {{目标文件夹}}
```
#### 列出目录以及其中所有文件和目录的可读大小:
```shell
du -ah {{目标文件夹}}
```
#### 列出一个目录和任何子目录的可读大小，最深可达 n 级:
```shell
du -h -d {{N}} {{目标文件夹}}
```
#### 列出当前目录子目录中所有.jpg 文件的可读大小，并在末尾显示累计总数:
```shell
du -ch */*.jpg
```
{% endraw %}{% raw %}
<h2 id="duti">
  <a href="/zh/osx/duti.html">duti</a> <a href="#duti"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 macOS 上为文档类型和网页设置默认打开的应用程序.

#### 将 Safari 设置为 HTML 文档的默认打开程序:
```shell
duti -s {{com.apple.Safari}} {{public.html}} all
```
#### 将 vlc 设置为扩展名为.m4v 的文件的默认查看器:
```shell
duti -s {{org.videolan.vlc}} {{m4v}} viewer
```
#### 将 Finder 设置为 ftp:// URL 访问的应用:
```shell
duti -s {{com.apple.Finder}} {{ftp}}
```
#### 显示有关给定扩展名的默认应用程序的信息:
```shell
duti -x {{ext}}
```
#### 显示给定的 UTI 对应默认的处理程序:
```shell
duti -d {{uti}}
```
#### 显示给定 UTI 对应所有的处理程序:
```shell
duti -l {{uti}}
```
{% endraw %}{% raw %}
<h2 id="eval">
  <a href="/zh/osx/eval.html">eval</a> <a href="#eval"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在当前 shell 中以单个命令的形式执行参数，并返回其结果.

#### 使用 'foo' 做为参数调用 `echo`:
```shell
eval "{{echo foo}}"
```
#### 在当前 shell 程序中设置变量:
```shell
eval "{{foo=bar}}"
```
{% endraw %}{% raw %}
<h2 id="export">
  <a href="/zh/osx/export.html">export</a> <a href="#export"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 命令为当前 shell 中的子进程进行环境变量设置.

#### 设置为新的环境变量:
```shell
export {{某变量名}}={{值}}
```
#### 删除环境变量:
```shell
export -n {{某变量名}}
```
#### 给 PATH 追加新的路径进去:
```shell
export PATH=$PATH:{{追加的 path 路径}}
```
{% endraw %}{% raw %}
<h2 id="fc">
  <a href="/zh/osx/fc.html">fc</a> <a href="#fc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打开最近的命令并编辑它.

#### 在系统默认编辑器中打开:
```shell
fc
```
#### 指定要使用的的编辑器:
```shell
fc -e {{'emacs'}}
```
#### 从历史记录中列出最近的命令:
```shell
fc -l
```
{% endraw %}{% raw %}
<h2 id="feh">
  <a href="/zh/osx/feh.html">feh</a> <a href="#feh"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 轻量级图像查看工具.

#### 查看本地图像或使用 URL:
```shell
feh {{图片路径}}
```
#### 递归查看图像:
```shell
feh --recursive {{图片路径}}
```
#### 使用无边框窗口查看图像:
```shell
feh --borderless {{图片路径}}
```
#### 在浏览完最后一个图像之后退出:
```shell
feh --cycle-once {{图片路径}}
```
#### 设置幻灯片放映周期延迟时间（秒）:
```shell
feh --slideshow-delay {{秒}} {{图片路径}}
```
#### 设置墙纸（居中、填充、最大化、缩放或平铺）:
```shell
feh --bg-{{center|fill|max|scale|tile}} {{图片路径}}
```
{% endraw %}{% raw %}
<h2 id="file">
  <a href="/zh/osx/file.html">file</a> <a href="#file"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 确定文件类型.

#### 提供指定文件类型的描述，对于没有文件扩展名的文件可以正常工作:
```shell
file {{文件名}}
```
#### 查看压缩文件并确定其中的文件类型:
```shell
file -z {{xxx.zip}}
```
#### 允许文件与特殊文件或设备文件一起使用:
```shell
file -s {{文件名}}
```
#### 不要在第一个文件类型匹配时停止；继续执行直到文件结束:
```shell
file -k {{文件名}}
```
#### 确定文件的 mime 编码类型:
```shell
file -I {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="fsck">
  <a href="/zh/osx/fsck.html">fsck</a> <a href="#fsck"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 检查或修复文件系统的完整性，运行命令时应卸载文件系统.
> 它是一个包装器，包含 `fsck_hfs`, `fsck_apfs`, `fsck_msdos`, `fsck_exfat`, `fsck_udf` 作为可选.

#### 检查文件系统 /dev/sda，报告损坏的块:
```shell
fsck {{/dev/sda}}
```
#### 仅当文件系统 /dev/sda 是干净的时才检查它，报告任何损坏的块并以交互方式让用户选择修复每个块:
```shell
fsck -f {{/dev/sda}}
```
#### 仅当文件系统 /dev/sda 干净时才检查它，报告任何损坏的块并自动修复它们:
```shell
fsck -fy {{/dev/sda}}
```
#### 检查文件系统 /dev/sda, 报告是否已完全卸载:
```shell
fsck -q {{/dev/sda}}
```
{% endraw %}{% raw %}
<h2 id="getfileinfo">
  <a href="/zh/osx/getfileinfo.html">GetFileInfo</a> <a href="#getfileinfo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 获取有关 HFS+ 目录中文件的信息.

#### 显示有关给定文件的信息:
```shell
GetFileInfo {{路径/文件名}}
```
#### 显示给定文件的创建日期和时间:
```shell
GetFileInfo -d {{路径/文件名}}
```
#### 显示给定文件的上次修改日期和时间:
```shell
GetFileInfo -m {{路径/文件名}}
```
#### 显示给定文件的创建者:
```shell
GetFileInfo -c {{路径/文件名}}
```
{% endraw %}{% raw %}
<h2 id="head">
  <a href="/zh/osx/head.html">head</a> <a href="#head"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 输出文件的开头部分.

#### 输出文件的前几行:
```shell
head -n {{行数}} {{文件名}}
```
#### 输出文件的前几个字节:
```shell
head -c {{字节数}} {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="hexdump">
  <a href="/zh/osx/hexdump.html">hexdump</a> <a href="#hexdump"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个 ASCII、十进制、十六进制、八进制转换查看工具.

#### 打印文件的十六进制表示形式:
```shell
hexdump {{文件}}
```
#### 以十六进制显示输入偏移量，并在最后两列中显示其 ASCII 表示形式:
```shell
hexdump -C {{文件}}
```
#### 显示文件的十六进制表示，但只解释输入的 N 个字节:
```shell
hexdump -C -n{{字节数}} {{文件}}
```
{% endraw %}{% raw %}
<h2 id="hostname">
  <a href="/zh/osx/hostname.html">hostname</a> <a href="#hostname"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或设置系统的主机名.

#### 显示本机的主机名:
```shell
hostname
```
#### 设置本机主机名:
```shell
hostname {{新主机名}}
```
{% endraw %}{% raw %}
<h2 id="imgcat">
  <a href="/zh/osx/imgcat.html">imgcat</a> <a href="#imgcat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 直接在命令行上显示图像的实用程序.
> 需要兼容的终端软件，如 ITerm2.

#### 在命令行上显示图像:
```shell
imgcat {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="launchctl">
  <a href="/zh/osx/launchctl.html">launchctl</a> <a href="#launchctl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于启动守护程序（系统范围的服务）和启动代理程序（每个用户程序）的命令行界面，该界面指向苹果的`launchd` 管理工具.
> `launchd`加载放置在适当位置的基于 XML 的`*.plist`文件，并根据其定义的计划运行相应的命令.

#### 每当用户登录时，自动将 plist 文件加载到 `launchd` :
```shell
launchctl load ~/Library/LaunchAgents/{{我的脚本}}.plist
```
#### 激活需要 root 权限才能运行和 / 或在任何用户登录时都应加载的脚本（注意路径中不能有`~`）:
```shell
sudo launchctl load /Library/LaunchAgents/{{root 脚本}}.plist
```
#### 激活一个系统范围的守护程序，以便在系统启动时加载（即使没有用户登录也会加载）:
```shell
sudo launchctl load /Library/LaunchDaemons/{{系统脚本}}.plist
```
#### 显示所有加载的代理 / 守护进程，如果它们指定的进程当前正在运行，则显示 pid，如果停止那么返回了它们上次运行的时间和退出代码:
```shell
launchctl list
```
#### 卸载当前加载的脚本，例如进行更改（注意：重新启动和 / 或登录后，plist 文件将自动加载到`launchd`）:
```shell
launchctl unload ~/Library/LaunchAgents/{{我的脚本}}.plist
```
#### 手动运行一个已知的（已加载的）脚本 / 守护进程，即使它不是正确的时间（注意：此命令使用脚本的标签，而不是文件名）:
```shell
launchctl start {{我的脚本}}
```
#### 手动终止与已知脚本 / 守护进程关联的进程（如果该进程正在运行）:
```shell
launchctl stop {{我的脚本}}
```
{% endraw %}{% raw %}
<h2 id="lldb">
  <a href="/zh/osx/lldb.html">lldb</a> <a href="#lldb"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> LLVM 低级调试器.

#### 调试可执行文件:
```shell
lldb {{可执行的命令}}
```
#### 将 `lldb` 附加到具有给定 PID 的正在运行的进程:
```shell
lldb -p {{进程号 PID}}
```
#### 等待使用给定名称的进程启动，然后附加到该进程上:
```shell
lldb -w -n {{进程名}}
```
{% endraw %}{% raw %}
<h2 id="locate">
  <a href="/zh/osx/locate.html">locate</a> <a href="#locate"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 快速查找文件名.

#### 在数据库中查找关键字。注意：数据库定期重新更新（通常每周或每天）:
```shell
locate {{关键字}}
```
#### 按文件名查找文件（不包含填充字符的模式被解释为 `*关键字*`）:
```shell
locate */{{文件名}}
```
#### 重新建立文件数据索引数据库。如果要查找最近添加的文件，则需要执行此操作:
```shell
sudo /usr/libexec/locate.updatedb
```
{% endraw %}{% raw %}
<h2 id="logger">
  <a href="/zh/osx/logger.html">logger</a> <a href="#logger"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 向系统日志增加记录 (/var/log/syslog).

#### 向系统日志增加记录:
```shell
logger {{消息内容}}
```
#### 从 stdin 获取输入并记录到系统日志 syslog:
```shell
echo {{记录内容}} | logger
```
#### 将输出发送到在给定端口上运行的远程系统日志服务器。默认端口为 514:
```shell
echo {{记录内容}} | logger -h {{服务器名}} -P {{端口}}
```
#### 对记录的每一行使用特定的标签。默认值是登录用户的名:
```shell
echo {{记录内容}} | logger -t {{标签}}
```
#### 以给定的错误等级记录消息。默认是 `user.notice`. 使用 `man logger` 查询所有可选等级:
```shell
echo {{记录内容}} | logger -p {{user.warning}}
```
{% endraw %}{% raw %}
<h2 id="look">
  <a href="/zh/osx/look.html">look</a> <a href="#look"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 查找已排序的文件行（注意，必须是已排序的文件）.

#### 它开始寻找一个给定的前缀:
```shell
look {{前缀}} {{文件}}
```
#### 查找行，忽略大小写:
```shell
look -f {{前缀}} {{文件}}
```
{% endraw %}{% raw %}
<h2 id="m">
  <a href="/zh/osx/m.html">m</a> <a href="#m"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> macOS 上的瑞士军刀.

#### 获取电池状态:
```shell
m battery status
```
#### 关闭蓝牙:
```shell
m bluetooth off
```
#### 列出可用于格式化的文件系统:
```shell
m disk filesystems
```
#### 启用 Dock（桌面程序坞） 的自动隐藏功能:
```shell
m dock autohide YES
```
#### 禁用防火墙:
```shell
m firewall disable
```
{% endraw %}{% raw %}
<h2 id="md5">
  <a href="/zh/osx/md5.html">md5</a> <a href="#md5"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 计算 MD5 加密和校验.

#### 计算一个文件的 MD5 校验值:
```shell
md5 {{文件名}}
```
#### 计算多个文件的 MD5 校验值:
```shell
md5 {{文件名 1}} {{文件名 2}}
```
#### 仅输出 MD5 校验值（无文件名）:
```shell
md5 -q {{文件名}}
```
#### 打印给定字符串的 MD5 校验值:
```shell
md5 -s {{字符串}}
```
{% endraw %}{% raw %}
<h2 id="mdfind">
  <a href="/zh/osx/mdfind.html">mdfind</a> <a href="#mdfind"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 列出与给定查询匹配的文件.

#### 按文件名查找文件:
```shell
mdfind -name {{文件}}
```
#### 按内容查找文件:
```shell
mdfind {{查找的字符串}}
```
#### 在给定目录中查找包含字符串的文件:
```shell
mdfind -onlyin {{目录}} {{字符串}}
```
{% endraw %}{% raw %}
<h2 id="mdutil">
  <a href="/zh/osx/mdutil.html">mdutil</a> <a href="#mdutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 Spotlight（聚焦搜索） 用于搜索的索引数据.

#### 显示指定卷 ('/') 的索引状态:
```shell
mdutil -s {{/}}
```
#### 打开 / 关闭给定卷的 Spotlight 索引:
```shell
mdutil -i {{on|off}} {{指定卷文件夹}}
```
#### 清除索引数据并重新建立索引:
```shell
mdutil -E {{指定卷文件夹}}
```
{% endraw %}{% raw %}
<h2 id="mkfile">
  <a href="/zh/osx/mkfile.html">mkfile</a> <a href="#mkfile"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建一个或多个任意大小的空文件.

#### 创建一个 15 千字节的空文件:
```shell
mkfile -n {{15k}} {{文件名}}
```
#### 创建给定大小和单位的文件 (bytes, KB, MB, GB):
```shell
mkfile -n {{大小}}{{b|k|m|g}} {{文件名}}
```
#### 创建两个 4 兆字节的文件:
```shell
mkfile -n {{4m}} {{文件名 1}} {{文件名 2}}
```
{% endraw %}{% raw %}
<h2 id="n">
  <a href="/zh/osx/n.html">n</a> <a href="#n"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于管理多个节点版本的工具.

#### 安装给定版本的节点。如果版本已经安装，它将被激活:
```shell
n {{版本}}
```
#### 显示已安装的版本并以交互方式激活其中一个版本:
```shell
n
```
#### 删除一个版本:
```shell
n rm {{版本}}
```
#### 使用给定版本执行文件:
```shell
n use {{版本}} {{文件.js}}
```
#### 输出指定版本的二进制:
```shell
n bin {{版本}}
```
{% endraw %}{% raw %}
<h2 id="netstat">
  <a href="/zh/osx/netstat.html">netstat</a> <a href="#netstat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示与网络相关的信息，如打开的连接、打开的套接字端口等.
> 更多信息: <https://www.unix.com/man-page/osx/1/netstat>.

#### 列出所有端口:
```shell
netstat -a
```
#### 列出所有被侦听端口:
```shell
netstat -l
```
#### 列出侦听的 TCP 端口:
```shell
netstat -t
```
#### 显示监听给定协议监听的 PID 和程序名:
```shell
netstat -p {{协议}}
```
#### 打印路由表:
```shell
netstat -nr
```
{% endraw %}{% raw %}
<h2 id="networksetup">
  <a href="/zh/osx/networksetup.html">networksetup</a> <a href="#networksetup"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 网络系统首选项配置工具.

#### 列出可用的网络服务源（以太网、Wi-Fi、蓝牙等）:
```shell
networksetup -listallnetworkservices
```
#### 显示特定网络设备的配置信息:
```shell
networksetup -getinfo "{{Wi-Fi}}"
```
#### 获取当前连接的 Wi-Fi 网络名称（Wi-Fi 设备通常为 en0 或 en1）:
```shell
networksetup -getairportnetwork {{en0}}
```
#### 连接到给定的 Wi-Fi 网络 Connect to a particular Wi-Fi network:
```shell
networksetup -setairportnetwork {{en0}} "{{无线网 SSID}}" {{密码}}
```
{% endraw %}{% raw %}
<h2 id="oathtool">
  <a href="/zh/osx/oathtool.html">oathtool</a> <a href="#oathtool"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> OATH 一次性密码工具.

#### 生成 TOTP 令牌（行为类似于 Google Authenticator）:
```shell
oathtool --totp --base32 {{密码}}
```
#### 根据给定时间产生特定的 TOTP 令牌:
```shell
oathtool --totp --now {{2004-02-29 16:21:42}} --base32 {{密码}}
```
#### 验证 TOTP 令牌:
```shell
oathtool --totp --base32 {{密码}} {{令牌}}
```
{% endraw %}{% raw %}
<h2 id="open">
  <a href="/zh/osx/open.html">open</a> <a href="#open"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打开文件、目录和应用程序.

#### 使用系统关联的应用程序打开文件:
```shell
open {{filename.extension}}
```
#### 运行图形化的 macOS 应用程序:
```shell
open -a {{应用程序名}}
```
#### 运行指定 包名 的图形化 macOS 应用程序（请参阅`OSascript`命令，查询如何获取应用程序的 包名）:
```shell
open -b {{com.domain.application 应用程序包名}}
```
#### 在"访达 (finder)"中打开当前文件夹:
```shell
open .
```
#### 打开"访达 (finder)", 并且给出指定文件:
```shell
open -R {{文件路径}}
```
#### 使用系统默认应用程序，打开当前目录中所有给定扩展名的文件:
```shell
open {{*.extension}}
```
{% endraw %}{% raw %}
<h2 id="opensnoop">
  <a href="/zh/osx/opensnoop.html">opensnoop</a> <a href="#opensnoop"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 跟踪系统中打开的文件标识符.

#### 输出当前系统内被打开的所有文件:
```shell
sudo opensnoop
```
#### 跟踪给定进程名，打开的所有文件:
```shell
sudo opensnoop -n {{进程名}}
```
#### 跟踪给定 PID（进程号）, 打开的所有文件:
```shell
sudo opensnoop -p {{PID 进程号}}
```
#### 跟踪打开了指定文件的继承:
```shell
sudo opensnoop -f {{路径 / 文件}}
```
{% endraw %}{% raw %}
<h2 id="osascript">
  <a href="/zh/osx/osascript.html">osascript</a> <a href="#osascript"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在命令行中运行指定的 AppleScript 或 JavaScript 脚本程序.

#### 运行一个 AppleScript 命令:
```shell
osascript -e '{{say "你好世界"}}'
```
#### 运行多条 AppleScript 命令:
```shell
osascript -e '{{say "你好"}}' -e '{{say "世界"}}'
```
#### 运行一个已编译的脚本 (`*.scpt`), 包脚本 (`*.scptd`), 或明文的 (`*.applescript`) AppleScript 文件:
```shell
osascript {{目录 / 脚本文件.scpt}}
```
#### 获取应用程序的包名 （这个包名，可以用在命令 `open -b` 中）:
```shell
osascript -e 'id of app "{{应用程序名}}"'
```
#### 运行一个 JavaScript 命令:
```shell
osascript -l JavaScript -e '{{console.log("你好世界！");}}'
```
#### 运行 JavaScript 文件:
```shell
osascript -l JavaScript {{路径 / 文件名.js}}
```
{% endraw %}{% raw %}
<h2 id="pbcopy">
  <a href="/zh/osx/pbcopy.html">pbcopy</a> <a href="#pbcopy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将标准输出放入剪贴板（命令行里的 cmd + C).

#### 将文件的内容放入剪贴板:
```shell
pbcopy < {{文件}}
```
#### 将命令的执行结果放入剪贴板:
```shell
find . -type t -name "*.png" | pbcopy
```
{% endraw %}{% raw %}
<h2 id="pbpaste">
  <a href="/zh/osx/pbpaste.html">pbpaste</a> <a href="#pbpaste"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将剪贴板的内容发送到标准输出（命令行）.

#### 将剪贴板的内容写入文件:
```shell
pbpaste > {{文件}}
```
#### 将剪贴板的内容用作命令的输入:
```shell
pbpaste | grep foo
```
{% endraw %}{% raw %}
<h2 id="pdfgrep">
  <a href="/zh/osx/pdfgrep.html">pdfgrep</a> <a href="#pdfgrep"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 PDF 文件中搜索文本.

#### 在 PDF 中查找与关键词匹配的行:
```shell
pdfgrep {{关键词}} {{文件.pdf}}
```
#### 包含每个匹配行的文件名和页码:
```shell
pdfgrep --with-filename --page-number {{关键词}} {{文件.pdf}}
```
#### 对以 "foo" 开头关键词搜索，返回前 3 个匹配项，不区分大小写:
```shell
pdfgrep --max-count {{3}} --ignore-case {{'^foo'}} {{文件.pdf}}
```
#### 在当前目录中扩展名为.pdf 的文件中递归查找关键词:
```shell
pdfgrep --recursive {{关键词}}
```
#### 在与当前目录中特定文件名 "*book.pdf" 匹配的文件上递归查找关键词:
```shell
pdfgrep --recursive --include {{'*book.pdf'}} {{关键词}}
```
{% endraw %}{% raw %}
<h2 id="ping">
  <a href="/zh/osx/ping.html">ping</a> <a href="#ping"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 向网络主机发送 ICMP 回显请求数据包.

#### Ping 指定的主机:
```shell
ping {{主机}}
```
#### 对主机执行指定定次数的 ping 操作:
```shell
ping -c {{次数}} {{主机}}
```
#### ping `主机` , 指定请求之间的间隔（以`秒`为单位）（默认为 1 秒）:
```shell
ping -i {{秒}} {{主机}}
```
#### Ping `主机`, 但不尝试查找地址的符号名:
```shell
ping -n {{主机}}
```
#### ping `主机` 并在收到数据包时响铃（如果您的终端支持）:
```shell
ping -a {{主机}}
```
#### ping `主机` 并打印接收数据包的时间（此选项是 Apple 的附加项）:
```shell
ping --apple-time {{主机}}
```
{% endraw %}{% raw %}
<h2 id="pmset">
  <a href="/zh/osx/pmset.html">pmset</a> <a href="#pmset"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 配置 macOS 电源管理设置，就像在系统首选项 > 节能程序中一样.
> 修改设置的命令必须以 `sudo` 开头.

#### 显示当前电源管理设置:
```shell
pmset -g
```
#### 显示当前电源和电池电量:
```shell
pmset -g batt
```
#### 当充电器通电时，将显示器设置为从不休眠:
```shell
sudo pmset -c displaysleep 0
```
#### 使用电池电源 15 分钟后将显示器设置为休眠:
```shell
sudo pmset -b displaysleep 15
```
#### 安排计算机在每个工作日上午 9 点自动唤醒:
```shell
sudo pmset repeat wake MTWRF 09:00:00
```
#### 还原为系统默认值:
```shell
sudo pmset -a displaysleep 10 disksleep 10 sleep 30 womp 1
```
{% endraw %}{% raw %}
<h2 id="pod">
  <a href="/zh/osx/pod.html">pod</a> <a href="#pod"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Swift 和 Objective-C Cocoa 项目的依赖关系管理.

#### 为当前项目初始化包含默认内容的 podfile:
```shell
pod init
```
#### 下载并安装 pod 文件中定义的所有 pod（以前未安装）:
```shell
pod install
```
#### 列出所有可用的 pod:
```shell
pod list
```
#### 显示过时的 pod（当前安装的 pod）:
```shell
pod outdated
```
#### 将当前安装的所有 pod 更新到其最新版本:
```shell
pod update
```
#### 将特定（以前安装的）pod 更新为其最新版本:
```shell
pod update {{pod_名}}
```
#### 从 Xcode 项目中删除 CocoaPods:
```shell
pod deintegrate {{xcode_项目}}
```
{% endraw %}{% raw %}
<h2 id="popd">
  <a href="/zh/osx/popd.html">popd</a> <a href="#popd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 通过 pushd shell 内置程序删除目录堆栈中的目录.

#### 从堆栈中删除顶部目录，并用 `cd` 跳转到该目录:
```shell
popd
```
#### 删除第 n 个目录（从零开始，以用 `dirs` 打印的列表左侧开始）:
```shell
popd +N
```
#### 删除第 n 个目录（从零开始，以用 `dirs` 打印的列表右侧开始）:
```shell
popd -N
```
{% endraw %}{% raw %}
<h2 id="port">
  <a href="/zh/osx/port.html">port</a> <a href="#port"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> macOS 包管理器软件（类似 brew).

#### 搜索包:
```shell
port search {{搜索的包名}}
```
#### 安装软件包:
```shell
sudo port install {{报名}}
```
#### 列出已安装的软件包:
```shell
port installed
```
#### 更新 port 自身，并获取可用包的最新列表:
```shell
sudo port selfupdate
```
#### 升级过时的软件包:
```shell
sudo port upgrade outdated
```
#### 删除已安装的软件包的旧版本:
```shell
sudo port uninstall inactive
```
{% endraw %}{% raw %}
<h2 id="pushd">
  <a href="/zh/osx/pushd.html">pushd</a> <a href="#pushd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将目录放在堆栈上，以便以后访问.
> 另请参阅 `popd` 命令说明，以切换回原始目录.

#### 切换到目录并将其添加到堆栈上:
```shell
pushd {{directory}}
```
#### 切换堆栈上的第一个和第二个目录:
```shell
pushd
```
#### 通过使第 5 个元素成为堆栈的顶部来旋转堆栈:
```shell
pushd +4
```
{% endraw %}{% raw %}
<h2 id="pwgen">
  <a href="/zh/osx/pwgen.html">pwgen</a> <a href="#pwgen"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 生成可拼写发音的密码.

#### 生成指定长度的随机密码:
```shell
pwgen -y {{长度}}
```
#### 生成安全、难以记忆的密码:
```shell
pwgen -s {{长度}}
```
#### 生成至少包含一个大写字母的密码:
```shell
pwgen -c {{长度}}
```
{% endraw %}{% raw %}
<h2 id="qlmanage">
  <a href="/zh/osx/qlmanage.html">qlmanage</a> <a href="#qlmanage"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> QuickLook 服务器工具.

#### 快速显示一个或多个文件:
```shell
qlmanage -p {{文件名}} {{文件名 2}}
```
#### 计算生成当前目录中所有 jpeg 文件的缩略图，300px 宽 png 格式，并将它们放在一个指定目录中:
```shell
qlmanage {{*.jpg}} -t -s {{300}} {{指定目录}}
```
#### 重置快速查看:
```shell
qlmanage -r
```
{% endraw %}{% raw %}
<h2 id="reboot">
  <a href="/zh/osx/reboot.html">reboot</a> <a href="#reboot"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 重启系统.

#### 立刻重启:
```shell
sudo reboot
```
#### 立即重启，而无需正常关机:
```shell
sudo reboot -q
```
{% endraw %}{% raw %}
<h2 id="route">
  <a href="/zh/osx/route.html">route</a> <a href="#route"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 手动操作路由表.
> 需要 root 权限.

#### 通过网关向目标添加路由:
```shell
sudo route add {{路由 ip 地址}} {{网关地址}}
```
#### 通过网关向 子网 / 24 添加路由:
```shell
sudo route add {{子网 ip}}/24 {{网关地址}}
```
#### 在测试模式下运行（不做任何操作，只打印）:
```shell
sudo route -t add {{路由 ip 地址}}/24 {{网关地址}}
```
#### 删除所有路由:
```shell
sudo route flush
```
#### 删除特定路由:
```shell
sudo route delete {{路由 ip 地址}}/24
```
#### 查找并显示目标的路由（主机名或 IP 地址）:
```shell
sudo route get {{目标}}
```
{% endraw %}{% raw %}
<h2 id="rubocop">
  <a href="/zh/osx/rubocop.html">rubocop</a> <a href="#rubocop"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 格式化 Ruby 文件.

#### 检查当前目录中的所有文件（包括子目录）:
```shell
rubocop
```
#### 检查一个或多个指定文件或目录:
```shell
rubocop {{目录 / 文件名}} {{目录 /}}
```
#### 将输出写入指定文件:
```shell
rubocop --out {{目录 / 文件名}}
```
#### 查看规则列表（格式化规则）:
```shell
rubocop --show-cops
```
#### 排除格式规则:
```shell
rubocop --except {{规则 1}} {{规则 2}}
```
#### 只运行指定的规则:
```shell
rubocop --only {{规则 1}} {{规则 2}}
```
#### 自动更正文件（实验）:
```shell
rubocop --auto-correct
```
{% endraw %}{% raw %}
<h2 id="say">
  <a href="/zh/osx/say.html">say</a> <a href="#say"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将文本转换为语音.

#### 大声说出一个句子:
```shell
say "{{你好，世界！}}"
```
#### 播放文本文件内容音频:
```shell
say -f {{文件名.txt}}
```
#### 用自定义的语音和语音速率说出一个句子:
```shell
say -v {{语音库名}} -r {{每分钟多少词}} "{{你好，我可以说中文.}}"
```
#### 列出可用的语音库:
```shell
say --voice="?"
```
#### 创建文本的音频文件:
```shell
say -o {{文件名.aiff}} "{{你好，请将录音内容输出到文件.}}"
```
{% endraw %}{% raw %}
<h2 id="scutil">
  <a href="/zh/osx/scutil.html">scutil</a> <a href="#scutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理系统配置参数.
> 设置配置时必须是 root 权限.

#### 显示 DNS 配置:
```shell
scutil --dns
```
#### 显示代理配置:
```shell
scutil --proxy
```
#### 获取计算机名称:
```shell
scutil --get ComputerName
```
#### 设置计算机名称:
```shell
sudo scutil --set ComputerName {{我的计算机名}}
```
#### 获取主机名 ( HostName ):
```shell
scutil --get HostName
```
#### 设置主机名:
```shell
scutil --set HostName {{hostname}}
```
{% endraw %}{% raw %}
<h2 id="sed">
  <a href="/zh/osx/sed.html">sed</a> <a href="#sed"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 以可用脚本的来批量编辑文本.
> 更多信息： <https://ss64.com/osx/sed.html>.

#### 替换文件中第一个出现的字符串，并打印结果:
```shell
sed 's/{{查找内容}}/{{替换内容}}/' {{文件名}}
```
#### 替换文件中所有符合正则表达式的部分:
```shell
sed -E 's/{{正则表达式}}/{{替换内容}}/g' {{文件名}}
```
#### 替换文件中所有出现的字符串，覆盖文件（直接覆盖文件）:
```shell
sed --in-place='' 's/{{查找内容}}/{{替换内容}}/g' {{文件名}}
```
#### 仅替换与行模式（一种搜索条件）匹配的行内容:
```shell
sed '/{{行模式}}/s/{{查找内容}}/{{替换内容}}/' {{文件名}}
```
#### 只打印第 n 行到下一行之间的文本:
```shell
sed -n '{{行号}},/^$/p' {{文件名}}
```
#### 将多个查找替换表达式应用于文件:
```shell
sed -e 's/{{查找内容}}/{{替换内容}}/' -e 's/{{查找内容}}/{{替换内容}}/' {{文件名}}
```
#### 将分隔符 / 替换为查找或替换模式中没有用到的的任何其他字符，例如 # （用于查找或替换内容中使用了 / 的情况）:
```shell
sed 's#{{查找内容}}#{{替换内容}}#' {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="shuf">
  <a href="/zh/osx/shuf.html">shuf</a> <a href="#shuf"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 生成随机排列.

#### 随机化文件中的行顺序并输出结果:
```shell
shuf {{文件名}}
```
#### 只输出结果的前 5 条:
```shell
shuf -n {{5}} {{文件名}}
```
#### 将结果输出写入另一个文件:
```shell
shuf {{文件名}} -o {{输出_文件名}}
```
#### 生成范围 (1-10) 内的随机数:
```shell
shuf -i {{1-10}}
```
{% endraw %}{% raw %}
<h2 id="shutdown">
  <a href="/zh/osx/shutdown.html">shutdown</a> <a href="#shutdown"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 关闭并重新启动系统.

#### 立即关机:
```shell
shutdown -h now
```
#### 立即休眠:
```shell
shutdown -s now
```
#### 立即重启:
```shell
shutdown -r now
```
#### 倒计时 5 分钟重启:
```shell
shutdown -r +{{5}}
```
{% endraw %}{% raw %}
<h2 id="sips">
  <a href="/zh/osx/sips.html">sips</a> <a href="#sips"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 苹果的处理文件脚本系统.
> 光栅 / 查询图像 和 颜色同步 ICC 配置文件.

#### S 指定一个输出目录，这样原始文件就不会被修改:
```shell
sips --out {{目标 / 文件夹 / 输出文件夹}}
```
#### 以指定的大小对图像重新采样，图像纵横比可能会更改:
```shell
sips -z {{1920}} {{300}} {{图片文件。扩展名}}
```
#### 对图像重新取样，使高度和宽度不大于指定的大小（注意大写 Z）:
```shell
sips -Z {{1920}} {{300}} {{图片文件。扩展名}}
```
#### 对目录中的所有图像重新取样，以适应 960px 的宽度（保持纵横比）:
```shell
sips --resampleWidth {{960}} {{目标 / 文件夹 / 所有图片文件}}
```
#### 将图像从 CMYK 转换为 RGB:
```shell
sips --matchTo '/System/Library/ColorSync/Profiles/Generic RGB Profile.icc' {{目标 / 文件夹 / 图片。扩展}} {{目标 / 文件夹 / 输出文件夹}}
```
#### 从图像中删除 ColorSync ICC 配置:
```shell
sips -d profile --deleteColorManagementProperties {{目标 / 文件夹 / 图片。扩展}}
```
{% endraw %}{% raw %}
<h2 id="softwareupdate">
  <a href="/zh/osx/softwareupdate.html">softwareupdate</a> <a href="#softwareupdate"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 通过命令行更新 macOS 应用商店中应用程序的工具.

#### 列出所有可用的更新:
```shell
softwareupdate -l
```
#### 下载并安装所有更新:
```shell
softwareupdate -ia
```
#### 下载并安装所有推荐的更新:
```shell
softwareupdate -ir
```
#### 下载并安装特定的应用程序:
```shell
softwareupdate -i {{更新应用程序名}}
```
{% endraw %}{% raw %}
<h2 id="split">
  <a href="/zh/osx/split.html">split</a> <a href="#split"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 把一个文件拆分成几块.

#### 分割一个文件，每个分割部分有 10 行（除了最后一个）:
```shell
split -l {{10}} {{文件名}}
```
#### 用正则表达式拆分文件。匹配行将是下一个输出文件的第一行:
```shell
split -p {{cat|^[dh]og}} {{文件名}}
```
#### 拆分一个文件，每个拆分中有 512 个字节（除了最后一个文件，使用 512K 表示 Kb，512M 表示 Mb）:
```shell
split -b {{512}} {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="ssh-add">
  <a href="/zh/osx/ssh-add.html">ssh-add</a> <a href="#ssh-add"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 ssh 代理中管理加载的 ssh 密钥.
> 需要确保 ssh 代理已启动并正在运行以加载其中的密钥.

#### 将 `~/.ssh` 中的默认 ssh 密钥添加到 `ssh` 代理:
```shell
ssh-add
```
#### 向 ssh 代理添加指定密钥:
```shell
ssh-add {{目录 / 私钥文件}}
```
#### 列出当前加载的密钥的指纹:
```shell
ssh-add -l
```
#### 从 ssh 代理中删除密钥:
```shell
ssh-add -d {{目录 / 私钥文件}}
```
#### 从 ssh 代理中删除所有当前已有的密钥:
```shell
ssh-add -D
```
#### 向 ssh 代理和密钥链添加密钥:
```shell
ssh-add -K {{目录 / 私钥文件}}
```
{% endraw %}{% raw %}
<h2 id="sshuttle">
  <a href="/zh/osx/sshuttle.html">sshuttle</a> <a href="#sshuttle"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 通过 ssh 连接传输流量的透明代理服务器.
> 不需要管理员或远程 ssh 服务器上的任何特殊设置.

#### 通过远程 ssh 服务器转发所有 IPv4 TCP 流量:
```shell
sshuttle --remote={{用户名}}@{{服务器名}} {{0.0.0.0/0}}
```
#### 转发所有 IPv4 TCP 和 DNS 流量:
```shell
sshuttle --dns --remote={{用户名}}@{{服务器名}} {{0.0.0.0/0}}
```
#### 使用 tproxy 方法转发所有 IPv4 和 IPv6 流量:
```shell
sudo sshuttle --method=tproxy --remote={{用户名}}@{{服务器名}} {{0.0.0.0/0}} {{::/0}} --exclude={{你本地 IP 地址}} --exclude={{SSH 服务器的 IP 地址}}
```
{% endraw %}{% raw %}
<h2 id="stat">
  <a href="/zh/osx/stat.html">stat</a> <a href="#stat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示文件状态.

#### 显示文件属性，如大小、权限、创建和访问日期等:
```shell
stat {{文件}}
```
#### 与上面相同，但更详细（更类似于 Linux 的 `stat`）:
```shell
stat -x {{文件}}
```
#### 只显示文件权限:
```shell
stat -f %Mp%Lp {{文件}}
```
#### 显示文件的所有者和所属组:
```shell
stat -f "%Su %Sg" {{文件}}
```
#### 以字节为单位显示文件的大小:
```shell
stat -f "%z %N" {{文件}}
```
{% endraw %}{% raw %}
<h2 id="sw_vers">
  <a href="/zh/osx/sw_vers.html">sw_vers</a> <a href="#sw_vers"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打印 macOS 软件版本信息.

#### 打印 macOS 版本:
```shell
sw_vers -productVersion
```
#### 打印 macOS 构建版本:
```shell
sw_vers -buildVersion
```
{% endraw %}{% raw %}
<h2 id="sysctl">
  <a href="/zh/osx/sysctl.html">sysctl</a> <a href="#sysctl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 访问内核状态信息.

#### 显示所有可用变量及其值:
```shell
sysctl -a
```
#### 显示 Apple 型号标识符:
```shell
sysctl -n hw.model
```
#### 显示 CPU 模型:
```shell
sysctl -n machdep.cpu.brand_string
```
#### 显示可用的 CPU 功能 (MMX, SSE, SSE2, SSE3, AES, 等）:
```shell
sysctl -n machdep.cpu.features
```
#### 设置一个可更改的内核状态变量:
```shell
sysctl -w {{部分。可修改的变量}}={{值}}
```
{% endraw %}{% raw %}
<h2 id="system_profiler">
  <a href="/zh/osx/system_profiler.html">system_profiler</a> <a href="#system_profiler"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 报告系统硬件和软件配置.

#### 显示可由 System Profiler.app 打开的完整系统资源报告:
```shell
system_profiler -xml > MyReport.spx
```
#### 显示硬件概述（型号、CPU、内存、串行等）:
```shell
system_profiler SPHardwareDataType
```
#### 打印系统序列号:
```shell
system_profiler SPHardwareDataType|grep "Serial Number (system)" |awk '{print $4}'
```
{% endraw %}{% raw %}
<h2 id="systemsetup">
  <a href="/zh/osx/systemsetup.html">systemsetup</a> <a href="#systemsetup"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 配置系统首选项计算机设置.

#### 启用远程登录 (SSH):
```shell
systemsetup -setremotelogin on
```
#### 指定时区、NTP 服务器并启用网络时间:
```shell
systemsetup -settimezone {{美国 / 太平洋}} -setnetworktimeserver {{us.pool.ntp.org}} -setusingnetworktime on
```
#### 使机器从不休眠，并在电源故障或内核死机时自动重新启动:
```shell
systemsetup -setsleep off -setrestartpowerfailure on -setrestartfreeze on
```
#### disks 选择启动:
```shell
systemsetup -liststartupdisks
```
#### 指定新的启动盘:
```shell
systemsetup -setstartupdisk {{路径}}
```
{% endraw %}{% raw %}
<h2 id="textutil">
  <a href="/zh/osx/textutil.html">textutil</a> <a href="#textutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于操作各种格式的文本文件.

#### 显示有关 `foo.rtf` 的信息:
```shell
textutil -info {{foo.rtf}}
```
#### 将 `foo.rtf` 转换为 `foo.html`:
```shell
textutil -convert {{html}} {{foo.rtf}}
```
#### 将带格式的 rtf 文本转换为普通 txt 文本:
```shell
textutil {{foo.rtf}} -convert {{txt}}
```
#### 将 `foo.txt` 转换为 `foo.rtf`, 字体使用 Times 字号 10:
```shell
textutil -convert {{rtf}} -font {{Times}} -fontsize {{10}} {{foo.txt}}
```
#### 加载当前目录中的所有 RTF 文件，连接其内容，并将结果作为 `index.html` 写入，HTML 标题设置为"多个文件":
```shell
textutil -cat {{html}} -title "多个文件" -output {{index.html}} *.rtf
```
{% endraw %}{% raw %}
<h2 id="top">
  <a href="/zh/osx/top.html">top</a> <a href="#top"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示运行进程的动态实时信息.

#### 执行 top 命令，界面中提供所有选项:
```shell
top
```
#### 按内部内存大小排序进程（默认顺序 - 进程 ID):
```shell
top -o mem
```
#### 首先按 CPU 启动顺序排序进程，然后按运行时间排序:
```shell
top -o cpu -O time
```
#### 只显示给定用户拥有的进程:
```shell
top -user {{用户名}}
```
#### 获取有关交互式命令的帮助（我测试并没看到这个功能）:
```shell
?
```
{% endraw %}{% raw %}
<h2 id="trap">
  <a href="/zh/osx/trap.html">trap</a> <a href="#trap"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在进程或操作系统接收到信号后自动执行命令.
> 可用于对用户中断或其他操作执行清理.

#### 列出设置 trap 的可用信号:
```shell
trap -l
```
#### 列出当前 shell 程序的活动 trap 程序:
```shell
trap -p
```
#### 设置 trap 以在检测到一个或多个信号时执行命令:
```shell
trap 'echo "检测到信号 {{SIGHUP}}"' {{SIGHUP}}
```
#### 移除活动 trap:
```shell
trap - {{SIGHUP}} {{SIGINT}}
```
{% endraw %}{% raw %}
<h2 id="tree">
  <a href="/zh/osx/tree.html">tree</a> <a href="#tree"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 以树的形式显示当前目录的内容.

#### 显示深度达到 “级数” 级的文件和目录（其中 1 表示当前目录）:
```shell
tree -L {{级数}}
```
#### 只显示目录:
```shell
tree -d
```
#### 同时显示隐藏文件:
```shell
tree -a
```
#### 打印没有缩进行的树，显示完整路径（使用`-N`不转义空格和特殊字符）:
```shell
tree -i -f
```
#### 以可读格式打印每个文件节点的大小，目录显示其累积大小（类似在`du`命令中所示）:
```shell
tree -s -h --du
```
#### 使用通配符（glob）模式在树层次结构中查找文件，并删除不包含匹配文件的目录:
```shell
tree -P '{{*.txt}}' --prune
```
#### 在树层次结构中查找目录，删除不属于所需目录的目录:
```shell
tree -P {{文件夹名}} --matchdirs --prune
```
{% endraw %}{% raw %}
<h2 id="uname">
  <a href="/zh/osx/uname.html">uname</a> <a href="#uname"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打印当前计算机及其上运行的操作系统的详细信息.
> 注意：有关操作系统的其他信息，请尝试使用 `sw-vers` 命令.

#### 打印硬件相关：架构信息和处理器:
```shell
uname -mp
```
#### 打印软件相关信息：操作系统、版本号和版本:
```shell
uname -srv
```
#### 打印系统的节点名称（主机名）:
```shell
uname -n
```
#### 打印所有可用的系统信息（硬件、软件、节点名）:
```shell
uname -a
```
{% endraw %}{% raw %}
<h2 id="w">
  <a href="/zh/osx/w.html">w</a> <a href="#w"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示谁登录以及他们在做什么.
> 打印用户登录、tty、远程主机、登录时间、空闲时间、当前进程.

#### 显示登录用户信息:
```shell
w
```
#### 显示没有标题的登录用户信息:
```shell
w -h
```
#### 显示有关已登录用户的信息，按其空闲时间排序:
```shell
w -i
```
{% endraw %}{% raw %}
<h2 id="wacaw">
  <a href="/zh/osx/wacaw.html">wacaw</a> <a href="#wacaw"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个用于 macOS 的小命令行工具，允许您从连接的摄像头捕获静止图片和视频

#### 从网络摄像机拍照:
```shell
wacaw {{文件名}}
```
#### 录制视频:
```shell
wacaw --video {{文件名}} -D {{录制多少秒}}
```
#### 用自定义分辨率拍照:
```shell
wacaw -x {{宽}} -y {{高}} {{文件名}}
```
#### 将刚拍摄的图像复制到剪贴板:
```shell
wacaw --to-clipboard
```
#### 可用设备列表:
```shell
wacaw -L
```
{% endraw %}{% raw %}
<h2 id="whereis">
  <a href="/zh/osx/whereis.html">whereis</a> <a href="#whereis"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 找到命令的二进制，源文件和手册文件.

#### 找到 `ssh` 命令的二进制、源文件和手册页:
```shell
whereis {{ssh}}
```
#### 查找 `ls` 命令的二进制和手册页:
```shell
whereis -bm {{ls}}
```
#### 找到 `gc` 的源文件和 `git` 的手册页:
```shell
whereis -s {{gcc}} -m {{git}}
```
#### 仅在 /usr/bin/ 目录中查找 `gcc` 的二进制文件:
```shell
whereis -b -B {{/usr/bin/}} -f {{gcc}}
```
{% endraw %}{% raw %}
<h2 id="wifi-password">
  <a href="/zh/osx/wifi-password.html">wifi-password</a> <a href="#wifi-password"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 获取 wifi 的密码.
> 更多信息: <https://github.com/rauchg/wifi-password>.

#### 获取你当前登录的 wifi 的密码:
```shell
wifi-password
```
#### 获取特定 SSID 的 wifi 的密码:
```shell
wifi-password {{ssid}}
```
#### 仅输出密码:
```shell
wifi-password -q
```
{% endraw %}{% raw %}
<h2 id="xattr">
  <a href="/zh/osx/xattr.html">xattr</a> <a href="#xattr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于扩展文件系统属性的实用程序.

#### 列出 键：值 列表，显示指定文件的值扩展属性:
```shell
xattr -l {{文件名}}
```
#### 为给定文件写入属性:
```shell
xattr -w {{属性键名}} {{属性值}} {{文件名}}
```
#### 从给定文件中删除属性:
```shell
xattr -d {{com.apple.quarantine}} {{文件名}}
```
#### 从给定文件中删除所有扩展属性:
```shell
xattr -c {{文件名}}
```
#### 递归删除给定目录中文件的属性:
```shell
xattr -rd {{属性键名}} {{目录}}
```
{% endraw %}{% raw %}
<h2 id="xcodebuild">
  <a href="/zh/osx/xcodebuild.html">xcodebuild</a> <a href="#xcodebuild"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 构建 Xcode 项目.

#### 构建工作区:
```shell
xcodebuild -workspace {{工作区名.工作区}} -scheme {{主题名}} -configuration {{配置名}} clean build SYMROOT={{SYMROOT_路径}}
```
#### 构建项目:
```shell
xcodebuild -target {{目标名}} -configuration {{配置名}} clean build SYMROOT={{SYMROOT_路径}}
```
#### 显示 SDK:
```shell
xcodebuild -showsdks
```
{% endraw %}{% raw %}
<h2 id="xctool">
  <a href="/zh/osx/xctool.html">xctool</a> <a href="#xctool"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于构建 Xcode 项目的工具.

#### 在没有任何工作区的情况下生成单个项目:
```shell
xctool -project {{你的项目.名称}} -scheme {{方案}} build
```
#### 构建属于工作区的项目:
```shell
xctool -workspace {{你的工作区.名字}} -scheme {{方案}} build
```
#### 清理、构建和执行所有测试:
```shell
xctool -workspace {{你的工作区.名字}} -scheme {{方案}} clean build test
```
{% endraw %}{% raw %}
<h2 id="xed">
  <a href="/zh/osx/xed.html">xed</a> <a href="#xed"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用 Xcode 打开要编辑的文件.

#### 用 Xcode 打开文件 :
```shell
xed {{文件名}}
```
#### 在 Xcode 中打开文件，如果不存在则创建:
```shell
xed -c {{文件名}}
```
#### 在 Xcode 中打开一个文件并跳转到第 75 行:
```shell
xed -l 75 {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="xsltproc">
  <a href="/zh/osx/xsltproc.html">xsltproc</a> <a href="#xsltproc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用 XSLT 转换 XML 以生成输出（通常是 HTML 或 XML ）.

#### 使用特定的 XSLT 样式表转换 XML 文件:
```shell
xsltproc --output {{输出.html}} {{样式表.xslt}} {{xml 文件.xml}}
```
#### 将值传递给样式表中的参数:
```shell
xsltproc --output {{输出.html}} --stringparam {{键名}} {{值}} {{样式表.xslt}} {{xml 文件.xml}}
```
{% endraw %}{% raw %}
<h2 id="yank">
  <a href="/zh/osx/yank.html">yank</a> <a href="#yank"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从 stdin 读取输入并显示一个选择界面，该界面允许选择一个字段并将其复制到剪贴板.

#### 使用默认分隔符 (\f, \n, \r, \s, \t):
```shell
{{sudo dmesg}} | yank
```
#### 输入单行:
```shell
{{sudo dmesg}} | yank -l
```
#### 使用特定分 `=` 隔符输入:
```shell
{{echo hello=world}} | yank -d {{=}}
```
#### 只有与特定正则表达式匹配的内容才输入:
```shell
{{ps ux}} | yank -g "{{[0-9]+}}"
```
{% endraw %}# Windows
{% raw %}
<h2 id="assoc">
  <a href="/zh/windows/assoc.html">assoc</a> <a href="#assoc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或修改文件扩展名关联.

#### 显示所有当前文件扩展名关联的列表:
```shell
assoc
```
#### 显示指定扩展名的关联文件类型:
```shell
assoc {{.txt}}
```
#### 将文件扩展名与特定的文件类型关联:
```shell
assoc {{.txt}}={{txtfile}}
```
{% endraw %}{% raw %}
<h2 id="attrib">
  <a href="/zh/windows/attrib.html">attrib</a> <a href="#attrib"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或修改文件和目录的属性.

#### 显示当前目录下所有文件的属性:
```shell
attrib
```
#### 显示当前目录和其子目录下所有文件的属性:
```shell
attrib /S
```
#### 显示当前目录和其子目录下所有文件和目录的属性:
```shell
attrib /S /D
```
#### 为一个文件增加只读属性:
```shell
attrib +R {{document.txt}}
```
#### 删除一个文件的系统和隐藏属性:
```shell
attrib -S -H {{document.txt}}
```
#### 为一个目录增加隐藏属性:
```shell
attrib +H {{目录的路径}}
```
{% endraw %}{% raw %}
<h2 id="choco-feature">
  <a href="/zh/windows/choco-feature.html">choco feature</a> <a href="#choco-feature"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Chocolatey 的交互功能.

#### 显示可用的功能列表:
```shell
choco feature list
```
#### 启用一个功能:
```shell
choco feature enable --name {{功能名称}}
```
#### 禁用一个功能:
```shell
choco feature disable --name {{功能名称}}
```
{% endraw %}{% raw %}
<h2 id="choco-info">
  <a href="/zh/windows/choco-info.html">choco info</a> <a href="#choco-info"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示有关 Chocolatey 包的详细信息.

#### 显示指定包的信息:
```shell
choco info {{包名}}
```
#### 显示一个本地已安装包的信息:
```shell
choco info {{包名}} --local-only
```
#### 从一个自定义的源来获取包的信息:
```shell
choco info {{包名}} --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco info {{包名}} --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco-install">
  <a href="/zh/windows/choco-install.html">choco install</a> <a href="#choco-install"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 下载一个或多个包.

#### 安装一个或多个用空格分隔的软件包:
```shell
choco install {{包名 包名 ..}}
```
#### 从一个自定义的配置文件中安装包:
```shell
choco install {{配置文件的路径}}
```
#### 安装一个特定的"nuspec"或"nupkg"文件:
```shell
choco install {{文件的路径}}
```
#### 安装一个指定版本的包:
```shell
choco install {{包名}} --version {{版本号}}
```
#### 允许安装一个包的多个版本:
```shell
choco install {{包名}} --allow-multiple
```
#### 自动确认所有提示:
```shell
choco install {{包名}} --yes
```
#### 从自定义的源处获取包:
```shell
choco install {{包名}} --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco install {{包名}} --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco-list">
  <a href="/zh/windows/choco-list.html">choco list</a> <a href="#choco-list"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 显示包列表.

#### 列出所有可用的包:
```shell
choco list
```
#### 列出所有本地已安装的包:
```shell
choco list --local-only
```
#### 显示包含本地程序的列表:
```shell
choco list --include-programs
```
#### 只显示已批准的包:
```shell
choco list --approved-only
```
#### Specify a custom source to display packages from 指定一个源来显示包列表:
```shell
choco list --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco list --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco-new">
  <a href="/zh/windows/choco-new.html">choco new</a> <a href="#choco-new"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 生成新的包规范文件.

#### 创建一个新的包框架:
```shell
choco new {{包名}}
```
#### 创建一个新的指定版本的包:
```shell
choco new {{包名}} --version {{版本号}}
```
#### 创建一个新的包并指定维护者的名字:
```shell
choco new {{包名}} --maintainer {{维护者名字}}
```
#### 在指定目录下创建新的包:
```shell
choco new {{包名}} --output-directory {{指定的目录路径}}
```
#### 创建一个新的包并指定其 32 位版和 64 位版的安装 URL:
```shell
choco new {{package_name}} url="{{url}}" url64="{{url}}"
```
{% endraw %}{% raw %}
<h2 id="choco-outdated">
  <a href="/zh/windows/choco-outdated.html">choco outdated</a> <a href="#choco-outdated"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 检查过时的包.

#### 用表格的形式列出过时的包:
```shell
choco outdated
```
#### 忽略输出中的固定包:
```shell
choco outdated --ignore-pinned
```
#### 从自定义的源处检查过时的包:
```shell
choco outdated --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco outdated --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco-pack">
  <a href="/zh/windows/choco-pack.html">choco pack</a> <a href="#choco-pack"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将 nuspec 打包到已编译的 nupkg.

#### 将 nuspec 打包到已编译的 nupkg:
```shell
choco pack {{nuspec 的路径}}
```
#### 将 nuspec 打包到已编译的 nupkg, 并指定生成的版本:
```shell
choco pack {{nuspec 的路径}} --version {{版本号}}
```
#### 将 nuspec 打包到已编译的 nupkg, 并输出到指定的目录:
```shell
choco pack {{nuspec 的路径}} --output-directory {{输出目录的路径}}
```
{% endraw %}{% raw %}
<h2 id="choco-pin">
  <a href="/zh/windows/choco-pin.html">choco pin</a> <a href="#choco-pin"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 将一个包固定到指定的版本.
> 被固定版本的包会在更新时自动忽略.

#### 显示被固定的包以及他们对应的版本号:
```shell
choco pin list
```
#### 将一个包固定至当前版本:
```shell
choco pin add --name {{包名}}
```
#### 将一个包固定直指定的版本:
```shell
choco pin add --name {{包名}} --version {{版本号}}
```
#### 移除指定包的固定状态:
```shell
choco pin remove --name {{包名}}
```
{% endraw %}{% raw %}
<h2 id="choco-search">
  <a href="/zh/windows/choco-search.html">choco search</a> <a href="#choco-search"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 搜索一个本地或远程的包.

#### 搜索一个包:
```shell
choco search {{查询语句}}
```
#### 搜索一个本地的包:
```shell
choco search {{查询语句}} --local-only
```
#### 只显示包含完全匹配的结果:
```shell
choco search {{查询语句}} --exact
```
#### 自动确认所有提示:
```shell
choco search {{查询语句}} --yes
```
#### 从自定义的源处搜索包:
```shell
choco search {{查询语句}} --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco search {{查询语句}} --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco-source">
  <a href="/zh/windows/choco-source.html">choco source</a> <a href="#choco-source"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 管理包的源.

#### 列出当前可用的源:
```shell
choco source list
```
#### 添加一个新的包源:
```shell
choco source add --name {{名称}} --source {{url}}
```
#### 添加包含凭据的新包源:
```shell
choco source add --name {{名称}} --source {{url}} --user {{用户名}} --password {{密码}}
```
#### 使用客户端证书添加新的包源:
```shell
choco source add --name {{名称}} --source {{url}} --cert {{证书的路径}}
```
#### 启用一个包源:
```shell
choco source enable --name {{名称}}
```
#### 禁用一个包源:
```shell
choco source disable --name {{名称}}
```
#### 移除一个包源:
```shell
choco source remove --name {{名称}}
```
{% endraw %}{% raw %}
<h2 id="choco-uninstall">
  <a href="/zh/windows/choco-uninstall.html">choco uninstall</a> <a href="#choco-uninstall"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 卸载一个或多个包.

#### 卸载一个或多个用空格分隔的软件包:
```shell
choco uninstall {{包名 『包名』 ..}}
```
#### 卸载一个指定版本的包:
```shell
choco uninstall {{包名}} --version {{版本号}}
```
#### 自动确认所有提示:
```shell
choco uninstall {{包名}} --yes
```
#### 卸载时同时删除其所有的依赖:
```shell
choco uninstall {{包名}} --remove-dependencies
```
#### 卸载全部包:
```shell
choco uninstall all
```
{% endraw %}{% raw %}
<h2 id="choco-upgrade">
  <a href="/zh/windows/choco-upgrade.html">choco upgrade</a> <a href="#choco-upgrade"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Chocolatey 升级一个或多个包.

#### 升级一个或多个用空格分隔的软件包:
```shell
choco upgrade {{包名 包名 ..}}
```
#### 将一个包升级到指定版本:
```shell
choco upgrade {{包名}} --version {{版本号}}
```
#### 升级全部包:
```shell
choco upgrade all
```
#### 升级除指定的用逗号分隔的包之外的所有包:
```shell
choco upgrade all --except "{{包名 , 包名 ..}}"
```
#### 自动确认所有提示:
```shell
choco upgrade {{包名}} --yes
```
#### 从自定义源处升级包:
```shell
choco upgrade {{包名}} --source {{源 URL|别名}}
```
#### 提供一个用户名和密码来进行验证:
```shell
choco upgrade {{包}} --user {{用户名}} --password {{密码}}
```
{% endraw %}{% raw %}
<h2 id="choco">
  <a href="/zh/windows/choco.html">choco</a> <a href="#choco"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Chocolatey 包管理器的命令行界面.
> 参见 `choco install`, `choco upgrade` 和其他的页面来获取额外的信息.

#### 执行 Chocolatey 命令:
```shell
choco {{命令}}
```
#### 显示基本的帮助页面:
```shell
choco -?
```
#### 显示指定命令的帮助页面:
```shell
choco {{命令}} -?
```
#### 显示 Chocolatey 的版本:
```shell
choco --version
```
{% endraw %}{% raw %}
<h2 id="cipher">
  <a href="/zh/windows/cipher.html">cipher</a> <a href="#cipher"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 加密或解密 NTFS 驱动器上的文件.

#### 加密文件或目录:
```shell
cipher /e:{{路径/文件或目录}}
```
#### 解密文件或目录:
```shell
cipher /d:{{路径/文件或目录}}
```
#### 安全地删除文件或目录:
```shell
cipher /w:{{路径/文件或目录}}
```
{% endraw %}{% raw %}
<h2 id="clip">
  <a href="/zh/windows/clip.html">clip</a> <a href="#clip"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将输入的内容复制到 Windows 的剪贴板.

#### 用管道将命令的输出内容复制到 Windows 剪贴板:
```shell
{{dir}} | clip
```
#### 将一个文件中的内容复制到 Windows 剪贴板:
```shell
clip < {{文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="cls">
  <a href="/zh/windows/cls.html">cls</a> <a href="#cls"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 清屏.

#### 清屏:
```shell
cls
```
{% endraw %}{% raw %}
<h2 id="cmd">
  <a href="/zh/windows/cmd.html">cmd</a> <a href="#cmd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Windows 命令解释器.

#### 开启一个新的命令行实例:
```shell
cmd
```
#### 运行指定的命令然后退出:
```shell
cmd /c "{{命令}}"
```
#### 执行一个指定的命令，之后进入一个交互式 shell:
```shell
cmd /k "{{命令}}"
```
#### 不显示命令的输出结果:
```shell
cmd /q
```
#### 启用或禁用命令扩展:
```shell
cmd /e:{{on|off}}
```
#### 启用或禁用文件和目录名的自动补全:
```shell
cmd /f:{{on|off}}
```
#### 启用或禁用环境变量扩展:
```shell
cmd /v:{{on|off}}
```
#### 强制输出内容使用 Unicode 编码:
```shell
cmd /u
```
{% endraw %}{% raw %}
<h2 id="cmstp">
  <a href="/zh/windows/cmstp.html">cmstp</a> <a href="#cmstp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于管理连接服务配置文件的命令行工具.

#### 安装指定的配置文件:
```shell
cmstp "{{配置文件的路径}}"
```
#### 安装时不创建桌面快捷方式:
```shell
cmstp /ns "{{配置文件的路径}}"
```
#### 安装时不检查依赖:
```shell
cmstp /nf "{{配置文件的路径}}"
```
#### 仅为当前用户安装:
```shell
cmstp /su "{{配置文件的路径}}"
```
#### 为所有用户安装 （需要管理员权限）:
```shell
cmstp /au "{{配置文件的路径}}"
```
#### 静默安装:
```shell
cmstp /s "{{配置文件的路径}}"
```
#### 卸载一个指定的配置文件:
```shell
cmstp /u "{{配置文件的路径}}"
```
#### 静默删除:
```shell
cmstp /u /s "{{配置文件的路径}}"
```
{% endraw %}{% raw %}
<h2 id="color">
  <a href="/zh/windows/color.html">color</a> <a href="#color"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 设置控制台的前景色和背景色.

#### 将控制台颜色恢复至默认值:
```shell
color
```
#### 列出可用的颜色值和详细信息:
```shell
color /?
```
#### 将控制台前景色和背景色设置为指定颜色:
```shell
color {{前景色值}}{{背景色值}}
```
{% endraw %}{% raw %}
<h2 id="comp">
  <a href="/zh/windows/comp.html">comp</a> <a href="#comp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 比较两个文件或文件集的内容.
> 使用通配符 (*) 来比较文件集.

#### 交互式比较文件:
```shell
comp
```
#### 比较两个指定的文件:
```shell
comp {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 比较两个文件集:
```shell
comp {{目录 1/*}} {{目录 2/*}}
```
#### 以十进制格式显示差异:
```shell
comp /d {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 以 ASCII 字符显示差异:
```shell
comp /a {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 显示不同的行数:
```shell
comp /l {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 比较文件时不区分大小写:
```shell
comp /c {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 只比较每个文件前 5 行的内容:
```shell
comp /n={{5}} {{文件 1 的路径}} {{文件 2 的路径}}
```
{% endraw %}{% raw %}
<h2 id="del">
  <a href="/zh/windows/del.html">del</a> <a href="#del"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 删除一个或多个文件.

#### 删除一个或多个以空格分隔的文件:
```shell
del {{文件 文件 ..}}
```
#### 在删除每个文件之前提示确认:
```shell
del {{文件}} /p
```
#### 强制删除只读文件:
```shell
del {{文件}} /f
```
#### 递归删除所有子目录中的文件:
```shell
del {{文件}} /s
```
#### 在基于全局通配符删除文件时不提示确认:
```shell
del {{文件}} /q
```
#### 显示帮助和所有的属性列表:
```shell
del /?
```
#### 根据指定的属性删除文件:
```shell
del {{文件}} /a {{属性}}
```
{% endraw %}{% raw %}
<h2 id="dir">
  <a href="/zh/windows/dir.html">dir</a> <a href="#dir"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 列出目录的内容.

#### 显示当前目录的内容:
```shell
dir
```
#### 显示指定目录的内容:
```shell
dir {{目录的路径}}
```
#### 显示当前目录的内容，包括隐藏的文件:
```shell
dir /A
```
#### 显示指定目录的内容，包括隐藏的文件:
```shell
dir {{目录的路径}} /A
```
{% endraw %}{% raw %}
<h2 id="doskey">
  <a href="/zh/windows/doskey.html">doskey</a> <a href="#doskey"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理宏，Windows 命令和命令行.

#### 列出可用的宏:
```shell
doskey /macros
```
#### 创建一个新的宏:
```shell
doskey {{宏的名称}} = "{{命令}}"
```
#### 为指定可执行文件创建新的宏:
```shell
doskey /exename={{可执行文件名}} {{宏的名称}} = "{{命令}}"
```
#### 删除一个宏:
```shell
doskey {{宏的名称}} =
```
#### 列出所有储存在内存中的命令:
```shell
doskey /history
```
#### 将宏保存到文件以便于移植:
```shell
doskey /macros > {{保存宏的文件名}}
```
#### 从文件中加载宏:
```shell
doskey /macrofile = {{保存宏的文件名}}
```
{% endraw %}{% raw %}
<h2 id="driverquery">
  <a href="/zh/windows/driverquery.html">driverquery</a> <a href="#driverquery"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示已安装设备驱动程序的信息.

#### 显示所有已安装设备驱动程序的列表:
```shell
driverquery
```
#### 以指定格式显示驱动程序的列表:
```shell
driverquery /fo {{table|list|csv}}
```
#### 显示带有列的驱动程序列表，以表明它们是否已签名:
```shell
driverquery /si
```
#### 排除输出列表中的标题:
```shell
driverquery /nh
```
#### 显示远程计算机的驱动程序列表:
```shell
driverquery /s {{主机名}} /u {{用户名}} /p {{密码}}
```
#### 显示详细信息的驱动程序列表
```shell
driverquery /v
```
#### 显示详细的使用信息:
```shell
driverquery /?
```
{% endraw %}{% raw %}
<h2 id="eventcreate">
  <a href="/zh/windows/eventcreate.html">eventcreate</a> <a href="#eventcreate"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在事件日志中创建自定义条目.
> 事件 ID 可以是 1 到 1000 之间的任意数值.

#### 在日志中创建一个具有给定 id（1-1000）的新事件:
```shell
eventcreate /t {{success|error|warning|information}} /id {{id}} /d "{{消息}}"
```
#### 在特定事件日志中创建事件:
```shell
eventcreate /l {{日志名}} /t {{类型}} /id {{id}} /d "{{消息}}"
```
#### 为新创建的事件指定来源:
```shell
eventcreate /so {{来源名}} /t {{类型}} /id {{id}} /d "{{消息}}"
```
#### 在远程计算机的事件日志中创建事件:
```shell
eventcreate /s {{主机名}} /u {{用户名}} /p {{密码}} /t {{类型}} /id {{id}} /d "{{消息}}"
```
{% endraw %}{% raw %}
<h2 id="exit">
  <a href="/zh/windows/exit.html">exit</a> <a href="#exit"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 退出当前的命令行实例或 bat 脚本.

#### 退出当前的命令行实例:
```shell
exit
```
#### 退出当前的 bat 脚本:
```shell
exit /b
```
#### 使用一个指定的退出码退出:
```shell
exit {{退出码}}
```
{% endraw %}{% raw %}
<h2 id="expand">
  <a href="/zh/windows/expand.html">expand</a> <a href="#expand"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 解压一个或多个 cab 文件.

#### 将单文件 cab 文件解压到指定目录:
```shell
expand {{cab 文件路径}} {{指定的目录}}
```
#### 列出 cab 文件中的所有文件:
```shell
expand {{cab 文件路径}} {{指定的目录}} -d
```
#### 从 cab 文件中解压所有的文件:
```shell
expand {{cab 文件路径}} {{指定的目录}} -f:*
```
#### 从 cab 文件中解压一个特定的文件:
```shell
expand {{cab 文件路径}} {{指定的目录}} -f:{{文件名}}
```
#### 解压缩时忽略目录结构，并将它们添加到单个目录中:
```shell
expand {{cab 文件路径}} {{指定的目录}} -i
```
{% endraw %}{% raw %}
<h2 id="explorer">
  <a href="/zh/windows/explorer.html">explorer</a> <a href="#explorer"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Windows 文件资源管理器.
> 更多信息： <https://ss64.com/nt/explorer.html>.

#### 打开 Windows 文件资源管理器:
```shell
explorer
```
#### 在当前目录打开 Windows 文件资源管理器:
```shell
explorer .
```
#### 在指定目录打开 Windows 文件资源管理器:
```shell
explorer {{path/to/directory}}
```
{% endraw %}{% raw %}
<h2 id="fc">
  <a href="/zh/windows/fc.html">fc</a> <a href="#fc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 比较两个文件或文件集之间的差异.
> 使用通配符 (*) 来比较文件集.

#### 比较两个指定的文件:
```shell
fc {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 比较时不区分大小写:
```shell
fc /c {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 将文件作为 Unicode 文本来进行比较:
```shell
fc /u {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 将文件作为 ASCII 文本来进行比较:
```shell
fc /l {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 将文件作为二进制来比较:
```shell
fc /b {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 禁用制表符到空格的扩展:
```shell
fc /t {{文件 1 的路径}} {{文件 2 的路径}}
```
#### 压缩空格（制表符和空格）进行比较:
```shell
fc /w {{文件 1 的路径}} {{文件 2 的路径}}
```
{% endraw %}{% raw %}
<h2 id="find">
  <a href="/zh/windows/find.html">find</a> <a href="#find"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在一个或多个文件里查找指定字符串.

#### 查找包含指定字符串的行:
```shell
find {{字符串}} {{文件或目录的路径}}
```
#### 查找不包含指定字符串的行:
```shell
find {{字符串}} {{文件或目录的路径}} /v
```
#### 显示包含指定字符串的行的总数:
```shell
find {{字符串}} {{文件或目录的路径}} /c
```
#### 显示匹配的行的行数:
```shell
find {{字符串}} {{文件或目录的路径}} /n
```
{% endraw %}{% raw %}
<h2 id="findstr">
  <a href="/zh/windows/findstr.html">findstr</a> <a href="#findstr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在一个或多个文件中查找指定的文本.

#### 在所有文件中查找以空格分隔的字符串:
```shell
findstr "{{查询语句 查询语句 ..}}" *
```
#### 以递归方式在所有文件中查找以空格分隔的字符串:
```shell
findstr /s "{{查询语句 查询语句 ..}}" *
```
#### 查找时不区分大小写:
```shell
findstr /i "{{查询语句}}" *"
```
#### 使用正则表达式搜索:
```shell
findstr /r "{{正则表达式}}" *
```
#### 在所有文本文件中查找文字字符串（包含空格）:
```shell
findstr /c:"{{查询语句}}" *.txt
```
#### 只查找完全匹配的行:
```shell
findstr /x "{{查询语句}}" *
```
#### 显示匹配的行的行数:
```shell
findstr /n "{{查询语句}}" *
```
#### 只显示匹配的文件名:
```shell
findstr /m "{{查询语句}}" *
```
{% endraw %}{% raw %}
<h2 id="finger">
  <a href="/zh/windows/finger.html">finger</a> <a href="#finger"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 返回有关指定系统上的一个或多个用户的信息.
> 远程系统必须运行 Finger 服务.

#### 显示有关特定用户的信息:
```shell
finger {{用户名}}@{{主机名}}
```
#### 在指定的主机上显示所有用户的信息:
```shell
finger @{{主机名}}
```
#### 以更长的格式显示信息:
```shell
finger {{用户名}}@{{主机名}} -l
```
#### 显示帮助信息:
```shell
finger /?
```
{% endraw %}{% raw %}
<h2 id="fondue">
  <a href="/zh/windows/fondue.html">fondue</a> <a href="#fondue"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 可选 Windows 功能的命令行安装程序.

#### 启用一个指定的 Windows 功能:
```shell
fondue /enable-feature:{{功能}}
```
#### 向用户隐藏所有输出信息:
```shell
fondue /enable-feature:{{功能}} /hide-ux:all
```
#### 为错误报告指定调用者进程名称:
```shell
fondue /enable-feature:{{功能}} /caller-name:{{名称}}
```
{% endraw %}{% raw %}
<h2 id="forfiles">
  <a href="/zh/windows/forfiles.html">forfiles</a> <a href="#forfiles"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 选择一个或多个文件以执行指定的命令.

#### 在当前的目录中寻找文件:
```shell
forfiles
```
#### 在一个指定目录中寻找文件:
```shell
forfiles /p {{目录的路径}}
```
#### 为每个文件执行指定的命令:
```shell
forfiles /c "{{命令}}"
```
#### 使用通配符来寻找指定的文件:
```shell
forfiles /m {{通配符}}
```
#### 递归寻找文件:
```shell
forfiles /s
```
#### 搜索超过 5 天的文件:
```shell
forfiles /d {{+5}}
```
{% endraw %}{% raw %}
<h2 id="ftp">
  <a href="/zh/windows/ftp.html">ftp</a> <a href="#ftp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在本地和远程 FTP 服务器之间交互式传输文件.

#### 交互式连接一个远程的 FTP 服务:
```shell
ftp {{主机名}}
```
#### 匿名登录:
```shell
ftp -A {{主机名}}
```
#### 初始连接时禁用自动登录:
```shell
ftp -n {{主机名}}
```
#### 运行包含 FTP 命令列表的文件:
```shell
ftp -s:{{文件的路径}} {{主机名}}
```
#### 下载多个文件 （通配符表达式）:
```shell
mget {{*.png}}
```
#### 上传多个文件 （通配符表达式）:
```shell
mput {{*.zip}}
```
#### 在远程服务器上删除多个文件:
```shell
mdelete {{*.txt}}
```
#### 显示详细的帮助:
```shell
ftp --help
```
{% endraw %}{% raw %}
<h2 id="ftype">
  <a href="/zh/windows/ftype.html">ftype</a> <a href="#ftype"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或修改用于文件扩展名关联的文件类型.

#### 显示所有文件类型的列表:
```shell
ftype
```
#### 显示特定文件类型的关联程序:
```shell
ftype {{文件类型}}
```
#### 设置特定文件类型的关联程序:
```shell
ftype {{文件类型}}="{{可执行命令的路径}}"
```
{% endraw %}{% raw %}
<h2 id="getmac">
  <a href="/zh/windows/getmac.html">getmac</a> <a href="#getmac"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示系统的 MAC 地址.

#### 显示当前系统的 MAC 地址:
```shell
getmac
```
#### 以特定格式显示详细信息:
```shell
getmac /fo {{table|list|csv}}
```
#### 排除输出列表中的标题:
```shell
getmac /nh
```
#### 显示一个远程主机的 MAC 地址:
```shell
getmac /s {{主机名}} /u {{用户名}} /p {{密码}}
```
#### 详细显示 MAC 地址信息:
```shell
getmac /v
```
#### 显示详细的帮助信息:
```shell
getmac /?
```
{% endraw %}{% raw %}
<h2 id="ipconfig">
  <a href="/zh/windows/ipconfig.html">ipconfig</a> <a href="#ipconfig"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示和管理 Windows 的网络配置.

#### 显示网络适配器列表:
```shell
ipconfig
```
#### 显示网络适配器的详细列表:
```shell
ipconfig /all
```
#### 为一个网络适配器重新获取 IP 地址:
```shell
ipconfig /renew {{适配器}}
```
#### 为一个网络适配器释放 IP 地址:
```shell
ipconfig /release {{适配器}}
```
#### 清除所有 DNS 缓存:
```shell
ipconfig /flushdns
```
{% endraw %}{% raw %}
<h2 id="iscc">
  <a href="/zh/windows/iscc.html">iscc</a> <a href="#iscc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Inno Setup 安装程序的编译器.
> 它将 Inno Setup 脚本编译为 Windows 安装程序可执行文件.
> 更多信息： <https://jrsoftware.org/isinfo.php>.

#### 编译一个 Inno Setup 脚本:
```shell
iscc {{脚本路径.iss}}
```
#### 静默编译一个 Inno Setup 安装程序:
```shell
iscc /Q {{脚本路径.iss}}
```
#### 编译已签名的 Inno Setup 安装程序:
```shell
iscc /S={{名称}}={{命令}} {{脚本路径.iss}}
```
{% endraw %}{% raw %}
<h2 id="logoff">
  <a href="/zh/windows/logoff.html">logoff</a> <a href="#logoff"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 注销登录会话.

#### 注销当前会话:
```shell
logoff
```
#### 通过名称和 id 注销会话:
```shell
logoff {{会话名|会话 id}}
```
#### 在通过 RDP 连接的特定服务器上注销会话:
```shell
logoff {{会话名|会话 id}} /server:{{服务器名}}
```
{% endraw %}{% raw %}
<h2 id="mkdir">
  <a href="/zh/windows/mkdir.html">mkdir</a> <a href="#mkdir"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建一个目录.

#### 创建一个目录:
```shell
mkdir {{目录名}}
```
#### 递归创建目录及子目录:
```shell
mkdir {{子目录名}}
```
{% endraw %}{% raw %}
<h2 id="mklink">
  <a href="/zh/windows/mklink.html">mklink</a> <a href="#mklink"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建符号链接.

#### 创建指向文件的符号链接:
```shell
mklink {{链接文件的路径}} {{源文件路径}}
```
#### 创建指向目录的符号链接:
```shell
mklink /d {{链接文件的路径}} {{源目录路径}}
```
#### 创建指向文件的硬链接:
```shell
mklink /h {{链接文件的路径}} {{源目录路径}}
```
#### 创建目录链接:
```shell
mklink /j {{链接文件的路径}} {{源目录路径}}
```
{% endraw %}{% raw %}
<h2 id="more">
  <a href="/zh/windows/more.html">more</a> <a href="#more"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 分页显示标准输入或文件的输出.

#### 分页显示标准输入的输出:
```shell
{{echo test}} | more
```
#### 分页显示一个或多个文件的内容:
```shell
more {{文件的路径}}
```
#### 将制表符转换为指定的空格数:
```shell
more {{文件的路径}} /t{{空格数}}
```
#### 显示内容前先清屏:
```shell
more {{文件的路径}} /c
```
#### 从第 5 行开始显示输出:
```shell
more {{文件的路径}} +{{5}}
```
#### 启用扩展交互模式（请参阅使用帮助）:
```shell
more {{文件的路径}} /e
```
#### 显示全部帮助信息:
```shell
more /?
```
{% endraw %}{% raw %}
<h2 id="msg">
  <a href="/zh/windows/msg.html">msg</a> <a href="#msg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 向指定的用户或会话发送信息.

#### 向指定的用户或会话发送信息:
```shell
msg {{用户名|会话名|会话 id}} {{信息}}
```
#### 从标准输入发送信息:
```shell
echo "{{信息}}" | msg {{用户名|会话名|会话 id}}
```
#### 向指定的服务器发送消息:
```shell
msg /server:{{服务器名称}} {{用户名|会话名|会话 id}}
```
#### 向当前计算机的所有用户发送消息:
```shell
msg *
```
#### 设置发送消息的延迟:
```shell
msg /time:{{秒}}
```
{% endraw %}{% raw %}
<h2 id="path">
  <a href="/zh/windows/path.html">path</a> <a href="#path"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或设置可执行文件的搜索路径.

#### 显示当前的路径:
```shell
path
```
#### 将路径设置为一个或多个以分号分隔的目录:
```shell
path {{目录的路径 1[; 目录的路径 2]}}
```
#### 将新的目录添加到源路径后:
```shell
path {{目录的路径}};%path%
```
#### 将命令提示符设置为仅搜索当前目录中的可执行文件:
```shell
path ;
```
{% endraw %}{% raw %}
<h2 id="pathping">
  <a href="/zh/windows/pathping.html">pathping</a> <a href="#pathping"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一种结合了`ping`和`tracert`功能的跟踪路由工具.

#### Ping 并追踪主机的路由:
```shell
pathping {{主机名}}
```
#### 不要对主机名执行 IP 地址的反向查找:
```shell
pathping {{主机名}} -n
```
#### 指定要搜索目标的最大跃点数（默认值为 30）:
```shell
pathping {{主机名}} -h {{最大跃点数}}
```
#### 指定 ping 之间等待的毫秒数（默认值为 240）:
```shell
pathping {{主机名}} -p {{时间}}
```
#### 指定每跳的查询数（默认值为 100）:
```shell
pathping {{主机名}} -q {{查询语句}}
```
#### 强制使用 IPV4:
```shell
pathping {{主机名}} -4
```
#### 强制使用 IPV6:
```shell
pathping {{主机名}} -6
```
#### 显示详细的使用帮助:
```shell
pathping /?
```
{% endraw %}{% raw %}
<h2 id="popd">
  <a href="/zh/windows/popd.html">popd</a> <a href="#popd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将当前目录切换到`pushd`命令存储的目录.

#### 切换到储存在栈顶的目录:
```shell
popd
```
{% endraw %}{% raw %}
<h2 id="powershell">
  <a href="/zh/windows/powershell.html">powershell</a> <a href="#powershell"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 专为系统管理而设计的命令行 shell 和脚本语言.
> 更多信息: <https://docs.microsoft.com/windows-server/administration/windows-commands/powershell>.

#### 在命令提示符窗口中启动 Windows PowerShell 会话:
```shell
powershell
```
#### 加载一个特定的 PowerShell 控制台文件:
```shell
powershell -PSConsoleFile {{路径/file}}
```
#### 用指定版本的 PowerShell 启动会话:
```shell
powershell -Version {{版本}}
```
#### 防止运行启动命令后 shell 退出:
```shell
powershell -NoExit
```
#### 描述发送到 PowerShell 的数据格式:
```shell
powershell -InputFormat {{Text|XML}}
```
#### 设定 PowerShell 输出的格式:
```shell
powershell -OutputFormat {{Text|XML}}
```
#### 显示帮助:
```shell
powershell -Help
```
{% endraw %}{% raw %}
<h2 id="print">
  <a href="/zh/windows/print.html">print</a> <a href="#print"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将文本文件打印到打印机.

#### 将文本文件打印到默认的打印机:
```shell
print {{文件的路径}}
```
#### 将文本文件打印到指定的打印机:
```shell
print /d:{{打印机}} {{文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="pushd">
  <a href="/zh/windows/pushd.html">pushd</a> <a href="#pushd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将目录储存在栈顶以便稍后访问.
> 参考`popd`命令来切换到原目录.

#### 切换目录并将它放至栈:
```shell
pushd {{目录}}
```
{% endraw %}{% raw %}
<h2 id="pwlauncher">
  <a href="/zh/windows/pwlauncher.html">pwlauncher</a> <a href="#pwlauncher"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于管理 Windows To Go 启动选项的命令行工具.

#### 显示当前 Windows To Go 的状态:
```shell
pwlauncher
```
#### 启用或禁用 Windows To Go 的启动选项:
```shell
pwlauncher /{{enable|disable}}
```
{% endraw %}{% raw %}
<h2 id="rdpsign">
  <a href="/zh/windows/rdpsign.html">rdpsign</a> <a href="#rdpsign"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于签名远程桌面协议（RDP）文件的工具.

#### 为一个 RDP 文件签名:
```shell
rdpsign {{文件路径.rdp}}
```
#### 使用一个指定的 sha256 哈希值为 RDP 文件签名:
```shell
rdpsign {{文件路径.rdp}} /sha265 {{哈希值}}
```
#### 启用静默输出:
```shell
rdpsign {{文件路径.rdp}} /q
```
#### 显示详细的信息、警告和状态:
```shell
rdpsign {{文件路径.rdp}} /v
```
#### 在不更新文件的情况下将输出显示到标准输出来测试签名:
```shell
rdpsign {{文件路径.rdp}} /l
```
{% endraw %}{% raw %}
<h2 id="reg-add">
  <a href="/zh/windows/reg-add.html">reg add</a> <a href="#reg-add"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将新的键值添加到注册表中.

#### 添加一个新的注册表键:
```shell
reg add {{键名}}
```
#### 在指定的键下添加新值:
```shell
reg add {{键名}} /v {{值}}
```
#### Add a new value with specific data:
```shell
reg add {{键名}} /d {{数据}}
```
#### 向具有特定数据类型的键添加新值:
```shell
reg add {{键名}} /t {{类型}}
```
#### 在没有提示的情况下强制覆盖现有的注册表值:
```shell
reg add {{键名}} /f
```
{% endraw %}{% raw %}
<h2 id="reg-compare">
  <a href="/zh/windows/reg-compare.html">reg compare</a> <a href="#reg-compare"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 比较注册表中的键和值.

#### 比较两个键中的所有值:
```shell
reg compare {{第一个键名}} {{第二个键名}}
```
#### 比较两个键中指定的值:
```shell
reg compare {{第一个键名}} {{第二个键名}} /v {{值}}
```
#### 比较两个键中的所有子键和值:
```shell
reg compare {{第一个键名}} {{第二个键名}} /s
```
#### 仅输出指定键之间匹配的结果:
```shell
reg compare {{第一个键名}} {{第二个键名}} /os
```
#### 输出两个键之间的匹配和差异:
```shell
reg compare {{第一个键名}} {{第二个键名}} /oa
```
{% endraw %}{% raw %}
<h2 id="reg-copy">
  <a href="/zh/windows/reg-copy.html">reg copy</a> <a href="#reg-copy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 复制注册表中的键和值.

#### 将注册表键复制到新的注册表位置:
```shell
reg copy {{旧键名}} {{新键名}}
```
#### 递归将注册表键复制到新的注册表位置:
```shell
reg copy {{旧键名}} {{新键名}} /s
```
#### 在没有提示的情况下强制复制注册表键:
```shell
reg copy {{旧键名}} {{新键名}} /f
```
{% endraw %}{% raw %}
<h2 id="reg-delete">
  <a href="/zh/windows/reg-delete.html">reg delete</a> <a href="#reg-delete"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从注册表中删除键和值.

#### 删除一个指定的键:
```shell
reg delete {{键名}}
```
#### 删除键中指定的值:
```shell
reg delete {{键名}} /v {{值}}
```
#### 递归删除指定键下所有的值:
```shell
reg delete {{键名}} /va
```
#### 在没有提示的情况下递归删除键中所有的值:
```shell
reg delete {{键名}} /f /va
```
{% endraw %}{% raw %}
<h2 id="reg-export">
  <a href="/zh/windows/reg-export.html">reg export</a> <a href="#reg-export"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将指定的子键和值导出到文件中.

#### 导出指定键下所有的子键和值:
```shell
reg export {{键名}} {{导出文件的路径.reg}}
```
#### 在没有提示的情况下强制覆盖现有文件:
```shell
reg export {{键名}} {{导出文件的路径.reg}} /y
```
{% endraw %}{% raw %}
<h2 id="reg-flags">
  <a href="/zh/windows/reg-flags.html">reg flags</a> <a href="#reg-flags"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或设置注册表键的标志.

#### 显示当前指定键的标志:
```shell
reg flags {{键名}} query
```
#### 显示帮助和可用的标志类型:
```shell
reg flags /?
```
#### 为特定键设置指定以空格分隔的标志，并取消设置未提及的标志:
```shell
reg flags {{键名}} set {{标志 1 标志 2 ..}}
```
#### 为指定的键和其子键设置标志:
```shell
reg flags {{键名}} set {{标志}} /s
```
{% endraw %}{% raw %}
<h2 id="reg-import">
  <a href="/zh/windows/reg-import.html">reg import</a> <a href="#reg-import"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从一个文件导入所有可用的键、子键和值.

#### 从一个文件导入所有可用的键、子键和值:
```shell
reg import {{reg 文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="reg-load">
  <a href="/zh/windows/reg-load.html">reg load</a> <a href="#reg-load"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将保存的子键加载到不同的子键中.
> This is intended for troubleshooting and temporary keys.

#### 将备份文件加载到指定的键中:
```shell
reg load {{键名}} {{文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="reg-query">
  <a href="/zh/windows/reg-query.html">reg query</a> <a href="#reg-query"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示注册表中键和子键的值.

#### 显示一个键中的所有值:
```shell
reg query {{键名}}
```
#### 显示键中指定的值:
```shell
reg query {{键名}} /v {{值}}
```
#### 显示指定键和其子键中的所有的值:
```shell
reg query {{键名}} /s
```
#### 搜索与特定模式匹配的键和值:
```shell
reg query {{键名}} /f "{{查询语句}}"
```
#### 显示与指定数据类型匹配的键的值:
```shell
reg query {{键名}} /t {{类型}}
```
{% endraw %}{% raw %}
<h2 id="reg-restore">
  <a href="/zh/windows/reg-restore.html">reg restore</a> <a href="#reg-restore"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从备份文件中恢复键和值.
> 参见 `reg-save` 来获取更多的信息.

#### 使用备份文件中的数据覆盖指定的键:
```shell
reg restore {{键名}} {{文件路径}}
```
{% endraw %}{% raw %}
<h2 id="reg-save">
  <a href="/zh/windows/reg-save.html">reg save</a> <a href="#reg-save"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将注册表键、子键的所有值保存到一个文件中.

#### 将注册表键、子键的所有值保存到一个文件中:
```shell
reg save {{键名}} {{文件的路径}}
```
#### 在没有提示的情况下强制覆盖现有文件:
```shell
reg save {{键名}} {{文件的路径}} /y
```
{% endraw %}{% raw %}
<h2 id="reg-unload">
  <a href="/zh/windows/reg-unload.html">reg unload</a> <a href="#reg-unload"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从使用`reg load`命令加载的注册表中删除数据.

#### 从使用`reg load`命令加载的注册表中删除数据:
```shell
reg unload {{键名}}
```
{% endraw %}{% raw %}
<h2 id="reg">
  <a href="/zh/windows/reg.html">reg</a> <a href="#reg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于在 Windows 注册表中管理键及其值的命令行界面.
> 参见 `reg-query`, `reg-add` 和其他的页面来获取额外的信息.

#### 执行注册表命令:
```shell
reg {{命令}}
```
#### 显示常规信息并列出所有可用命令:
```shell
reg /?
```
#### 显示指定命令的帮助信息:
```shell
reg {{命令}} /?
```
{% endraw %}{% raw %}
<h2 id="repair-bde">
  <a href="/zh/windows/repair-bde.html">repair-bde</a> <a href="#repair-bde"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 尝试修复或解密损坏的 BitLocker 加密卷.

#### 尝试修复一个指定的卷:
```shell
repair-bde {{C:}}
```
#### 尝试修复指定的卷并输出到另一个卷:
```shell
repair-bde {{C:}} {{D:}}
```
#### 尝试使用提供的恢复密钥文件修复指定的卷:
```shell
repair-bde {{C:}} -RecoveryKey {{bek 文件的路径}}
```
#### 尝试使用提供的数字恢复密码修复指定的卷:
```shell
repair-bde {{C:}} -RecoveryPassword {{密码}}
```
#### 尝试使用提供的密码修复指定的卷:
```shell
repair-bde {{C:}} -Password {{密码}}
```
#### 尝试使用提供的密钥包修复指定的卷:
```shell
repair-bde {{C:}} -KeyPackage {{目录的路径}}
```
#### 将日志输出到指定的文件:
```shell
repair-bde {{C:}} -LogFile {{文件的路径}}
```
#### 显示所有可用的选项:
```shell
repair-bde /?
```
{% endraw %}{% raw %}
<h2 id="rmdir">
  <a href="/zh/windows/rmdir.html">rmdir</a> <a href="#rmdir"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 删除一个目录和其中的内容.

#### 删除一个空目录:
```shell
rmdir {{目录的路径}}
```
#### 递归删除一个目录及其中的内容:
```shell
rmdir {{目录的路径}} /s
```
#### 在没有提示的情况下递归删除目录及其内容:
```shell
rmdir {{path/to/directory}} /s /q
```
{% endraw %}{% raw %}
<h2 id="scoop-bucket">
  <a href="/zh/windows/scoop-bucket.html">scoop bucket</a> <a href="#scoop-bucket"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 管理 bucket: 包含描述 scoop 应如何安装应用程序的文件的 Git 存储库。
> 如果 Scoop 不知道 bucket 在哪里，则必须指定其存储库位置。
> 更多信息: <https://github.com/lukesampson/scoop/wiki/Buckets>.

#### 列出所有正在使用的 bucket:
```shell
scoop bucket list
```
#### 列出所有已知 bucket:
```shell
scoop bucket known
```
#### 按名称添加一个已知 bucket:
```shell
scoop bucket add {{名称}}
```
#### 通过名称和 Git 存储库 URL 添加未知 bucket:
```shell
scoop bucket add {{名称}} {{https://example.com/repository.git}}
```
#### 按名称删除 bucket:
```shell
scoop bucket rm {{名称}}
```
{% endraw %}{% raw %}
<h2 id="scoop">
  <a href="/zh/windows/scoop.html">scoop</a> <a href="#scoop"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Windows 的命令行安装程序.

#### 安装一个包:
```shell
scoop install {{包名}}
```
#### 删除一个包:
```shell
scoop uninstall {{包名}}
```
#### 更新所有已安装的包:
```shell
scoop update *
```
#### 列出所有已安装的包:
```shell
scoop list
```
#### 显示一个包的信息:
```shell
scoop info {{包名}}
```
#### 搜索一个包:
```shell
scoop search {{包名}}
```
#### 列出所有已知的桶 (“桶”代表程序的仓库）:
```shell
scoop bucket known
```
#### 通过别名或 Git 存储库 URL 添加存储桶:
```shell
scoop bucket add {{bucket}}
```
{% endraw %}{% raw %}
<h2 id="set">
  <a href="/zh/windows/set.html">set</a> <a href="#set"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示或设置当前命令行实例的环境变量.

#### 列出当前所有环境变量:
```shell
set
```
#### 为一个环境变量设置指定的值:
```shell
set {{变量名}}={{值}}
```
#### 列出以指定字符串开头的环境变量:
```shell
set {{变量名}}
```
#### 提示用户输入指定变量的值:
```shell
set /p {{变量名}}={{提示信息}}
```
{% endraw %}{% raw %}
<h2 id="sfc">
  <a href="/zh/windows/sfc.html">sfc</a> <a href="#sfc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 扫描 Windows 系统文件的完整性.

#### 显示命令的使用方法:
```shell
sfc
```
#### 扫描所有的系统文件，如果可能的话，修复所有出现的问题:
```shell
sfc /scannow
```
#### 扫描系统文件，但不修复出现的问题:
```shell
sfc /verifyonly
```
#### 扫描指定的文件，如果可能的话，修复所有出现的问题:
```shell
sfc /scanfile={{文件的路径}}
```
#### 扫描指定的文件，但不修复出现的问题:
```shell
sfc /verifyfile={{文件的路径}}
```
#### 当离线修复时，指定引导目录:
```shell
sfc /offbootdir={{目录的路径}}
```
#### 当离线修复时，指定 Windows 目录:
```shell
sfc /offwindir={{文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="shutdown">
  <a href="/zh/windows/shutdown.html">shutdown</a> <a href="#shutdown"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于关闭，重新启动或注销计算机的工具.

#### 关闭当前的计算机:
```shell
shutdown /s
```
#### 重启当前的计算机:
```shell
shutdown /r
```
#### 休眠当前的计算机:
```shell
shutdown /h
```
#### 注销当前的计算机:
```shell
shutdown /l
```
#### 指定在关闭之前等待的时间（以秒为单位）:
```shell
shutdown /s /t {{秒}}
```
#### 指定一个关机的理由:
```shell
shutdown /s /c "{{理由}}"
```
#### 在超时之前取消关机指令:
```shell
shutdown /a
```
#### 关闭远程的计算机:
```shell
shutdown /m {{\\ 主机名}}
```
{% endraw %}{% raw %}
<h2 id="subst">
  <a href="/zh/windows/subst.html">subst</a> <a href="#subst"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将路径与虚拟驱动器号关联.

#### 列出已激活的关联:
```shell
subst
```
#### 添加一个关联:
```shell
subst {{Z:}} {{C:\Python2.7}}
```
#### 删除一个关联:
```shell
subst {{Z:}} /d
```
{% endraw %}{% raw %}
<h2 id="systeminfo">
  <a href="/zh/windows/systeminfo.html">systeminfo</a> <a href="#systeminfo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示本地或远程计算机的操作系统配置.

#### 显示本地计算机的操作系统配置:
```shell
systeminfo
```
#### 以指定的输出格式显示系统配置:
```shell
systeminfo /fo {{table|list|csv}}
```
#### 显示远程计算机的系统配置:
```shell
systeminfo /s {{远程主机名}} /u {{用户名}} /p {{密码}}
```
#### 显示详细的帮助信息:
```shell
systeminfo /?
```
{% endraw %}{% raw %}
<h2 id="takeown">
  <a href="/zh/windows/takeown.html">takeown</a> <a href="#takeown"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 取得文件或目录的所有权.
> 更多信息: <https://docs.microsoft.com/windows-server/administration/windows-commands/takeown>.

#### 取得指定文件的所有权:
```shell
takeown /f {{路径/文件}}
```
#### 取得指定目录的所有权:
```shell
takeown /d {{路径/目录}}
```
#### 取得指定目录和所有子目录的所有权:
```shell
takeown /r /d {{路径/目录}}
```
#### 将所有权更改为管理员组，而不是当前用户:
```shell
takeown /a /f {{路径/文件}}
```
{% endraw %}{% raw %}
<h2 id="taskkill">
  <a href="/zh/windows/taskkill.html">taskkill</a> <a href="#taskkill"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 按进程 id 或进程名终止进程.

#### 通过进程 id 终止进程:
```shell
taskkill /pid {{进程 id}}
```
#### 通过进程名终止进程:
```shell
taskkill /im {{进程名}}
```
#### 强制终止一个指定的进程:
```shell
taskkill /pid {{进程名}} /f
```
#### 终止一个进程及其子进程:
```shell
taskkill /im {{进程名}} /t
```
#### 终止远程计算机上的进程:
```shell
taskkill /pid {{进程 id}} /s {{远程主机名}}
```
#### 显示命令的帮助信息:
```shell
taskkill /?
```
{% endraw %}{% raw %}
<h2 id="tasklist">
  <a href="/zh/windows/tasklist.html">tasklist</a> <a href="#tasklist"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示本地或远程计算机上当前正在运行的进程的列表.

#### 显示当前正在运行的进程:
```shell
tasklist
```
#### 使用指定的格式显示当前进程列表:
```shell
tasklist /fo {{table|list|csv}}
```
#### 已匹配的方式 (.exe, .dll) 显示当前运行的进程:
```shell
tasklist /m {{匹配模式}}
```
#### 显示在远程计算机上运行的进程:
```shell
tasklist /s {{远程主机名}} /u {{用户名}} /p {{密码}}
```
#### 显示每个进程中的服务信息:
```shell
tasklist /svc
```
{% endraw %}{% raw %}
<h2 id="title">
  <a href="/zh/windows/title.html">title</a> <a href="#title"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 设置命令提示符窗口的标题.

#### 设置当前的命令提示符窗口的标题:
```shell
title {{新标题}}
```
{% endraw %}{% raw %}
<h2 id="tree">
  <a href="/zh/windows/tree.html">tree</a> <a href="#tree"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 以目录树的形式显示指定目录的所有文件夹和文件.

#### 显示当前目录的目录树:
```shell
tree
```
#### 显示指定目录的目录树:
```shell
tree {{目录的路径}}
```
#### 显示目录中文件的目录树:
```shell
tree {{目录的路径}} /f
```
#### 使用 ASCII 字符而不是扩展字符显示目录树:
```shell
tree {{目录的路径}} /a
```
{% endraw %}{% raw %}
<h2 id="type">
  <a href="/zh/windows/type.html">type</a> <a href="#type"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示文件的内容.

#### 显示特定文件的内容:
```shell
type {{文件的路径}}
```
{% endraw %}{% raw %}
<h2 id="tzutil">
  <a href="/zh/windows/tzutil.html">tzutil</a> <a href="#tzutil"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于显示或配置系统时区的工具.

#### 获取当前的时区:
```shell
tzutil /g
```
#### 显示可用的时区列表:
```shell
tzutil /l
```
#### 将系统时区设置为特定值:
```shell
tzutil /s {{时区 id}}
```
{% endraw %}{% raw %}
<h2 id="ver">
  <a href="/zh/windows/ver.html">ver</a> <a href="#ver"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示当前 Windows 或 MS-DOS 的版本号.

#### Display the current version number:
```shell
ver
```
{% endraw %}{% raw %}
<h2 id="vol">
  <a href="/zh/windows/vol.html">vol</a> <a href="#vol"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示有关卷的信息.

#### 显示当前驱动器的标签和序列号:
```shell
vol
```
#### 显示指定驱动器的标签和序列号:
```shell
vol {{D:}}
```
{% endraw %}{% raw %}
<h2 id="where">
  <a href="/zh/windows/where.html">where</a> <a href="#where"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示与搜索模式匹配的文件的位置.
> 在默认情况下，搜索是在当前目录和 PATH 环境变量指定的路径中执行的.

#### 显示匹配的文件的位置:
```shell
where {{文件模式}}
```
#### 显示匹配的文件的位置、大小和日期:
```shell
where /T {{文件模式}}
```
#### 在指定的路径下递归搜索要匹配的文件:
```shell
where /R {{目录的路径}} {{文件模式}}
```
#### 只返回退出代码，不显示匹配文件列表:
```shell
where /Q {{文件模式}}
```
{% endraw %}{% raw %}
<h2 id="whoami">
  <a href="/zh/windows/whoami.html">whoami</a> <a href="#whoami"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示有关当前用户的详细信息.

#### 显示当前用户的用户名:
```shell
whoami
```
#### 显示当前用户所属的组:
```shell
whoami /groups
```
#### 显示当前用户的权限:
```shell
whoami /priv
```
#### 显示当前用户的用户主体名称 (UPN):
```shell
whoami /upn
```
#### 显示当前用户的登录 id:
```shell
whoami /logonid
```
{% endraw %}{% raw %}
<h2 id="winget">
  <a href="/zh/windows/winget.html">winget</a> <a href="#winget"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Windows 软件包管理器命令行工具.
> 更多信息: <https://docs.microsoft.com/windows/package-manager/winget>.

#### 安装一个软件包:
```shell
winget install {{package}}
```
#### 显示关于一个软件包的信息:
```shell
winget show {{package}}
```
#### 查找一个软件包:
```shell
winget search {{package}}
```
{% endraw %}{% raw %}
<h2 id="wsl">
  <a href="/zh/windows/wsl.html">wsl</a> <a href="#wsl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从命令行管理适用于 Linux 的 Windows 子系统.
> 更多信息: <https://docs.microsoft.com/windows/wsl/reference>.

#### 启动 Linux Shell（在默认发行版中）:
```shell
wsl {{shell_命令}}
```
#### 在不使用 Shell 的情况下运行 Linux 命令:
```shell
wsl --exec {{命令}} {{命令参数}}
```
#### 指定特定的发行版:
```shell
wsl --distribution {{发行版}} {{shell_命令}}
```
#### 列出所有可用发行版:
```shell
wsl --list
```
#### 将发行版导出到 .tar 文件:
```shell
wsl --export {{发行版}} {{路径/distro_fs.tar}}
```
#### 从 .tar 文件导入发行版:
```shell
wsl --import {{发行版}} {{路径/安装位置}} {{路径/distro_fs.tar}}
```
#### 更改指定发行版的版本:
```shell
wsl --set-version {{发行版}} {{版本}}
```
#### 关闭适用于 Linux 的 Windows 子系统:
```shell
wsl --shutdown
```
{% endraw %}{% raw %}
<h2 id="xcopy">
  <a href="/zh/windows/xcopy.html">xcopy</a> <a href="#xcopy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 复制文件和目录树.

#### 复制文件到指定的路径:
```shell
xcopy {{被复制的目录路径}} {{目标路径}}
```
#### 列出在复制前将要被复制的文件:
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /p
```
#### 仅复制目录结构，不包括文件:
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /t
```
#### 复制时包含空目录:
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /e
```
#### 复制文件时保留 ACL 信息:
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /o
```
#### 网络连接丢失时允许恢复:
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /z
```
#### 当文件存在于目标路径中时禁用提示
```shell
xcopy {{文件或目录的路径}} {{目标路径}} /y
```
#### 显示详细的使用帮助:
```shell
xcopy /?
```
{% endraw %}# Sunos
{% raw %}
<h2 id="dmesg">
  <a href="/zh/sunos/dmesg.html">dmesg</a> <a href="#dmesg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将内核消息写入标准输出.
> 更多信息： <https://www.unix.com/man-page/sunos/1m/dmesg>.

#### 显示内核消息:
```shell
dmesg
```
#### 显示此系统上可用的物理内存:
```shell
dmesg | grep -i memory
```
#### 一次显示一页内核消息:
```shell
dmesg | less
```
{% endraw %}# Common
{% raw %}
<h2 id="7z">
  <a href="/zh/common/7z.html">7z</a> <a href="#7z"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个高压缩率的文件归档器.

#### 归档一个文件或文件夹:
```shell
7z a {{归档文件.7z}} {{文件路径}}
```
#### 对已存在的归档文件加密（包括头部）:
```shell
7z a {{加密文件.7z}} -p{{密码}} -mhe=on {{归档文件.7z}}
```
#### 提取一个已存在的 7z 文件，并保持原来的目录结构:
```shell
7z x {{归档文件.7z}}
```
#### 提取一个归档文件到自定义的输出目录:
```shell
7z x {{归档文件.7z}} -o{{输出路径}}
```
#### 使用指定的类型来归档文件:
```shell
7z a -t {{zip|gzip|bzip2|tar|...}} {{归档文件.7z}} {{文件路径}}
```
#### 列出可用的归档文件类型:
```shell
7z i
```
#### 列出一个归档文件的内容:
```shell
7z l {{归档文件.7z}}
```
{% endraw %}{% raw %}
<h2 id="7za">
  <a href="/zh/common/7za.html">7za</a> <a href="#7za"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个高压缩率的文件归档器.
> `7z`的独立版本，支持的文档类型较少.

#### 归档一个文件或文件夹:
```shell
7za a {{归档文件.7z}} {{文件路径}}
```
#### 提取一个已存在的 7z 文件，并保持原来的目录结构:
```shell
7za x {{归档文件文件}}
```
#### 使用指定的类型来归档文件:
```shell
7za a -t{{zip|gzip|bzip2|tar|...}} {{归档文件}} {{文件路径}}
```
#### 列出可用的归档文件类型:
```shell
7za i
```
#### 列出一个归档文件的内容:
```shell
7za l {{归档文件}}
```
{% endraw %}{% raw %}
<h2 id="7zr">
  <a href="/zh/common/7zr.html">7zr</a> <a href="#7zr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个高压缩率的文件归档器.
> `7z`的独立版本，只支持 .7z 文件.

#### 归档一个文件或文件夹:
```shell
7zr a {{归档文件.7z}} {{文件路径}}
```
#### 提取一个已存在的 7z 文件，并保持原来的目录结构:
```shell
7zr x {{归档文件.7z}}
```
#### 列出一个归档文件的内容:
```shell
7zr l {{归档文件.7z}}
```
{% endraw %}{% raw %}
<h2 id="aapt">
  <a href="/zh/common/aapt.html">aapt</a> <a href="#aapt"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 安卓资源包工具（Android Asset Packaging Tools）.
> 该工具可以查看，创建， 更新资源压缩包(zip, jar, apk)。

#### 列出资源压缩包里的内容:
```shell
aapt list {{路径/到/应用.apk}}
```
#### 查看APK包内指定的内容 (版本, 权限许可等):
```shell
aapt dump badging {{路径/到/应用.apk}}
```
#### 打包生成资源压缩包:
```shell
aapt package -F {{路径/到/应用.apk}} {{路径/到/目录}}
```
{% endraw %}{% raw %}
<h2 id="ab">
  <a href="/zh/common/ab.html">ab</a> <a href="#ab"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Apache 基准测试工具.最简单的压力测试工具.

#### 向目标 URL 执行 100 次 HTTP GET 请求:
```shell
ab -n {{100}} {{url}}
```
#### 使用 10 个并发请求，同时向目标 URL 执行 100 次 HTTP GET 请求:
```shell
ab -n {{100}} -c {{10}} {{url}}
```
#### 使用 keep alive:
```shell
ab -k {{url}}
```
#### 为基准测试设置最大的测试时间（单位：秒）:
```shell
ab -t {{60}} {{url}}
```
{% endraw %}{% raw %}
<h2 id="abduco">
  <a href="/zh/common/abduco.html">abduco</a> <a href="#abduco"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 终端会话管理器.

#### 列出会话:
```shell
abduco
```
#### 附加到一个会话，如果不存在则新建它:
```shell
abduco -A {{会话名}} {{终端}}
```
#### 使用`dvtm`附加到一个会话，如果不存在则新建它:
```shell
abduco -A {{会话名}}
```
#### 从一个会话中分离:
```shell
Ctrl + \
```
#### 以只读模式附加到一个会话:
```shell
abduco -Ar {{会话名}}
```
{% endraw %}{% raw %}
<h2 id="ack">
  <a href="/zh/common/ack.html">ack</a> <a href="#ack"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个类似 grep 的搜索工具，为程序员优化.

#### 寻找包含"小明"的文件:
```shell
ack {{小明}}
```
#### 在给定文件类型中寻找包含"小明"的文件:
```shell
ack --ruby {{小明}}
```
#### 计算匹配到"小明"的总次数:
```shell
ack -ch {{小明}}
```
#### 列出内容包含"小明"的文件的文件名，并显示在每个文件中匹配的次数:
```shell
ack -cl {{小明}}
```
{% endraw %}{% raw %}
<h2 id="act">
  <a href="/zh/common/act.html">act</a> <a href="#act"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用Docker本地运行GitHub Actions
> 更多信息: <https://github.com/nektos/act>.

#### 列出可用的actions清单:
```shell
act -l
```
#### 运行默认event:
```shell
act
```
#### 运行指定event:
```shell
act {{事件类型}}
```
#### 运行指定action:
```shell
act -a {{action_id}}
```
#### 非实际运行actions (也就是dry-run模式):
```shell
act -n
```
#### 展示详细记录:
```shell
act -v
```
{% endraw %}{% raw %}
<h2 id="adb-install">
  <a href="/zh/common/adb-install.html">adb install</a> <a href="#adb-install"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 安卓调试桥-Install: 将应用安装包推送到Android模拟器或已连接的安卓设备.
> 更多信息: <https://developer.android.com/studio/command-line/adb>.

#### 向模拟器/设备推送安卓app:
```shell
adb install {{路径/到/应用.apk}}
```
#### 重装app, 保持原有数据:
```shell
adb install -r {{路径/到/应用.apk}}
```
#### 授予app manifest中列举的所有权限许可:
```shell
adb install -g {{路径/到/应用.apk}}
```
#### 快速部署模式，仅更新APK更改过的部分:
```shell
adb install --fastdeploy {{路径/到/应用.apk}}
```
{% endraw %}{% raw %}
<h2 id="adb-reverse">
  <a href="/zh/common/adb-reverse.html">adb reverse</a> <a href="#adb-reverse"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 安卓调试桥-反射: 反向映射安卓模拟器实例或者已连接的实体设备的套接字连接.
> 更多信息: <https://developer.android.com/studio/command-line/adb>.

#### 列出所有来自模拟器和设备的映射连接
```shell
adb reverse —list
```
#### 将TCP端口从安卓模拟器或设备中映射到localhost:
```shell
adb reverse tcp:{{远程端口}} tcp:{{本地端口}}
```
#### 从安卓模拟器或设备移除一个反向socket连接:
```shell
adb reverse --remove tcp:{{远程端口}}
```
#### 从安卓模拟器或设备移除所有反向socket连接:
```shell
adb reverse --remove-all
```
{% endraw %}{% raw %}
<h2 id="adb-shell">
  <a href="/zh/common/adb-shell.html">adb shell</a> <a href="#adb-shell"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 安卓调试桥-Shell: 运行安卓模拟器或者连接设备上的远程终端命令。
> 更多信息: <https://developer.android.com/studio/command-line/adb>.

#### 启动模拟器/设备上的远程终端:
```shell
adb shell
```
#### 获取模拟器/设备全部属性:
```shell
adb shell getprop
```
#### 重置所有运行时权限为它们的默认值:
```shell
adb shell pm reset-permissions
```
#### 撤销一个应用的危险权限:
```shell
adb shell pm revoke {{包名}} {{权限}}
```
#### 触发一个键盘敲击事件:
```shell
adb shell input keyevent {{键位码}}
```
#### 清除模拟器/设备上的数据:
```shell
adb shell pm clear {{包名}}
```
#### 启动模拟器/设备上的一个行为:
```shell
adb shell am start -n {{包名}}/{{活动名}}
```
#### 启动模拟器/设备上的首页活动:
```shell
adb shell am start -W -c android.intent.category.HOME -a android.intent.action.MAIN
```
{% endraw %}{% raw %}
<h2 id="adb">
  <a href="/zh/common/adb.html">adb</a> <a href="#adb"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 安卓调试桥：与 Android 模拟器或已连接的 Android 设备通信.
> 更多信息: <https://developer.android.com/studio/command-line/adb>.

#### 检查 adb server 进程的是否在运行，并开启它:
```shell
adb start-server
```
#### 终止 adb server 进程:
```shell
adb kill-server
```
#### 在目标模拟器 / 设备实例上开启一个远程 shell:
```shell
adb shell
```
#### 将 Android 应用程序推送到模拟器 / 设备 :
```shell
adb install -r {{路径/到/应用.apk}}
```
#### 从目标设备上拷贝一个文件 / 目录到本地:
```shell
adb pull {{路径/到/设备的文件或目录}} {{路径/到/本地上的目录}}
```
#### 从本地拷贝一个文件 / 目录到目标设备:
```shell
adb push {{路径/到/本地文件或目录}} {{路径/到/设备上的目录}}
```
#### 列出已连接的设备:
```shell
adb devices
```
{% endraw %}{% raw %}
<h2 id="adguardhome">
  <a href="/zh/common/adguardhome.html">AdGuardHome</a> <a href="#adguardhome"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一款全网广告拦截与反跟踪软件.
> 更多信息: <https://github.com/AdguardTeam/AdGuardHome>.

#### 运行 AdGuard Home:
```shell
AdGuardHome
```
#### 使用给定的配置文件运行 AdGuard Home:
```shell
AdGuardHome --config {{给定的/配置文件.yaml}}
```
#### 设置存储数据的工作目录:
```shell
AdGuardHome --work-dir {{工作目录/路径}}
```
#### 安装或卸载 AdGuard Home 的服务:
```shell
AdGuardHome --service {{install|uninstall}}
```
#### 启动 AdGuard Home 的服务:
```shell
AdGuardHome --service start
```
#### 刷新 AdGuard Home 服务的设置项:
```shell
AdGuardHome --service reload
```
#### 停止或重启 AdGuard Home 的服务:
```shell
AdGuardHome --service {{stop|restart}}
```
{% endraw %}{% raw %}
<h2 id="ag">
  <a href="/zh/common/ag.html">ag</a> <a href="#ag"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> The Silver Searcher. 类似 ack, 但是更快.
> 更多信息: <https://github.com/ggreer/the_silver_searcher>.

#### 寻找内容包含"小明"的文件，并列出所在的行数:
```shell
ag {{小明}}
```
#### 在指定目录中寻找内容包含"foo"的文件:
```shell
ag {{小明}} {{指定的目录}}
```
#### 寻找内容包含"foo"的文件，但只列出文件名:
```shell
ag -l {{小明}}
```
#### 忽略大小写，寻找内容包含"ABC"的文件，并只输出匹配的内容，而非整行:
```shell
ag -i -o {{ABC}}
```
#### 在文件名包含"小红"的文件中寻找"小明":
```shell
ag {{小明}} -G {{小红}}
```
#### 使用正则表达式来匹配文件内容:
```shell
ag '{{^ba(r|z)$}}'
```
#### 输出文件名包含"小明"的文件名:
```shell
ag -g {{小明}}
```
{% endraw %}{% raw %}
<h2 id="airpaste">
  <a href="/zh/common/airpaste.html">airpaste</a> <a href="#airpaste"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在同一网络下共享信息和文件.
> 更多信息： <https://github.com/mafintosh/airpaste>.

#### 等待接收消息并显示接收到的信息:
```shell
airpaste
```
#### 发送文本:
```shell
echo {{文本}} | airpaste
```
#### 发送文件:
```shell
airpaste < {{文件的路径}}
```
#### 接收文件:
```shell
airpaste > {{文件的路径}}
```
#### 创建 / 加入频道:
```shell
airpaste {{频道名}}
```
{% endraw %}{% raw %}
<h2 id="alacritty">
  <a href="/zh/common/alacritty.html">alacritty</a> <a href="#alacritty"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 跨平台，GPU 加速的终端模拟器.
> 更多信息： <https://github.com/alacritty/alacritty>.

#### 打开一个新的 Alacritty 窗口:
```shell
alacritty
```
#### 运行在指定目录中：
```shell
alacritty --working-directory {{路径}}
```
#### 在新的 Alacritty 窗口中运行命令:
```shell
alacritty -e {{命令}}
```
#### 指定备用配置文件 (默认在 `$XDG_CONFIG_HOME/alacritty/alacritty.yml`):
```shell
alacritty --config-file {{路径/config.yml}}
```
#### 在启用实时配置重新加载的情况下运行（默认情况下也可以在 `alacritty.yml` 中启用）:
```shell
alacritty --live-config-reload --config-file {{路径/config.yml}}
```
{% endraw %}{% raw %}
<h2 id="alias">
  <a href="/zh/common/alias.html">alias</a> <a href="#alias"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建别名 -- 用给定的字符串指代特定的命令.
> 别名只会在当前的 shell 会话中生效，除非它们在 shell 的配置文件中被定义，例如`~/.bashrc`.
> 更多信息： <https://tldp.org/LDP/abs/html/aliases.html>.

#### 创建一个通用的别名:
```shell
alias {{别名}}="{{命令}}"
```
#### 通过给定的别名查看它所指代的命令:
```shell
alias {{别名}}
```
#### 移除一个别名:
```shell
unalias {{别名}}
```
#### 列出所有的别名:
```shell
alias -p
```
#### 将 rm 转换为交互式命令:
```shell
alias {{rm}}="{{rm -i}}"
```
#### 创建别名`la`来指代`ls -a`:
```shell
alias {{la}}="{{ls -a}}"
```
{% endraw %}{% raw %}
<h2 id="androguard">
  <a href="/zh/common/androguard.html">androguard</a> <a href="#androguard"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用python编写的一款针对安卓应用的逆向工程工具.
> 更多信息: <https://github.com/androguard/androguard>.

#### 展示Android manifest清单文件:
```shell
androguard axml {{路径/至/应用.apk}}
```
#### 展示app元数据 (版本和app ID):
```shell
androguard apkid {{路径/至/应用.apk}}
```
#### 反编译Java代码:
```shell
androguard decompile {{路径/至/应用.apk}} --output {{路径/至/目录}}
```
{% endraw %}{% raw %}
<h2 id="ansible-galaxy">
  <a href="/zh/common/ansible-galaxy.html">ansible-galaxy</a> <a href="#ansible-galaxy"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建和管理 Ansible 角色.
> 主页：<https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html>.

#### 安装一个角色:
```shell
ansible-galaxy install {{用户名.角色名}}
```
#### 移除一个角色:
```shell
ansible-galaxy remove {{用户名.角色名}}
```
#### 列出已安装的角色:
```shell
ansible-galaxy list
```
#### 搜索一个指定的角色:
```shell
ansible-galaxy search {{角色名}}
```
#### 创建一个新的角色:
```shell
ansible-galaxy init {{角色名}}
```
{% endraw %}{% raw %}
<h2 id="ansible-playbook">
  <a href="/zh/common/ansible-playbook.html">ansible-playbook</a> <a href="#ansible-playbook"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 通过 SSH 协议在远程计算机上执行 playbook 中定义的任务.
> 主页：<https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html>.

#### 执行 playbook 中的任务:
```shell
ansible-playbook {{playbook}}
```
#### 在给定的主机清单文件中执行 playbook 中的命令:
```shell
ansible-playbook {{playbook}} -i {{清单文件}}
```
#### 通过定义在命令行中额外的变量执行 playbook 中的任务:
```shell
ansible-playbook {{playbook}} -e "{{变量 1}}={{值 1}} {{变量 2}}={{值 2}}"
```
#### 通过定义在一个 json 格式的文件中额外的变量执行 playbook 中的任务:
```shell
ansible-playbook {{playbook}} -e "@{{variables.json}}"
```
{% endraw %}{% raw %}
<h2 id="ansible">
  <a href="/zh/common/ansible.html">ansible</a> <a href="#ansible"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 通过 SSH 协议远程管理计算机组.
> 使用 `/etc/ansible/hosts` 文件来添加组 / 主机.
> 主页：<https://www.ansible.com/>.

#### 列出给定组下的所有主机:
```shell
ansible {{组}} --list-hosts
```
#### 调用 ping 模块来 ping 一组主机:
```shell
ansible {{组}} -m ping
```
#### 通过调用安装模块来显示关于一组主机的信息:
```shell
ansible {{组}} -m setup
```
#### 调用命令模块并使用给定的参数来对一组主机执行命令:
```shell
ansible {{组}} -m command -a '{{命令}}'
```
#### 以管理员权限执行一个命令:
```shell
ansible {{组}} --become --ask-become-pass -m command -a '{{命令}}'
```
#### 使用自定义的清单文件执行一个命令:
```shell
ansible {{组}} -i {{清单文件}} -m command -a '{{命令}}'
```
{% endraw %}{% raw %}
<h2 id="ansiweather">
  <a href="/zh/common/ansiweather.html">ansiweather</a> <a href="#ansiweather"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个 shell 脚本，用于在终端中显示当前的天气状况.

#### 使用公制单位显示 Rzeszow, Poland 接下来 5 天的天气预报:
```shell
ansiweather -u {{metric}} -f {{5}} -l {{Rzeszow,PL}}
```
#### 显示带符号和日光数据信息的天气预报:
```shell
ansiweather -s {{true}} -d {{true}}
```
#### 显示带风力等级和湿度信息的天气预报:
```shell
ansiweather -w {{true}} -h {{true}}
```
{% endraw %}{% raw %}
<h2 id="apg">
  <a href="/zh/common/apg.html">apg</a> <a href="#apg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 生成任意复杂度的随机密码.
> 更多信息： <https://manned.org/apg>.

#### 生成随机密码 （默认密码长度为 8 位）:
```shell
apg
```
#### 生成密码，包含至少 1 个符号 (S), 1 个数字 (N), 1 个大写字母 (C), 1 个小写字母 (L):
```shell
apg -M SNCL
```
#### 生成 16 个字符的密码:
```shell
apg -m {{16}}
```
#### 生成最大长度为 16 位的密码:
```shell
apg -x {{16}}
```
#### 生成未出现在字典中的密码（必须提供字典文件）
```shell
apg -r {{字典文件}}
```
{% endraw %}{% raw %}
<h2 id="apktool">
  <a href="/zh/common/apktool.html">apktool</a> <a href="#apktool"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> APK文件反编译工具
> 更多信息: <https://ibotpeaches.github.io/Apktool/>.

#### 反编译:
```shell
apktool d {{应用.apk}}
```
#### 将一个文件夹打包为apk文件:
```shell
apktool b {{路径/到/目录}}
```
#### 安装并存储框架:
```shell
apktool if {{框架.apk}}
```
{% endraw %}{% raw %}
<h2 id="apm">
  <a href="/zh/common/apm.html">apm</a> <a href="#apm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Atom 编辑器的包管理工具.
> 参见 `atom`.

#### 下载包：http://atom.io/packages 和主题 http://atom.io/themes:
```shell
apm install {{包名}}
```
#### 移除包 / 主题:
```shell
apm remove {{包名}}
```
#### 升级包 / 主题:
```shell
apm upgrade {{包名}}
```
{% endraw %}{% raw %}
<h2 id="apropos">
  <a href="/zh/common/apropos.html">apropos</a> <a href="#apropos"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在 manpages 中搜索，例如查找一个新命令.
> 更多信息： <https://manned.org/apropos>.

#### 搜索关键字:
```shell
apropos {{正则表达式}}
```
#### 搜索时不限制输出到终端宽度:
```shell
apropos -l {{正则表达式}}
```
{% endraw %}{% raw %}
<h2 id="ar">
  <a href="/zh/common/ar.html">ar</a> <a href="#ar"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建，修改，提取库文件 (`.a`, `.so`, `.o`).
> 更多信息： <https://manned.org/ar>.

#### 从库文件中提取全部成员:
```shell
ar -x {{a 文件}}
```
#### 列出库文件中的成员:
```shell
ar -t {{a 文件}}
```
#### 替换或添加文件到库文件:
```shell
ar -r {{要被添加内容的 a 文件}} {{o 文件 1}} {{o 文件 2}} {{o 文件 3}}
```
#### 插入对象文件索引（相当于使用`ranlib`):
```shell
ar -s {{a 文件}}
```
#### 使用文件和附带的目标文件索引创建存档:
```shell
ar -rs {{a 文件}} {{o 文件 1}} {{o 文件 2}} {{o 文件 3}}
```
{% endraw %}{% raw %}
<h2 id="arch">
  <a href="/zh/common/arch.html">arch</a> <a href="#arch"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 展示系统架构的名称.
> 另见`uname`.
> 更多信息： <https://www.gnu.org/software/coreutils/arch>.

#### 展示系统架构.
```shell
arch
```
{% endraw %}{% raw %}
<h2 id="aria2">
  <a href="/zh/common/aria2.html">aria2</a> <a href="#aria2"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个轻量级多协议和多源命令行下载工具
> 支持 HTTP, HTTPS, FTP, SFTP, BitTorrent and Metalink.
> 主页：<https://aria2.github.io/>.

#### 下载一个网络资源:
```shell
aria2c {{http://example.org/myLinux.iso}}
```
#### 从多个源处下载一个资源:
```shell
aria2c {{http://mirror1.org/myLinux.iso}} {{http://mirror2.org/myLinux.iso}}
```
#### 使用两个连接下载资源:
```shell
aria2c -x{{2}} {{http://example.org/myLinux.iso}}
```
#### 从 Metalink URI 中下载资源:
```shell
aria2c {{http://example.org/myLinux.metalink}}
```
#### 从 BitTorrent URI 中下载资源:
```shell
aria2c {{http://example.org/myLinux.torrent}}
```
#### 从 BitTorrent Magnet URI 中下载资源:
```shell
aria2c {{'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C'}}
```
#### 从一个文件中下载资源:
```shell
aria2c -i {{uris.txt}}
```
{% endraw %}{% raw %}
<h2 id="aria2c">
  <a href="/zh/common/aria2c.html">aria2c</a> <a href="#aria2c"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 快速下载工具.
> 支持 HTTP(S), FTP, SFTP, BitTorrent, and Metalink.

#### 下载一个 URI 到文件:
```shell
aria2c {{url}}
```
#### 从多个源处下载一个资源:
```shell
aria2c {{url_1}} {{url_2}}
```
#### 通过保存在一个文件中的 URL 列表来下载资源:
```shell
aria2c -i {{文件名}}
```
#### 使用多个连接下载资源:
```shell
aria2c -s {{连接数量}} {{url}}
```
#### 通过带用户名密码验证的 FTP 协议下载资源:
```shell
aria2c --ftp-user={{用户名}} --ftp-passwd={{密码}} {{url}}
```
#### 限制下载速度 (bytes/s):
```shell
aria2c --max-download-limit={{速度}} {{url}}
```
{% endraw %}{% raw %}
<h2 id="arp">
  <a href="/zh/common/arp.html">arp</a> <a href="#arp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示和操作系统的 ARP 缓存.
> 更多信息： <https://manned.org/arp>.

#### 显示当前的 ARP 表:
```shell
arp -a
```
#### 清除整个缓存:
```shell
sudo arp -a -d
```
#### 删除特定条目:
```shell
arp -d {{地址}}
```
#### 创建指定条目:
```shell
arp -s {{地址}} {{MAC 地址}}
```
{% endraw %}{% raw %}
<h2 id="asar">
  <a href="/zh/common/asar.html">asar</a> <a href="#asar"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Electron 平台的文件打包工具.

#### 打包一个文件或目录:
```shell
asar pack {{文件或目录路径}} {{输出的 asar 文件}}
```
#### 解压一个 asar 文件:
```shell
asar extract {{asar 文件}}
```
#### 从 asar 文件中解压指定的文件:
```shell
asar extract-file {{asar 文件}} {{文件}}
```
#### 列出一个 asar 文件中的内容:
```shell
asar list {{asar 文件}}
```
{% endraw %}{% raw %}
<h2 id="asciinema">
  <a href="/zh/common/asciinema.html">asciinema</a> <a href="#asciinema"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 录制和播放终端会话，也可以把他们分享到 asciinema.org.

#### 将本地安装的`asciinema`与 asciinema.org 账号关联:
```shell
asciinema auth
```
#### 进行新的录制（完成后，将提示用户上传或在本地保存:
```shell
asciinema rec
```
#### 进行新的录制，保存到本地的文件中:
```shell
asciinema rec {{文件路径}}.cast
```
#### 从本地文件中播放终端录屏:
```shell
asciinema play {{文件路径}}.cast
```
#### 在 asciinema.org 中播放终端录屏:
```shell
asciinema play https://asciinema.org/a/{{文件 ID}}
```
#### 进行新的录制，将闲置时间设置为最多 2.5 秒:
```shell
asciinema rec -i {{2.5}}
```
#### 打印本地保存的录像的完整输出:
```shell
asciinema cat {{文件路径}}.cast
```
#### 从本地上传一个录屏到 asciinema.org:
```shell
asciinema upload {{文件路径}}.cast
```
{% endraw %}{% raw %}
<h2 id="asdf">
  <a href="/zh/common/asdf.html">asdf</a> <a href="#asdf"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 可扩展的包版本管理器，支持Nodejs,Ruby,Elixir,Erlang等.
> 更多信息: <https://asdf-vm.com>.

#### 可用插件清单:
```shell
asdf plugin-list-all
```
#### 安装插件:
```shell
asdf plugin-add {{插件名}}
```
#### 软件包的可用版本清单:
```shell
asdf list-all {{软件包名}}
```
#### 安装指定版本的软件包:
```shell
asdf install {{软件包名}} {{版本}}
```
#### 设置软件包的全局安装版本:
```shell
asdf global {{软件包名}} {{版本}}
```
#### 设置软件包的本地版本:
```shell
asdf local {{软件包名}} {{版本}}
```
{% endraw %}{% raw %}
<h2 id="atom">
  <a href="/zh/common/atom.html">atom</a> <a href="#atom"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个跨平台的，可插拔的文本编辑器.
> 由 `apm` 管理插件.
> 更多信息：<https://atom.io/>.

#### 打开文件或目录:
```shell
atom {{path/to/file_or_directory}}
```
#### 在新窗口中打开文件或目录:
```shell
atom -n {{path/to/file_or_directory}}
```
#### 在已有窗口中打开文件或目录:
```shell
atom --add {{path/to/file_or_directory}}
```
#### 以安全模式启动 Atom （不加载额外插件）:
```shell
atom --safe
```
#### 在终端前台运行 Atom:
```shell
atom --foreground
```
{% endraw %}{% raw %}
<h2 id="autoflake">
  <a href="/zh/common/autoflake.html">autoflake</a> <a href="#autoflake"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个工具，用于检查python代码中未被使用的引入和变量.
> 更多信息: <https://github.com/myint/autoflake>.

#### 移除指定文件中未使用的变量，并展示diff:
```shell
autoflake --remove-unused-variables {{文件.py}}
```
#### 移除多个文件中未使用的引入，并展示diffs:
```shell
autoflake --remove-all-unused-imports {{文件1.py}} {{文件2.py}} {{文件3.py}}
```
#### 移除未被使用的变量，并覆盖更新:
```shell
autoflake --remove-unused-variables --in-place {{文件.py}}
```
#### 递归地移除指定文件夹下层所有文件中未使用的变量，并覆盖更新:
```shell
autoflake --remove-unused-variables --in-place --recursive {{路径/到/目录}}
```
{% endraw %}{% raw %}
<h2 id="autojump">
  <a href="/zh/common/autojump.html">autojump</a> <a href="#autojump"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 快速跳转，访问次数最多的文件夹优先.
> 使用j、jc、jo作为别名.
> 更多信息: <https://github.com/wting/autojump>.

#### 跳转到包含指定通配符的目录:
```shell
j {{通配符表达式}}
```
#### 跳转到包含指定通配符的目录的下一级:
```shell
jc {{通配符表达式}}
```
#### 使用系统文件管理器，打开指定的目录:
```shell
jo {{通配符表达式}}
```
#### 从autojump数据库中删除不存在的目录:
```shell
j --purge
```
#### 展示autojump数据库数据:
```shell
j -s
```
{% endraw %}{% raw %}
<h2 id="axel">
  <a href="/zh/common/axel.html">axel</a> <a href="#axel"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一款下载加速器.
> 支持HTTP, HTTPS, 和 FTP.
> 更多信息: <https://github.com/axel-download-accelerator/axel>.

#### 链接下载:
```shell
axel {{超链接}}
```
#### 链接下载，指定文件名:
```shell
axel {{超链接}} -o {{文件名称}}
```
#### 多连接数下载:
```shell
axel -n {{连接数量}} {{超链接}}
```
#### 查询镜像:
```shell
axel -S {{镜像数量}} {{超链接}}
```
#### 限制下载速度 (字节bite每秒):
```shell
axel -s {{字节数}} {{超链接}}
```
{% endraw %}{% raw %}
<h2 id="babel">
  <a href="/zh/common/babel.html">babel</a> <a href="#babel"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一款JavaScript的编译器，将下一代ES语法转换为兼容语法。
> 更多信息: <https://babeljs.io/>.

#### 转编译指定文件到标准输出:
```shell
babel {{路径/到/文件}}
```
#### 转编译指定文件，输入为特定文件:
```shell
babel {{路径/到/输入文件}} --out-file {{路径/到/输出文件}}
```
#### 监听文件变动触发转编译:
```shell
babel {{路径/到/输入文件}} --watch
```
#### 转编译整个目录下的js文件:
```shell
babel {{路径/到/输入文件目录}}
```
#### 跳过指定目录下指定文件的编译（多文件使用英文逗号“,”分隔）:
```shell
babel {{路径/到/输入文件目录}} --ignore {{被忽略文件}}
```
#### 转编译后，执行压缩:
```shell
babel {{路径/到/输入文件}} --minified
```
#### 使用预设值:
```shell
babel {{路径/到/输入文件}} --presets {{预设项}}
```
{% endraw %}{% raw %}
<h2 id="banner">
  <a href="/zh/common/banner.html">banner</a> <a href="#banner"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将给定参数输出为大型 ASCII 文字.
> 更多信息： <https://man.archlinux.org/man/banner.1>.

#### 将文字信息打印为大横幅（引号是可选的）:
```shell
banner "{{Hello World}}"
```
#### 将文字信息打印为横幅，宽度为 50 个字:
```shell
banner -w {{50}} "{{Hello World}}"
```
#### 从 stdin 中读取文本:
```shell
banner
```
{% endraw %}{% raw %}
<h2 id="base32">
  <a href="/zh/common/base32.html">base32</a> <a href="#base32"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将文件或标准输入编码到Base32或从Base32解码为标准输出。
> 更多信息： <https://www.gnu.org/software/coreutils/base32>.

#### 编码一个文件:
```shell
base32 {{文件名}}
```
#### 解码一个文件:
```shell
base32 --decode {{文件名}}
```
#### 从标准输入编码:
```shell
{{某指令}} | base32
```
#### 将标准输入解码:
```shell
{{某指令}} | base32 --decode
```
{% endraw %}{% raw %}
<h2 id="base64">
  <a href="/zh/common/base64.html">base64</a> <a href="#base64"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将文件或标准输入编码到Base64或从Base64解码为标准输出。
> 更多信息： <https://www.gnu.org/software/coreutils/base64>.

#### 编码一个文件:
```shell
base64 {{文件名}}
```
#### 解码一个文件:
```shell
base64 --decode {{文件名}}
```
#### 从标准输入编码:
```shell
{{某指令}} | base64
```
#### 将标准输入解码:
```shell
{{某指令}} | base64 --decode
```
{% endraw %}{% raw %}
<h2 id="basename">
  <a href="/zh/common/basename.html">basename</a> <a href="#basename"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 移除一个路径的目录部分字符.
> 更多信息： <https://www.gnu.org/software/coreutils/basename>.

#### 仅显示文件名:
```shell
basename {{路径/到/文件}}
```
#### 显示路径字符最右边表示目录的字符:
```shell
basename {{路径/到/目录/}}
```
#### 展示无后缀的文件名称:
```shell
basename {{路径/到/文件}} {{后缀}}
```
{% endraw %}{% raw %}
<h2 id="bash">
  <a href="/zh/common/bash.html">bash</a> <a href="#bash"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Bourne-Again SHell.
> 兼容`sh`的命令行解释器.
> 更多信息: <https://gnu.org/software/bash>.

#### 启动交互式 shell:
```shell
bash
```
#### 执行命令:
```shell
bash -c "{{command}}"
```
#### 执行脚本文件:
```shell
bash {{file.sh}}
```
#### 执行脚本文件，并将所有执行过的命令输出到终端:
```shell
bash -x {{file.sh}}
```
#### 执行脚本文件，并在第一个错误处终止:
```shell
bash -e {{file.sh}}
```
#### 从输入 (stdin) 读取命令:
```shell
bash -s
```
#### 将跟随的所有选项原样传递到要执行的脚本文件（可与`-s`选项共用来将选项传递到来自输入的命令 / 脚本）
```shell
bash --
```
#### 打印 bash 的版本信息 （使用`echo $BASH_VERSION`来获得纯粹的版本字符串）:
```shell
bash --version
```
{% endraw %}{% raw %}
<h2 id="bashmarks">
  <a href="/zh/common/bashmarks.html">bashmarks</a> <a href="#bashmarks"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用一个字母的命令，保存或者跳转到常用的目录
> 更多信息: <https://github.com/huyng/bashmarks>.

#### 可访问书签清单:
```shell
l
```
#### 保存当前目录到某书签里:
```shell
s {{书签名}}
```
#### 跳转到指定书签
```shell
g {{书签名}}
```
#### 打印书签目录内容
```shell
p {{书签名}}
```
#### 删除书签：
```shell
d {{书签名}}
```
{% endraw %}{% raw %}
<h2 id="bat">
  <a href="/zh/common/bat.html">bat</a> <a href="#bat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 可以打印并且合并文件的命令.
> `cat`的复制品，外加无法高亮和git集成.
> 更多信息: <https://github.com/sharkdp/bat>.

#### 文件内容打印:
```shell
bat {{文件}}
```
#### 多文件合并到目标文件:
```shell
bat {{文件1}} {{文件2}} > {{目标文件}}
```
#### 在指定文件后追加多个文件合并的内容:
```shell
bat {{文件1}} {{文件2}} >> {{目标文件}}
```
#### 打印时，显示行号:
```shell
bat -n {{文件}}
```
#### 高亮一个json文件:
```shell
bat --language json {{文件.json}}
```
#### 受支持的语言清单:
```shell
bat --list-languages
```
{% endraw %}{% raw %}
<h2 id="behat">
  <a href="/zh/common/behat.html">behat</a> <a href="#behat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 基于Behaviour-Driven Development的自动化测试PHP框架
> 更多信息: <https://behat.org>.

#### 初始化一个PHP behat项目:
```shell
behat --init
```
#### 运行所有测试:
```shell
behat
```
#### 运行指定组所有的测试用例:
```shell
behat --suite={{组名}}
```
#### 运行所有测试，指定输入格式:
```shell
behat --format {{pretty|progress}}
```
#### 将测试结果输出到指定文件:
```shell
behat --out {{路径/到/文件}}
```
#### 展示测试组所在的目录清单:
```shell
behat --definitions
```
{% endraw %}{% raw %}
<h2 id="bg">
  <a href="/zh/common/bg.html">bg</a> <a href="#bg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 恢复被挂起的任务 (如. 使用 `Ctrl + Z`), 使它们在后台运行.
> 更多信息： <https://manned.org/bg>.

#### 恢复最近被挂起的任务，在后台运行:
```shell
bg
```
#### 恢复特定的任务 (使用 `jobs -l` 可以获取任务ID) 并在后台运行:
```shell
bg %{{job_id}}
```
{% endraw %}{% raw %}
<h2 id="bmaptool">
  <a href="/zh/common/bmaptool.html">bmaptool</a> <a href="#bmaptool"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 便捷地创建或复制块文件映射（被设计的比`cp`或`dd`更快）.
> 更多信息: <https://source.tizen.org/documentation/reference/bmaptool>.

#### 使用图片生成块图文件:
```shell
bmaptool create -o {{blockmap格式文件.bmap}} {{图片文件}}
```
#### 复制图片到指定目录:
```shell
bmaptool copy --bmap {{blockmap格式文件}} {{图片文件}} {{/开发路径/sdb}}
```
#### 复制压缩后的图片到指定目录:
```shell
bmaptool copy --bmap {{blockmap格式文件}} {{图片文件.gz}} {{/开发路径/sdb}}
```
#### 复制图片的时候，不将图片转成块图:
```shell
bmaptool copy --nobmap {{图片文件}} {{/开发路径/sdb}}
```
{% endraw %}{% raw %}
<h2 id="bower">
  <a href="/zh/common/bower.html">bower</a> <a href="#bower"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 前端web开发的包管理优化工具。
> 一个包可以是GitHub中user/repo的缩写，一个Git端口，一个URL链接或者一个已注册的包。
> 更多信息: <https://bower.io/>.

#### 安装列在项目下 的bower.json文件中的依赖:
```shell
bower install
```
#### 安装一个或者多个依赖到bower_components目录:
```shell
bower install {{包名1}} {{包名2}}
```
#### 从本地的bower_components目录卸载依赖
```shell
bower uninstall {{包名1}} {{包名2}}
```
#### 列出本地包和可能的更新项:
```shell
bower list
```
#### 显示bower指令的帮助信息:
```shell
bower help {{指令}}
```
#### 创建你的项目的bower.json:
```shell
bower init
```
#### 安装时候指定依赖的版本号，并添加到bower.json:
```shell
bower install {{local_name}}={{package}}#{{version}} --save
```
{% endraw %}{% raw %}
<h2 id="browser-sync">
  <a href="/zh/common/browser-sync.html">browser-sync</a> <a href="#browser-sync"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 启动一个本地的服务，可以监听文件改动，刷新浏览器.
> 更多信息: <https://browsersync.io/docs/command-line>.

#### 将指定目录发成服务:
```shell
browser-sync start --server {{路径/到/目录}} --files {{路径/到/目录}}
```
#### 启动当前目录服务，同时监听指定目录下css文件的变动
```shell
browser-sync start --server --files '{{路径/到/目录/*.css}}'
```
#### 创建配置文件:
```shell
browser-sync init
```
#### 按指定配置文件中的配置启动服务:
```shell
browser-sync start --config {{配置文件}}
```
{% endraw %}{% raw %}
<h2 id="btm">
  <a href="/zh/common/btm.html">btm</a> <a href="#btm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 命令行`top`的替代品.
> 比`top更轻便，支持跨平台、图表更丰富`.
> 更多信息: <https://github.com/ClementTsang/bottom>.

#### 展示默认布局 (cpu, 内存, 温度, 磁盘, 网络和 进程):
```shell
btm
```
#### 开启基础模式,关闭图表和高亮(接近于 `top`):
```shell
btm --basic
```
#### 将图表中的小点换成大点:
```shell
btm --dot_marker
```
#### 展示电池充电和健康状态:
```shell
btm --battery
```
#### 设置图表刷新间隔和留存数据的时长:
```shell
btm --rate 250 --default_time_value 30000
```
{% endraw %}{% raw %}
<h2 id="buku">
  <a href="/zh/common/buku.html">buku</a> <a href="#buku"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 命令行版本的书签管理器.
> 更多信息: <https://github.com/jarun/Buku>.

#### 根据关键词和标签查找书签:
```shell
buku {{关键字}} --stag {{标签}}
```
#### 添加书签，并且打上标签:
```shell
buku --add {{https://example.com}} {{搜索引擎}}, {{标签}}
```
#### 删除一个书签:
```shell
buku --delete {{书签id}}
```
#### 打开编辑器，修改书签:
```shell
buku --write {{书签id}}
```
#### 将指定标签移除:
```shell
buku --update {{书签id}} --tag {{-}} {{搜索引擎}}
```
{% endraw %}{% raw %}
<h2 id="carbon-now">
  <a href="/zh/common/carbon-now.html">carbon-now</a> <a href="#carbon-now"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建漂亮的代码图片。
> 更多信息在 <https://github.com/mixn/carbon-now-cli>.

#### 使用默认设置从文件创建图片:
```shell
carbon-now {{文件}}
```
#### 使用默认设置从剪贴板创建图片:
```shell
carbon-now --from-clipboard
```
#### 使用默认设置从标准输入创建图片:
```shell
{{输入}} | carbon-now
```
#### 以交互方式创建图片以进行自定义设置，还可以选择保存预设:
```shell
carbon-now -i {{文件}}
```
#### 从先前保存的预设创建图片:
```shell
carbon-now -p {{预设}} {{文件}}
```
#### 从指定的文本行开始:
```shell
carbon-now -s {{行号}} {{文件}}
```
#### 结束于指定的文本行:
```shell
carbon-now -e {{行号}} {{文件}}
```
#### 在浏览器中打开图片而不是保存:
```shell
carbon-now --open {{文件}}
```
{% endraw %}{% raw %}
<h2 id="case">
  <a href="/zh/common/case.html">case</a> <a href="#case"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> case ... esac 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构.
> 更多信息： <https://manned.org/case>.

#### 通过字符串字面量判断执行分支:
```shell
case {{入参变量}} in {{字符字面量1}} {{执行语句块1}} ;; {{字符字面量2}}) {{执行语句块2}} ;; *) {{默认执行语句块}} ;; esac
```
#### 搭配通配符进行匹配，判断执行分支:
```shell
case {{入参变量}} in {{通配符或者字符字面量}}) {{执行语句块1}} ; ;; {{通配符或者字符字面量}}) {{执行语句块1}}; ;; *) {{echo "what?"}}; ;; esac
```
{% endraw %}{% raw %}
<h2 id="cat">
  <a href="/zh/common/cat.html">cat</a> <a href="#cat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 打印和拼接文件的工具.
> 更多信息： <https://www.gnu.org/software/coreutils/cat>.

#### 以标准输出，打印文件内容:
```shell
cat {{file}}
```
#### 多文件合并到目标文件:
```shell
cat {{file1}} {{file2}} > {{target_file}}
```
#### 多文件合并，并追加到目标文件:
```shell
cat {{file1}} {{file2}} >> {{target_file}}
```
#### 显示行号:
```shell
cat -n {{file}}
```
#### 显示不可打印和空白的字符 (使用`M-` 前缀标记非ASCII字符):
```shell
cat -v -t -e {{file}}
```
{% endraw %}{% raw %}
<h2 id="cd">
  <a href="/zh/common/cd.html">cd</a> <a href="#cd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 更改当前工作目录.
> 更多信息： <https://man.archlinux.org/man/cd.n>.

#### 转到指定目录:
```shell
cd {{路径}}
```
#### 转到当前用户的主（home）目录:
```shell
cd
```
#### 转到当前目录的父目录:
```shell
cd ..
```
#### 转到刚才选择的目录:
```shell
cd -
```
{% endraw %}{% raw %}
<h2 id="clear">
  <a href="/zh/common/clear.html">clear</a> <a href="#clear"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 清空终端的屏幕.
> 更多信息： <https://manned.org/clear>.

#### 清空屏幕（相当于在 Bash shell 中按 Control-L 键）:
```shell
clear
```
#### 清空屏幕但保留终端的回滚缓冲区:
```shell
clear -x
```
#### 指明要清空的终端类型（默认为环境变量 `TERM` 的值）:
```shell
clear -T {{type_of_terminal}}
```
#### 显示 `clear` 使用的 `ncurses` 版本:
```shell
clear -V
```
{% endraw %}{% raw %}
<h2 id="code">
  <a href="/zh/common/code.html">code</a> <a href="#code"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Visual Studio Code.
> 更多信息: <https://github.com/microsoft/vscode>.

#### 打开 VS Code:
```shell
code
```
#### 在 VS Code 中打开当前目录:
```shell
code .
```
#### 在 VS Code 打开一个文件或目录:
```shell
code {{路径/文件或目录}}
```
#### 在当前打开的 VS Code 窗口中打开一个文件或目录:
```shell
code --reuse-window {{路径/文件或目录}}
```
#### 在 VS Code 中对比两个文件:
```shell
code -d {{文件1}} {{文件2}}
```
#### 用超级用户 (sudo) 权限打开 VS Code:
```shell
sudo code {{路径/文件或目录}} --user-data-dir
```
{% endraw %}{% raw %}
<h2 id="command">
  <a href="/zh/common/command.html">command</a> <a href="#command"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 命令强制 shell 执行命令程序，并忽略具有相同名称的任何函数、内置函数和别名（会忽略掉一切别名，执行命令本身）.
> 更多信息： <https://manned.org/command>.

#### 从字面上执行 `ls` 程序，即使存在 ls 别名:
```shell
command {{ls}}
```
{% endraw %}{% raw %}
<h2 id="cp">
  <a href="/zh/common/cp.html">cp</a> <a href="#cp"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 复制文件和文件夹。
> 更多信息：<https://www.gnu.org/software/coreutils/cp>.

#### 将文件复制到另一个位置：
```shell
cp {{某路径/源文件.ext}} {{某路径/目标文件.ext}}
```
#### 将文件复制到另一个文件夹，并保留原来的文件名：
```shell
cp {{某路径/源文件.ext}} {{某路径/目标文件夹}}
```
#### 以递归方式将文件夹内的内容复制到另一个位置（如果目标文件夹存在，则将此文件夹复制到目标文件夹中）：
```shell
cp -R {{某路径/源文件夹}} {{某路径/目标文件夹}}
```
#### 以详细模式递归复制目录（在复制文件时显示文件信息）：
```shell
cp -vR {{某路径/源文件夹}} {{某路径/目标文件夹}}
```
#### 以交互方式将文本文件复制到另一个位置（覆盖之前会提示用户）：
```shell
cp -i {{*.txt}} {{某路径/目标文件夹}}
```
#### 复制之前，请遵循符号链接：
```shell
cp -L {{符号文件}} {{某路径/目标文件夹}}
```
{% endraw %}{% raw %}
<h2 id="curl">
  <a href="/zh/common/curl.html">curl</a> <a href="#curl"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 向 / 从一个服务器传输数据.
> 支持大多数协议，包括 HTTP, FTP, 和 POP3.
> 更多信息：<https://curl.se>.

#### 将指定 URL 的内容下载到文件:
```shell
curl {{http://example.com}} --output {{文件名}}
```
#### 将文件从 URL 保存到由 URL 指示的文件名中:
```shell
curl --remote-name {{http://example.com/filename}}
```
#### 下载文件，跟随 重定向，并且自动 续传（恢复）前序文件传输:
```shell
curl --remote-name --location --continue-at - {{http://example.com/filename}}
```
#### Send form-encoded data (POST request of type `application/x-www-form-urlencoded`):
```shell
curl --data {{'name=bob'}} {{http://example.com/form}}
```
#### 发送带有额外请求头，使用自定义请求方法的请求:
```shell
curl --header {{'X-My-Header: 123'}} --request {{PUT}} {{http://example.com}}
```
#### 发送 JSON 格式的数据，并附加正确的 `Content-Type` 请求头:
```shell
curl --data {{'{"name":"bob"}'}} --header {{'Content-Type: application/json'}} {{http://example.com/users/1234}}
```
#### 使用用户名和密码，授权访问服务器:
```shell
curl --user myusername:mypassword {{http://example.com}}
```
#### 为指定资源使用客户端证书和密钥，并且跳过证书验证:
```shell
curl --cert {{client.pem}} --key {{key.pem}} --insecure {{https://example.com}}
```
{% endraw %}{% raw %}
<h2 id="echo">
  <a href="/zh/common/echo.html">echo</a> <a href="#echo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 输出给定参数.
> 更多信息： <https://www.gnu.org/software/coreutils/echo>.

#### 输出文本信息. 注意: 引号是可选的:
```shell
echo "{{Hello World}}"
```
#### 输出带有环境变量的信息:
```shell
echo "{{My path is $PATH}}"
```
#### 打印不带尾随换行符的信息：
```shell
echo -n "{{Hello World}}"
```
#### 向文件添加信息:
```shell
echo "{{Hello World}}" >> {{file.txt}}
```
#### 启用反斜杠转义的解释（特殊字符）:
```shell
echo -e "{{Column 1\tColumn 2}}"
```
{% endraw %}{% raw %}
<h2 id="etcd">
  <a href="/zh/common/etcd.html">etcd</a> <a href="#etcd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 分布式，可靠的键值存储，用于分布式系统中存储最关键的数据。
> 更多信息见：<https://etcd.io>.

#### 启动单节点 etcd 集群：
```shell
etcd
```
#### 启动一个单节点 etcd 集群，在自定义 URL 上侦听客户端请求：
```shell
etcd --advertise-client-urls {{http://127.0.0.1:1234}} --listen-client-urls {{http://127.0.0.1:1234}}
```
#### 使用自定义名称启动单节点 etcd 集群：
```shell
etcd --name {{my_etcd_cluster}}
```
#### 启动单节点 etcd 集群，同时可以在这里看到大量监控指标 http://localhost:2379/debug/pprof/:
```shell
etcd --enable-pprof --metrics extensive
```
{% endraw %}{% raw %}
<h2 id="exit">
  <a href="/zh/common/exit.html">exit</a> <a href="#exit"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 退出终端程序。
> 更多信息见：<https://manned.org/exit>.

#### 使用最后执行命令的退出代码，退出终端程序：
```shell
exit
```
#### 使用指定的退出代码，退出终端程序：
```shell
exit {{exit_code}}
```
{% endraw %}{% raw %}
<h2 id="gh-gist">
  <a href="/zh/common/gh-gist.html">gh gist</a> <a href="#gh-gist"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在命令行上使用 GitHub Gists.
> 更多信息: <https://cli.github.com/manual/gh_gist>.

#### 从一个以空格分隔的文件列表中创建一个新的 Gist:
```shell
gh gist create {{路径/文件}}
```
#### 创建一个带有描述的新 Gist:
```shell
gh gist create {{文件名}} --desc "{{描述}}"
```
#### 编辑一个 Gist:
```shell
gh gist edit {{id_或_url}}
```
#### 列出当前登录用户所拥有的 Gist:
```shell
gh gist list --limit {{int}}
```
#### 在默认浏览器中查看 Gist，且不渲染 Markdown:
```shell
gh gist view {{id_或_url}} --web --raw
```
{% endraw %}{% raw %}
<h2 id="gh-repo">
  <a href="/zh/common/gh-repo.html">gh repo</a> <a href="#gh-repo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在命令行上操作 GitHub 仓库.
> 更多信息: <https://cli.github.com/manual/gh_repo>.

#### 创建一个新的仓库(如果没有设置仓库名称，默认将为当前目录的名称):
```shell
gh repo create {{名称}}
```
#### 克隆一个仓库:
```shell
gh repo clone {{拥有者}}/{{仓库}}
```
#### 复刻并克隆一个仓库:
```shell
gh repo fork {{拥有者}}/{{仓库}} --clone
```
#### 在网络浏览器中查看仓库:
```shell
gh repo view {{仓库}} --web
```
{% endraw %}{% raw %}
<h2 id="gpg-zip">
  <a href="/zh/common/gpg-zip.html">gpg-zip</a> <a href="#gpg-zip"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用`GPG`加密存档中的文件和目录。
> 更多信息： <https://www.gnupg.org/documentation/manuals/gnupg/gpg_002dzip.html>.

#### 使用密码将一个目录加密为`archive.gpg`：
```shell
gpg-zip --symmetric --output {{archive.gpg}} {{path/to/directory}}
```
#### 将`archive.gpg`解密到同名目录中：
```shell
gpg-zip --decrypt {{path/to/archive.gpg}}
```
#### 列出加密的`archive.gpg`的内容：
```shell
gpg-zip --list-archive {{path/to/archive.gpg}}
```
{% endraw %}{% raw %}
<h2 id="gpg">
  <a href="/zh/common/gpg.html">gpg</a> <a href="#gpg"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> GNU Privacy Guard。
> 请参阅`gpg2`了解 GNU Privacy Guard 2。
> 更多信息：<https://docs.releng.linuxfoundation.org/en/latest/gpg.html>。

#### 不加密，仅对`doc.txt`进行签名（生成`doc.txt.asc`，格式为 ASCII 码形式）：
```shell
gpg --clearsign {{doc.txt}}
```
#### 对`doc.txt`进行签名并加密（生成`doc.txt.asc`，格式为 ASCII 码形式）：
```shell
gpg --local-user {{sender_id}} --recipient {{recipient_id}} --armor --sign --encrypt {{doc.txt}}
```
#### 为接收者 alice@example.com 加密`doc.txt`（生成`doc.txt.gpg`）：
```shell
gpg --encrypt --recipient {{alice@example.com}} {{doc.txt}}
```
#### 只用密码加密`doc.txt`（生成`doc.txt.gpg`）：
```shell
gpg --symmetric {{doc.txt}}
```
#### 解密`doc.txt.gpg`（输出到标准输出）：
```shell
gpg --decrypt {{doc.txt.gpg}}
```
#### 导入一个公钥：
```shell
gpg --import {{public.gpg}}
```
#### 导出 alice@example.com 的公钥（输出到标准输出）：
```shell
gpg --export --armor {{alice@example.com}}
```
#### 导出 alice@example.com 的私钥（输出到标准输出）：
```shell
gpg --export-secret-keys --armor {{alice@example.com}}
```
{% endraw %}{% raw %}
<h2 id="gpg2">
  <a href="/zh/common/gpg2.html">gpg2</a> <a href="#gpg2"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> GNU Privacy Guard 2。
> GNU Privacy Guard 1 请参见`gpg`。
> 更多信息：<https://docs.releng.linuxfoundation.org/en/latest/gpg.html>。

#### 列出导入的密钥（公钥）：
```shell
gpg2 --list-keys
```
#### 为指定的接收者加密指定的文件，将输出结果写到一个新的文件中，并附加`.gpg`：
```shell
gpg2 --encrypt --recipient {{alice@example.com}} {{path/to/doc.txt}}
```
#### 只用密码（对称加密）对指定文件进行加密，将输出结果写入一个附加`.gpg`的新文件：
```shell
gpg2 --symmetric {{path/to/doc.txt}}
```
#### 解密指定的文件，并将结果写入标准输出：
```shell
gpg2 --decrypt {{path/to/doc.txt.gpg}}
```
#### 导入一个公钥：
```shell
gpg2 --import {{path/to/public_key.gpg}}
```
#### 将指定电子邮件地址的公钥导出到标准输出：
```shell
gpg2 --export --armor {{alice@example.com}}
```
#### 将指定电子邮件地址的私钥导出到标准输出：
```shell
gpg2 --export-secret-keys --armor {{alice@example.com}}
```
{% endraw %}{% raw %}
<h2 id="gpgv">
  <a href="/zh/common/gpgv.html">gpgv</a> <a href="#gpgv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 验证 OpenPGP 签名。
> 更多信息：<https://www.gnupg.org/documentation/manuals/gnupg/gpgv.html>。

#### 验证签名文件：
```shell
gpgv {{path/to/file}}
```
#### 使用分离式签名验证已签名的文件：
```shell
gpgv {{path/to/signature}} {{path/to/file}}
```
#### 在 keyrings 列表中添加一个文件（一个导出的钥匙也算作一个 keyring）：
```shell
gpgv --keyring {{path/to/keyring_file}} {{path/to/signature}} {{path/to/file}}
```
{% endraw %}{% raw %}
<h2 id="gunicorn">
  <a href="/zh/common/gunicorn.html">gunicorn</a> <a href="#gunicorn"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Python 的 WSGI http 服务器.

#### 运行 python web 应用程序:
```shell
gunicorn {{导入路径：应用程序}}
```
#### 在 localhost 上监听 8080 端口:
```shell
gunicorn --bind {{localhost}}:{{8080}} {{导入路径：应用程序}}
```
#### 启用实时自动加载:
```shell
gunicorn --reload {{导入路径：应用程序}}
```
#### 使用 4 个工作进程处理请求:
```shell
gunicorn --workers {{4}} {{导入路径：应用程序}}
```
#### 使用 4 个工作线程处理请求:
```shell
gunicorn --threads {{4}} {{导入路径：应用程序}}
```
#### 通过 https 运行应用程序:
```shell
gunicorn --certfile {{cert.pem}} --keyfile {{key.pem}} {{导入路径：应用程序}}
```
{% endraw %}{% raw %}
<h2 id="heroku">
  <a href="/zh/common/heroku.html">heroku</a> <a href="#heroku"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从命令行创建和管理 Heroku 应用.
> 更多信息: <https://www.heroku.com/>.

#### 登录到你的 heroku 帐户:
```shell
heroku login
```
#### 创建一个 heroku 应用:
```shell
heroku create
```
#### 显示应用的日志:
```shell
heroku logs --app {{app_name}}
```
#### 在 dyno（Heroku 虚拟机）中运行一次性进程:
```shell
heroku run {{process_name}} --app {{app_name}}
```
#### 列出应用的 dyno（Heroku 虚拟机）:
```shell
heroku ps --app {{app_name}}
```
#### 永久销毁应用:
```shell
heroku destroy --app {{app_name}}
```
{% endraw %}{% raw %}
<h2 id="hexo">
  <a href="/zh/common/hexo.html">hexo</a> <a href="#hexo"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 快速、简洁且高效的博客框架.
> 更多信息: <https://hexo.io/>.

#### 初始化一个网站:
```shell
hexo init {{path/to/directory}}
```
#### 创建一篇新文章:
```shell
hexo new {{layout}} {{title}}
```
#### 构建静态文件:
```shell
hexo generate
```
#### 启动本地服务器:
```shell
hexo server
```
#### 部署网站:
```shell
hexo deploy
```
#### 清理缓存文件 (`db.json`) 和生成的文件 (`public/`):
```shell
hexo clean
```
{% endraw %}{% raw %}
<h2 id="jar">
  <a href="/zh/common/jar.html">jar</a> <a href="#jar"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Java 应用程序 / 类库打包程序。
> 更多信息见：<https://docs.oracle.com/javase/tutorial/deployment/jar/basicsindex.html>.

#### 将当前目录中的所有文件递归归档到 `.jar` 文件中：
```shell
jar cf {{file.jar}} *
```
#### 将 `.jar` / `.war` 文件解压缩到当前目录：
```shell
jar -xvf {{file.jar}}
```
#### 列出 `.jar` / `.war` 文件内容：
```shell
jar tf {{path/to/file.jar}}
```
#### 列出带有详细输出的 `.jar` / `.war` 文件内容：
```shell
jar tvf {{path/to/file.jar}}
```
{% endraw %}{% raw %}
<h2 id="jarsigner">
  <a href="/zh/common/jarsigner.html">jarsigner</a> <a href="#jarsigner"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 签名并验证 Java 存档（JAR）文件。
> 更多信息见：<https://docs.oracle.com/javase/9/tools/jarsigner.htm>.

#### 签名一个 `JAR` 文件：
```shell
jarsigner {{path/to/file.jar}} {{keystore_alias}}
```
#### 使用特定算法对 `JAR` 文件进行签名：
```shell
jarsigner -sigalg {{algorithm}} {{path/to/file.jar}} {{keystore_alias}}
```
#### 验证 `JAR` 文件的签名：
```shell
jarsigner -verify {{path/to/file.jar}}
```
{% endraw %}{% raw %}
<h2 id="java">
  <a href="/zh/common/java.html">java</a> <a href="#java"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Java 程序启动器.
> 更多信息: <https://java.com>.

#### 通过提供类名称运行一个含有 main 函数的 java .class 程序:
```shell
java {{类名称}}
```
#### 运行一个 .jar 程序:
```shell
java -jar {{文件名.jar}}
```
#### 运行一个 .jar 程序并且在端口5005等待调试器:
```shell
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005 -jar {{文件名.jar}}
```
#### 显示 JDK, JRE 和 HotSpot 的版本:
```shell
java -version
```
#### 显示详细的帮助:
```shell
java -help
```
{% endraw %}{% raw %}
<h2 id="javac">
  <a href="/zh/common/javac.html">javac</a> <a href="#javac"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Java 程序编译器.

#### 编译一个 `.java` 文件:
```shell
javac {{文件名.java}}
```
#### 编译多个 `.java` 文件:
```shell
javac {{文件名1.java}} {{文件名2.java}} {{文件名3.java}}
```
#### 编译当前目录内所有 `.java` 文件:
```shell
javac {{*.java}}
```
#### 编译一个 `.java` 文件并将生成的 class 字节码文件放入一个指定目录:
```shell
javac -d {{输出目录}} {{文件名.java}}
```
{% endraw %}{% raw %}
<h2 id="javadoc">
  <a href="/zh/common/javadoc.html">javadoc</a> <a href="#javadoc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从源代码以 HTML 格式生成 Java API 文档。
> 更多信息见：https://docs.oracle.com/javase/9/javadoc/javadoc-command.htm>.

#### 生成 Java 源代码的文档并将结果保存在文件夹中：
```shell
javadoc -d {{path/to/directory/}} {{path/to/java_source_code}}
```
#### 生成指定编码的文档：
```shell
javadoc -docencoding {{UTF-8}} {{path/to/java_source_code}}
```
#### 生成文档时，排除掉某些软件包：
```shell
javadoc -exclude {{package_list}} {{path/to/java_source_code}}
```
{% endraw %}{% raw %}
<h2 id="jps">
  <a href="/zh/common/jps.html">jps</a> <a href="#jps"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示当前用户的 JVM 进程状态。
> 详细信息见：<https://docs.oracle.com/en/java/javase/11/tools/jps.html>.

#### 列出所有 JVM 进程：
```shell
jps
```
#### 列出所有 JVM 进程，只打印进程号：
```shell
jps -q
```
#### 显示传递给进程的参数：
```shell
jps -m
```
#### 显示所有进程的完整软件包名称：
```shell
jps -l
```
#### 显示传递给 JVM 的参数：
```shell
jps -v
```
{% endraw %}{% raw %}
<h2 id="make">
  <a href="/zh/common/make.html">make</a> <a href="#make"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Makefile 文件描述目标的任务运行器。
> 通常用于控制源代码中可执行文件的编译。
> 更多信息见：<https://www.gnu.org/software/make/manual/make.html>.

#### 调用 Makefile 中指定的第一个目标（通常命名为 "all"）：
```shell
make
```
#### 调用指定目标：
```shell
make {{目标}}
```
#### 调用一个指定的目标，一次并行执行4个作业：
```shell
make -j{{4}} {{目标}}
```
#### 使用指定的 Makefile 文件：
```shell
make --file {{文件}}
```
#### 从另一个目录执行 make ：
```shell
make --directory {{文件夹}}
```
#### 即使源文件未更改，也强制执行目标：
```shell
make --always-make {{目标}}
```
#### 覆盖在 Makefile 中定义的环境变量：
```shell
make --environment-overrides {{目标}}
```
{% endraw %}{% raw %}
<h2 id="matlab">
  <a href="/zh/common/matlab.html">matlab</a> <a href="#matlab"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> MathWorks 制作的数值计算环境。
> 更多信息: <https://uk.mathworks.com/help/matlab/>.

#### 在启动过程中，运行时不出现闪屏:
```shell
matlab -nosplash
```
#### 执行 MATLAB 语句:
```shell
matlab -r "{{matlab_语句}}"
```
#### 运行 MATLAB 脚本:
```shell
matlab -r "run({{路径/script.m}})"
```
{% endraw %}{% raw %}
<h2 id="md5sum">
  <a href="/zh/common/md5sum.html">md5sum</a> <a href="#md5sum"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 计算 MD5 加密校验和.
> 更多信息： <https://www.gnu.org/software/coreutils/md5sum>.

#### 计算文件的 MD5 校验和:
```shell
md5sum {{filename1}}
```
#### 计算多个文件的 MD5 校验和:
```shell
md5sum {{filename1}} {{filename2}}
```
#### 读取 MD5SUM 的文件并验证所有文件是否具有匹配的校验和:
```shell
md5sum -c {{filename.md5}}
```
{% endraw %}{% raw %}
<h2 id="mongod">
  <a href="/zh/common/mongod.html">mongod</a> <a href="#mongod"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> MongoDB 数据库服务器。
> 更多信息见：<https://docs.mongodb.com/manual/reference/program/mongod>.

#### 指定配置文件：
```shell
mongod --config {{filename}}
```
#### 指定要监听的端口：
```shell
mongod --port {{port}}
```
#### 指定数据库分析级别，用于性能调优分析。 0 - 关闭，1 - 仅是记录慢速操作，2 - 全部：
```shell
mongod --profile {{0|1|2}}
```
{% endraw %}{% raw %}
<h2 id="mpv">
  <a href="/zh/common/mpv.html">mpv</a> <a href="#mpv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个基于 MPlayer 的音频/视频播放器.
> 更多信息: <https://mpv.io>.

#### 播放一个音频或视频文件:
```shell
mpv {{文件名}}
```
#### 往后/往前 跳跃5秒:
```shell
LEFT <or> RIGHT
```
#### 往后/往前 跳跃一分钟:
```shell
DOWN <or> UP
```
#### 减少/增加 10% 播放速度:
```shell
[ <or> ]
```
#### 以指定速度播放文件 (0.01 到 100, 默认是 1):
```shell
mpv --speed {{速度}} {{文件名}}
```
#### 用 `mpv.conf` 中指定的一个用户配制播放文件:
```shell
mpv --profile {{配制名称}} {{文件名}}
```
#### 播放摄像头或其他设备的输出:
```shell
mpv /dev/{{video0}}
```
{% endraw %}{% raw %}
<h2 id="mvn">
  <a href="/zh/common/mvn.html">mvn</a> <a href="#mvn"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Apache Maven.
> 用于构建和管理基于 Java 的项目的工具。
> 更多信息见：<https://maven.apache.org>.

#### 编译项目：
```shell
mvn compile
```
#### 将编译后的代码打包成可分发格式，比如 `jar`：
```shell
mvn package
```
#### 编译和打包，跳过单元测试：
```shell
mvn package -Dmaven.test.skip=true
```
#### 在本地 maven 存储库中安装构建的包（这也会调用 compile 和 package 命令）：
```shell
mvn install
```
#### 从目标目录中删除构建工件，通常用来清理之前的编译结果：
```shell
mvn clean
```
#### 执行清理操作，然后进行编译打包：
```shell
mvn clean package
```
#### 执行清理操作并使用给定的构建配置打包代码，比如 `profileId` 如果有dev、test、pro，可以指定其中一个 `profileId` 用来选择具体执行环境：
```shell
mvn clean -P{{profileId}} package
```
#### 使用 main 方法运行一个类：
```shell
mvn exec:java -Dexec.mainClass="{{com.example.Main}}" -Dexec.args="{{参数1 参数2}}"
```
{% endraw %}{% raw %}
<h2 id="ninja">
  <a href="/zh/common/ninja.html">ninja</a> <a href="#ninja"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一个快速的构建系统.
> 更多信息: <https://ninja-build.org/manual.html>.

#### 在当前目录下构建:
```shell
ninja
```
#### 在指定的目录中构建一个程序:
```shell
ninja -C {{路径}}
```
#### 查看 target（如 `install` 和 `uninstall`):
```shell
ninja -t targets
```
#### 查看帮助:
```shell
ninja -h
```
{% endraw %}{% raw %}
<h2 id="nmap">
  <a href="/zh/common/nmap.html">nmap</a> <a href="#nmap"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 网络探索工具和安全/端口扫描程序。
> 仅当以特权运行 Nmap 时，某些功能才激活。
> 更多信息见: <https://nmap.org>.

#### 检查IP地址是否可用，并猜测远程主机的操作系统：
```shell
nmap -O {{IP 或者 主机名}}
```
#### 尝试确定指定的主机是否启动以及它们的名称是什么：
```shell
nmap -sn {{IP 或者 主机名}} {{可选的其它地址}}
```
#### 像上面一样，如果主机启动了，还可以运行默认的1000端口TCP扫描：
```shell
nmap {{IP 或者 主机名}} {{可选的其它地址}}
```
#### 也可以启用脚本，服务检测，操作系统指纹识别和跟踪路由：
```shell
nmap -A {{一个地址 或者 多个地址}}
```
#### 假设网络连接良好并加快执行速度：
```shell
nmap -T4 {{一个地址 或者 多个地址}}
```
#### 扫描端口的特定列表（使用 `-p` 参数覆盖所有端口，如 `-p 1-65535`，也可以明确指定几个端口，如 `-p 3306,3307,3308`）：
```shell
nmap -p {{端口1, 端口2, ..., 端口N}} {{一个地址 或者 多个地址}}
```
#### 执行 TCP 和 UDP 扫描（`-sU` 只用 UDP 扫描，`-sZ` 用 SCTP 扫描，`-sO` 用于 IP 扫描）：
```shell
nmap -sSU {{一个地址 或者 多个地址}}
```
#### 使用默认 NSE 脚本执行针对该主机地址的完整端口、服务、版本检测扫描，以确定弱点和信息：
```shell
nmap -sC -sV {{一个地址 或者 多个地址}}
```
{% endraw %}{% raw %}
<h2 id="node">
  <a href="/zh/common/node.html">node</a> <a href="#node"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 服务器后端 JavaScript 平台 (Node.js).
> 更多信息: <https://nodejs.org>.

#### 运行一个 JavaScript 文件:
```shell
node {{文件名}}
```
#### 开始一个 REPL 交互式解释器:
```shell
node
```
#### 执行输入的 JavaScript 代码:
```shell
node -e "{{代码}}"
```
#### 执行输入的 JavaScript 代码并显示结果:
```shell
node -p "{{代码}}"
```
#### 启动检查器并在程序源码解析完成后等待调试器连接:
```shell
node --no-lazy --inspect-brk {{文件名}}
```
{% endraw %}{% raw %}
<h2 id="rsync">
  <a href="/zh/common/rsync.html">rsync</a> <a href="#rsync"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 一种快速，通用，远程（和本地）文件复制工具。
> 更多信息：<https://man7.org/linux/man-pages/man1/rsync.1.html>。

#### 从本地传输文件到远程主机：
```shell
rsync {{path/to/local_file}} {{remote_host}}:{{path/to/remote_directory}}
```
#### 从远程主机传输文件到本地：
```shell
rsync {{remote_host}}:{{path/to/remote_file}} {{path/to/local_directory}}
```
#### 将本地文件以归档模式并保留几乎所有属性，同时使用压缩功能传输到远程主机，并以人类可读方式输出详细信息和进度条：
```shell
rsync --archive --compress --verbose --human-readable --progress {{path/to/local_file}} {{remote_host}}:{{path/to/remote_directory}}
```
#### 将远程主机目录上的所有文件，以递归模式传输到本地：
```shell
rsync --recursive {{remote_host}}:{{path/to/remote_directory}} {{path/to/local_directory}}
```
#### 将远程主机该目录下的所有内容（不包含该目录），以递归方式传输到本地：
```shell
rsync --recursive {{remote_host}}:{{path/to/remote_directory}}/ {{path/to/local_directory}}
```
#### 递归方式传输目录，保留几乎所有属性，解析软连接，并忽略已传输的文件：
```shell
rsync --recursive --archive --update --copy-links {{remote_host}}:{{path/to/remote_file}} {{path/to/local_directory}}
```
#### 指定本地和远程之间通信方式：
```shell
rsync --rsh ssh {{remote_host}}:{{path/to/remote_file}} {{path/to/local_file}}
```
#### 指定本地和远程之间通信方式，使用指定端口，并显示进度条：
```shell
rsync --rsh 'ssh -p {{port}}' --progress {{remote_host}}:{{path/to/remote_file}} {{path/to/local_file}}
```
{% endraw %}{% raw %}
<h2 id="runit">
  <a href="/zh/common/runit.html">runit</a> <a href="#runit"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 三级初始化系统.
> 更多信息： <https://wiki.archlinux.org/index.php/Runit>.

#### 启动 runit 的三阶段初始化方案:
```shell
runit
```
#### 停止运行 runit:
```shell
kill --CONT {{runit 进程 id}}
```
{% endraw %}{% raw %}
<h2 id="runsv">
  <a href="/zh/common/runsv.html">runsv</a> <a href="#runsv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 启动和管理 runit 服务.
> 更多信息： <https://manpages.ubuntu.com/manpages/latest/man8/runsv.8.html>.

#### 以当前用户身份启动 runit 服务:
```shell
runsv {{目录 / 服务文件}}
```
#### 以 root 用户身份启动 runit 服务:
```shell
sudo runsv {{目录 / 服务文件}}
```
{% endraw %}{% raw %}
<h2 id="runsvchdir">
  <a href="/zh/common/runsvchdir.html">runsvchdir</a> <a href="#runsvchdir"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 更改默认使用的 `runsvdir` 目录.
> 更多信息： <https://manpages.ubuntu.com/manpages/latest/man8/runsvchdir.8.html>.

#### 切换 `runsvdir` 目录:
```shell
sudo runsvchdir {{指定 / 目录}}
```
{% endraw %}{% raw %}
<h2 id="runsvdir">
  <a href="/zh/common/runsvdir.html">runsvdir</a> <a href="#runsvdir"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 运行整个目录下的服务.
> 更多信息： <https://manpages.ubuntu.com/manpages/latest/man8/runsvdir.8.html>.

#### 以当前用户身份启动和管理目录中的所有服务:
```shell
runsvdir {{目录 / 服务文件}}
```
#### 以 root 用户身份启动和管理目录中的所有服务:
```shell
sudo runsvdir {{目录 / 服务文件}}
```
#### 在单独会话中启动服务:
```shell
runsvdir -P {{目录 / 服务文件}}
```
{% endraw %}{% raw %}
<h2 id="rustfmt">
  <a href="/zh/common/rustfmt.html">rustfmt</a> <a href="#rustfmt"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 格式化 Rust 源代码的工具.
> 更多信息: <https://github.com/rust-lang/rustfmt>.

#### 格式化文件，就地覆盖原始文件:
```shell
rustfmt {{source.rs}}
```
#### 检查文件的格式并在控制台上显示所有更改:
```shell
rustfmt --check {{source.rs}}
```
#### 格式化之前，备份所有修改过的文件(原始文件的扩展名为 `.bk`):
```shell
rustfmt --backup {{source.rs}}
```
{% endraw %}{% raw %}
<h2 id="shasum">
  <a href="/zh/common/shasum.html">shasum</a> <a href="#shasum"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 计算或检查加密 SHA 校验值.

#### 计算文件的 SHA1 校验值:
```shell
shasum {{文件名}}
```
#### 计算文件的 SHA256 校验值:
```shell
shasum --algorithm 256 {{文件名}}
```
#### 计算多个文件的 SHA512 校验值:
```shell
shasum --algorithm 512 {{文件名 1}} {{文件名 2}}
```
#### 计算一个文件内列出的所有的目录文件的相对应的总数:
```shell
shasum --check {{列表文件}}
```
#### 从标准输入中获取并计算 SHA1 校验值:
```shell
{{其他命令}} | shasum
```
{% endraw %}{% raw %}
<h2 id="stty">
  <a href="/zh/common/stty.html">stty</a> <a href="#stty"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 设置终端设备接口的选项.
> 更多信息： <https://www.gnu.org/software/coreutils/stty>.

#### 显示当前终端的所有设置:
```shell
stty -a
```
#### 设置行数:
```shell
stty rows {{行数}}
```
#### 设置列数:
```shell
stty cols {{列数}}
```
#### 获取设备的实际传输速度:
```shell
stty -F {{目标 / 文件夹 / 驱动设备文件}} speed
```
#### 将当前终端的所有模式重置为合理值:
```shell
stty sane
```
{% endraw %}{% raw %}
<h2 id="sv">
  <a href="/zh/common/sv.html">sv</a> <a href="#sv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 控制正在运行的服务.
> 更多信息： <https://manpages.ubuntu.com/manpages/latest/man8/sv.8.html>.

#### 启动服务:
```shell
sudo sv up {{目标目录 / 服务文件}}
```
#### 停止服务:
```shell
sudo sv down {{目标目录 / 服务文件}}
```
#### 获取服务状态:
```shell
sudo sv status {{目标目录 / 服务文件}}
```
{% endraw %}{% raw %}
<h2 id="tldr">
  <a href="/zh/common/tldr.html">tldr</a> <a href="#tldr"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 简化过的 man 帮助手册.
> 更多信息：<https://tldr.sh>.

#### 获取一个命令的用例 （提示：这就是你怎么得到本信息的）:
```shell
tldr {{command}}
```
#### 展示 Linux 下 tar 的 tldr 文档:
```shell
tldr -p {{linux}} {{tar}}
```
#### 获取一个 Git 子命令的帮助:
```shell
tldr {{git checkout}}
```
#### 更新本地页面 (如果客户端支持缓存):
```shell
tldr -u
```
{% endraw %}{% raw %}
<h2 id="uname">
  <a href="/zh/common/uname.html">uname</a> <a href="#uname"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 输出关于当前机器和运行在该机器上的操作系统的详细信息。
> 注意：如需了解操作系统的其他信息，请尝试使用 `lsb_release` 命令。
> 更多信息： <https://www.gnu.org/software/coreutils/uname>.

#### 打印硬件相关信息：机器和处理器：
```shell
uname -mp
```
#### 打印软件相关信息：操作系统、发行号和版本：
```shell
uname -srv
```
#### 打印系统的名称（主机名）：
```shell
uname -n
```
#### 打印所有可用的系统信息（硬件、软件、名称）：
```shell
uname -a
```
{% endraw %}{% raw %}
<h2 id="units">
  <a href="/zh/common/units.html">units</a> <a href="#units"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 提供两个度量单位之间的转换.
> 更多信息： <https://www.gnu.org/software/units/>.

#### 以交互模式运行:
```shell
units
```
#### 显示两个简单单位之间的转换:
```shell
units {{quarts（夸脱）}} {{tablespoons（大汤匙）}}
```
#### 单位与数量之间的转换:
```shell
units "{{15 pounds（磅）}}" {{kilograms（公斤）}}
```
#### 显示两个复合单位之间的转换:
```shell
units "{{meters（米） / second（秒）}}" "{{inches（英尺） / hour（小时）}}"
```
#### 显示具有不同维度的单位之间的转换:
```shell
units "{{acres（英亩）}}" "{{ft（英尺）^2（平方）}}"
```
#### 显示字节乘数的转换:
```shell
units "{{15 megabytes（兆字节）}}" {{bytes（字节）}}
```
{% endraw %}{% raw %}
<h2 id="view">
  <a href="/zh/common/view.html">view</a> <a href="#view"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> `vim` 的只读版本.
> 等效于 `vim -R`.

#### 打开文件:
```shell
view {{file}}
```
{% endraw %}{% raw %}
<h2 id="vim">
  <a href="/zh/common/vim.html">vim</a> <a href="#vim"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Vi IMproved, 一个程序员的文本编辑器，提供为不同类型的文档修改设计的多种模式
> 在`vim`内使用任何命令时请确认未使用中文输入法，否则可能会出现奇怪的问题
> 按下`i`来进入编辑模式，`<esc>`回到标准模式 （不允许普通的字符输入）
> 更多信息：<https://www.vim.org>.

#### 打开文档:
```shell
vim {{file}}
```
#### 进入编辑模式 （插入模式）:
```shell
<Esc>i
```
#### 复制 ("yank") 或剪切 ("delete") 当前行 （使用`P`来粘贴）:
```shell
<Esc>{{yy|dd}}
```
#### 撤销上一个操作:
```shell
<Esc>u
```
#### 在文件中搜寻 （按下 `n`/`N` 来在上一个 / 下一个结果中切换）:
```shell
<Esc>/{{search_pattern}}<Enter>
```
#### 对整个文件使用正则表达式进行替换:
```shell
<Esc>:%s/{{pattern}}/{{replacement}}/g<Enter>
```
#### 保存 （写入） 文件，然后退出:
```shell
<Esc>:wq<Enter>
```
#### 不保存退出:
```shell
<Esc>:q!<Enter>
```
{% endraw %}{% raw %}
<h2 id="virtualenv">
  <a href="/zh/common/virtualenv.html">virtualenv</a> <a href="#virtualenv"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 创建被隔离的的 Python 虚拟环境.
> 更多信息：<https://virtualenv.pypa.io/>.

#### 创建新环境:
```shell
virtualenv {{path/to/venv}}
```
#### 自定义提示符:
```shell
virtualenv --prompt={{prompt_prefix}} {{path/to/venv}}
```
#### 为虚拟环境使用不同的 Python 版本:
```shell
virtualenv --python={{path/to/pythonbin}} {{path/to/venv}}
```
#### 启动 （选择） 环境:
```shell
source {{path/to/venv}}/bin/activate
```
#### 停止环境:
```shell
deactivate
```
{% endraw %}{% raw %}
<h2 id="vlc">
  <a href="/zh/common/vlc.html">vlc</a> <a href="#vlc"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 跨平台多媒体播放器.
> 更多信息: <https://www.videolan.org/vlc/>.

#### 播放一个文件:
```shell
vlc {{文件名}}
```
#### 全屏播放:
```shell
vlc --fullscreen {{文件名}}
```
#### 静音播放:
```shell
vlc --no-audio {{文件名}}
```
#### 循环播放:
```shell
vlc --loop {{文件名}}
```
#### 播放网络连接:
```shell
vlc {{连接}}
```
{% endraw %}{% raw %}
<h2 id="vue-cli">
  <a href="/zh/common/vue.html">vue-cli</a> <a href="#vue-cli"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 用于初始化 Vue.js 项目的 CLI.
> 本帮助适用于旧的 `vue-cli@2` 和 `@vue/cli-init` 插件，新版 CLI 文档请参见更多信息
> 官方模板包括：webpack, webpack-simple, browserify, browserify-simple, simple.
> 更多信息：<https://cli.vuejs.org>.

#### 从模板创建新项目:
```shell
vue init {{template}} {{project_name}}
```
#### 从本地模板创建新项目:
```shell
vue init {{path/to/template_directory}} {{project_name}}
```
#### 从 GitHub 上拉取模板并创建新项目:
```shell
vue init {{username}}/{{repo}} {{project_name}}
```
{% endraw %}{% raw %}
<h2 id="w">
  <a href="/zh/common/w.html">w</a> <a href="#w"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示有哪些用户登录了本机以及他们当前的活动.
> 打印用户登录，TTY, 远程主机，登录时间，闲置时间，当前进程.

#### 获取已登录用户信息:
```shell
w
```
#### 无标题栏模式:
```shell
w -h
```
{% endraw %}{% raw %}
<h2 id="wget">
  <a href="/zh/common/wget.html">wget</a> <a href="#wget"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 从网络上下载文件.
> 支持 HTTP, HTTPS, 和 FTP.
> 更多信息：<https://www.gnu.org/software/wget>.

#### 将该 URL 的内容下载到文件中 （在这个例子中文件名为 "foo"）:
```shell
wget {{https://example.com/foo}}
```
#### 将该 URL 的内容下载到文件中 （在这个例子中文件名为 "bar"）:
```shell
wget --output-document {{bar}} {{https://example.com/foo}}
```
#### 以每三秒一个请求的速度下载一个网页和其所有资源 （脚本，样式表，图片等等）:
```shell
wget --page-requisites --convert-links --wait=3 {{https://example.com/somepage.html}}
```
#### 从一个目录中下载所有列出的文件和其所有子文件夹 （不下载内嵌网页）:
```shell
wget --mirror --no-parent {{https://example.com/somepath/}}
```
#### 限制下载速度和重试次数:
```shell
wget --limit-rate={{300k}} --tries={{100}} {{https://example.com/somepath/}}
```
#### 使用基本授权来从 HTTP/FTP 服务器中下载文件:
```shell
wget --user={{username}} --password={{password}} {{https://example.com}}
```
#### 继续一个未完成的下载任务:
```shell
wget --continue {{https://example.com}}
```
#### 将指定文件中所有列出的 URL 下载到一个目录中:
```shell
wget --directory-prefix {{path/to/directory}} --input-file {{URLs.txt}}
```
{% endraw %}{% raw %}
<h2 id="where">
  <a href="/zh/common/where.html">where</a> <a href="#where"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 报告所有已知的命令入口.
> 它可以是一个在`PATH`中的可执行文件，一个别名，或者一个 shell 內建命令.

#### 报告所有已知命令入口:
```shell
where {{command}}
```
{% endraw %}{% raw %}
<h2 id="which">
  <a href="/zh/common/which.html">which</a> <a href="#which"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 在用户的`PATH`中寻找可执行文件的路径

#### 在`PATH`中寻找可执行文件并打印第一个匹配的结果:
```shell
which {{executable}}
```
#### 如果有多个匹配结果则打印所有结果:
```shell
which -a {{executable}}
```
{% endraw %}{% raw %}
<h2 id="write">
  <a href="/zh/common/write.html">write</a> <a href="#write"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 向某个终端上的特定用户的屏幕写入信息 （Ctrl-C 来停止写入）.
> 使用 `who` 命令来获取所有活动用户的终端 id. 参见 `mesg`.

#### 向指定的终端 ID 上的指定用户写入信息:
```shell
write {{username}} {{terminal_id}}
```
#### 向终端 "/dev/tty/5" 上的用户 "testuser" 发送信息:
```shell
write {{testuser}} {{tty/5}}
```
#### 向伪终端 "/dev/pts/5" 上的用户 "johndoe" 发送信息 :
```shell
write {{johndoe}} {{pts/5}}
```
{% endraw %}{% raw %}
<h2 id="yarn-why">
  <a href="/zh/common/yarn-why.html">yarn-why</a> <a href="#yarn-why"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 确认安装这个 Yarn 软件包的原因.
> 更多信息：<https://www.npmjs.com/package/yarn-why>.

#### 打印安装这个 Yarn 软件包的原因:
```shell
yarn-why {{package_name}}
```
{% endraw %}{% raw %}
<h2 id="yarn">
  <a href="/zh/common/yarn.html">yarn</a> <a href="#yarn"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> JavaScript 和 Node.js package manager 的一个替代.
> 更多信息：<https://yarnpkg.com>.

#### 全局安装一个模块:
```shell
yarn global add {{module_name}}
```
#### 安装 `package.json` 中指定的依赖 (`install` 命令是可选的 -- 你可以直接输入`yarn`):
```shell
yarn install
```
#### 安装一个模块并将其写入 `package.json` 中的依赖项 （增加 `--dev` 来作为开发依赖写入）:
```shell
yarn add {{module_name}}@{{version}}
```
#### 卸载一个模块并将其从 `package.json` 的依赖项中移除:
```shell
yarn remove {{module_name}}
```
#### 交互式地创建一个 `package.json` 文件:
```shell
yarn init
```
#### 确认一个模块是否是一个依赖项并且列出依赖其的模块:
```shell
yarn why {{module_name}}
```
{% endraw %}{% raw %}
<h2 id="z">
  <a href="/zh/common/z.html">z</a> <a href="#z"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 记录被使用次数最多的目录并允许在它们之间以字符串或正则表达式来进行匹配和跳转.
> 更多信息：<https://github.com/rupa/z>.

#### 跳转到一个名字带有 "foo" 的文件夹:
```shell
z {{foo}}
```
#### 跳转到一个名字带有 "foo" 并且后面带有 "bar" 的文件夹（例：`fooesbar`):
```shell
z {{foo}} {{bar}}
```
#### 跳转到名字带有 "foo" 并且拥有最高访问次数的文件夹:
```shell
z -r {{foo}}
```
#### 跳转到最近使用的名字带有 "foo" 的文件夹:
```shell
z -t {{foo}}
```
#### 列出在 `z` 的数据库中名字带有 "foo" 的文件夹:
```shell
z -l {{foo}}
```
#### 将当前文件夹从 `z`的数据库中移除:
```shell
z -x .
```
{% endraw %}{% raw %}
<h2 id="zsh">
  <a href="/zh/common/zsh.html">zsh</a> <a href="#zsh"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Z SHell.
> 与 `bash` 和 `sh` 兼容的命令行解释器.
> 更多信息：<https://www.zsh.org>.

#### 启动交互式解释器:
```shell
zsh
```
#### 执行从参数传入的命令:
```shell
zsh -c {{command}}
```
#### 从文件执行命令 （脚本）:
```shell
zsh {{file}}
```
#### 从文件执行命令并将执行过的命令打印到终端:
```shell
zsh -x {{file}}
```
{% endraw %}{% raw %}
<h2 id="zstd">
  <a href="/zh/common/zstd.html">zstd</a> <a href="#zstd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 使用 Zstandard 压缩来压缩 / 解压文件.
> 更多信息：<https://github.com/facebook/zstd>.

#### 将一个文件压缩到一个 `.zst` 后缀的压缩文件中:
```shell
zstd {{file}}
```
#### 解压缩一个文件:
```shell
zstd -d {{file}}.zst
```
#### 将文件解压缩到标准输出 (stdout):
```shell
zstd -dc {{file}}.zst
```
#### 使用指定的压缩等级来压缩一个文件.0 = 最差，19 = 最好 （默认等级是 3):
```shell
zstd -{{level}} {{file}}
```
#### 使用更多内存 （解压或压缩时） 来得到更高的压缩比:
```shell
zstd --ultra -{{level}} {{file}}
```
{% endraw %}# Android
{% raw %}
<h2 id="am">
  <a href="/zh/android/am.html">am</a> <a href="#am"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Android 活动管理器。
> 更多信息见：<https://developer.android.com/studio/command-line/adb#am>.

#### 启动一个指定的活动：
```shell
am start -n {{com.android.settings/.Settings}}
```
#### 启动一个活动并将数据传递给它：
```shell
am start -a {{android.intent.action.VIEW}} -d {{tel:123}}
```
#### 启动与特定操作和类别匹配的活动：
```shell
am start -a {{android.intent.action.MAIN}} -c {{android.intent.category.HOME}}
```
#### 将意图转换为 URI：
```shell
am to-uri -a {{android.intent.action.VIEW}} -d {{tel:123}}
```
{% endraw %}{% raw %}
<h2 id="bugreport">
  <a href="/zh/android/bugreport.html">bugreport</a> <a href="#bugreport"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示安卓的 Bug 报告。
> 该命令只能通过 `adb shell` 使用。
> 更多信息：<https://android.googlesource.com/platform/frameworks/native/+/master/cmds/bugreport/>.

#### 显示 Android 设备的完整错误报告：
```shell
bugreport
```
{% endraw %}{% raw %}
<h2 id="cmd">
  <a href="/zh/android/cmd.html">cmd</a> <a href="#cmd"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Android 服务管理器。
> 更多信息见： <https://cs.android.com/android/platform/superproject/+/master:frameworks/native/cmds/cmd/>.

#### 列出所有正在运行的服务：
```shell
cmd -l
```
#### 调用指定服务：
```shell
cmd {{alarm}}
```
#### 调用服务同时传递参数：
```shell
cmd {{vibrator}} {{vibrate 300}}
```
{% endraw %}{% raw %}
<h2 id="dalvikvm">
  <a href="/zh/android/dalvikvm.html">dalvikvm</a> <a href="#dalvikvm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> Android Java 虚拟机。
> 更多信息见：<https://source.android.com/devices/tech/dalvik>.

#### 启动一个 Java 程序：
```shell
dalvikvm -classpath {{path/to/file.jar}} {{classname}}
```
{% endraw %}{% raw %}
<h2 id="dumpsys">
  <a href="/zh/android/dumpsys.html">dumpsys</a> <a href="#dumpsys"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 提供关于 Android 系统服务的信息。
> 此命令只能通过 `adb shell` 使用。
> 更多信息见：https://developer.android.com/studio/command-line/dumpsys>.

#### 获取所有系统服务的诊断输出：
```shell
dumpsys
```
#### 获取指定系统服务的诊断输出：
```shell
dumpsys {{服务}}
```
#### 列出 `dumpsys` 可以提供的所有服务信息：
```shell
dumpsys -l
```
#### 列出服务的指定服务参数：
```shell
dumpsys {{服务}} -h
```
#### 从诊断输出中排除指定服务：
```shell
dumpsys --skip {{服务}}
```
#### 指定超时时间，以秒为单位（默认为 10s）：
```shell
dumpsys -t {{秒数}}
```
{% endraw %}{% raw %}
<h2 id="getprop">
  <a href="/zh/android/getprop.html">getprop</a> <a href="#getprop"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示关于 Android 系统属性的信息。
> 更多信息见：<https://manned.org/getprop>.

#### 显示关于 Android 系统属性的信息：
```shell
getprop
```
#### 显示关于指定属性的信息：
```shell
getprop {{prop}}
```
#### 显示 SDK API 级别：
```shell
getprop {{ro.build.version.sdk}}
```
#### 显示 Android 版本：
```shell
getprop {{ro.build.version.release}}
```
#### 显示 Android 设备型号：
```shell
getprop {{ro.vendor.product.model}}
```
#### 显示 OEM 解锁状态：
```shell
getprop {{ro.oem_unlock_supported}}
```
#### 显示 Android WiFi 卡的 MAC 地址：
```shell
getprop {{ro.boot.wifimacaddr}}
```
{% endraw %}{% raw %}
<h2 id="input">
  <a href="/zh/android/input.html">input</a> <a href="#input"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 将事件代码或触摸屏手势发送到 Android 设备。
> 此命令只能通过 `adb shell` 使用。
> 更多信息见：<https://developer.android.com/reference/android/view/KeyEvent.html#constants_1>.

#### 将单个字符的事件代码发送到 Android 设备：
```shell
input keyevent {{event_code}}
```
#### 将文本发送到Android设备（`%s` 代表空格）：
```shell
input text "{{text}}"
```
#### 将轻触发送到 Android 设备：
```shell
input tap {{x_pos}} {{y_pos}}
```
#### 将滑动手势发送到 Android 设备：
```shell
input swipe {{x_start}} {{y_start}} {{x_end}} {{y_end}} {{duration_in_ms}}
```
#### 使用滑动手势将长按发送到 Android 设备：
```shell
input swipe {{x_pos}} {{y_pos}} {{x_pos}} {{y_pos}} {{duration_in_ms}}
```
{% endraw %}{% raw %}
<h2 id="logcat">
  <a href="/zh/android/logcat.html">logcat</a> <a href="#logcat"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 转储系统消息日志。
> 更多信息见：https://developer.android.com/studio/command-line/logcat>.

#### 显示系统日志：
```shell
logcat
```
#### 将系统日志写入文件：
```shell
logcat -f {{文件路径}}
```
#### 显示与正则表达式匹配的行：
```shell
logcat --regex {{正则表达式}}
```
{% endraw %}{% raw %}
<h2 id="pm">
  <a href="/zh/android/pm.html">pm</a> <a href="#pm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示关于 Android 设备上的应用程序的信息。
> 更多信息见：<https://developer.android.com/studio/command-line/adb#pm>.

#### 打印所有已安装应用程序的列表：
```shell
pm list packages
```
#### 打印所有已安装的系统应用程序的列表：
```shell
pm list packages -s
```
#### 打印所有已安装的第三方应用程序的列表：
```shell
pm list packages -3
```
#### 打印与指定关键字匹配的应用程序列表：
```shell
pm list packages {{关键词}}
```
#### 打印指定应用的 APK 的路径：
```shell
pm path {{应用名}}
```
{% endraw %}{% raw %}
<h2 id="settings">
  <a href="/zh/android/settings.html">settings</a> <a href="#settings"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 获取关于 Android OS 的信息。
> 更多信息见：https://adbinstaller.com/commands/adb-shell-settings-5b670d5ee7958178a2955536>.

#### 在 `全局` 命名空间中显示环境变量列表：
```shell
settings list {{global}}
```
#### 获取指定环境变量的值：
```shell
settings get {{global}} {{airplane_mode_on}}
```
#### 设置指定环境变量的值：
```shell
settings put {{system}} {{screen_brightness}} {{42}}
```
#### 删除指定环境变量：
```shell
settings delete {{secure}} {{screensaver_enabled}}
```
{% endraw %}{% raw %}
<h2 id="wm">
  <a href="/zh/android/wm.html">wm</a> <a href="#wm"><svg class="icon">
    <use href="/assets/images/unicode_sprite.svg#link" />
  </svg></a>
</h2>
> 显示关于 Android 设备屏幕的信息。
> 此命令只能通过 `adb shell` 使用。
> 更多信息见：<https://adbinstaller.com/commands/adb-shell-wm-5b672b17e7958178a2955538>.

#### 显示 Android 设备屏幕的物理尺寸：
```shell
wm {{size}}
```
#### 显示 Android 设备屏幕的物理密度：
```shell
wm {{density}}
```
{% endraw %}